<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TKD Championship 2025 — Quản lý giải Pickleball V21 GitHub (Sân CK là Sân 3 & Sửa Lịch mẫu & Sân 1-8)</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body { background:#f7f9fc; font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial; color:#222; padding:18px; }
    .tab-content { margin-top: 18px; }
    .logo { 
      width:64px; 
      height:64px; 
      object-fit:contain; 
      border-radius:8px; 
      border:1px solid #e6eefc; 
      padding:6px; 
      background:#fff; 
    }
    table th { background:#0d6efd; color:#fff; position:sticky; top:0; }
    .status { font-size:0.95rem; color:#555; }
    /* Responsive adjustment for match inputs */
    .match-score-cell input {
      width: 45px;
      text-align: center;
      padding: 0.1rem;
    }
    @media (max-width: 576px) {
      .match-score-cell input {
        width: 35px;
      }
    }
    .winner { font-weight: bold; color: green; }
    .loser { color: red; }
    .ranking-container { display: flex; flex-direction: column; gap: 20px; }
    @media (min-width: 768px) {
        .ranking-container { flex-direction: row; }
        .ranking-container > div { flex: 1; }
    }
  </style>
</head>
<body>
<div class="container">
  <div class="d-flex justify-content-between align-items-center mb-3">
    <div class="d-flex align-items-center gap-2">
      <img class="logo" src="data/logoTKD.png" alt="Logo TKD">
      <div>
        <h3 class="mb-0">TKD Championship 2025</h3>
        <div>Ngày thi đấu: 18/10/2025 (**V21**)</div>
      </div>
    </div>
    <div>
      <div id="autoSaveStatus" class="text-end status">Auto-save: <span id="autoState" class="text-danger">Tắt</span></div>
      <div id="lastSaved" class="text-end status">Chưa lưu</div>
    </div>
  </div>

  <ul class="nav nav-tabs" id="mainTabs">
    <li class="nav-item"><button class="nav-link active" data-bs-toggle="tab" data-bs-target="#overview" onclick="renderOverview()">Tổng quan</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#matches" id="matchesTabButton" onclick="renderMatchesView()">Vòng Bảng</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#finals" onclick="renderFinals()">Vòng Chung Kết</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#results" onclick="tinhVaCapNhatXepHang(); renderFinalResults();">Kết quả Chung cuộc</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#config" id="configTabButton" onclick="renderConfig()">Cấu hình</button></li>
  </ul>

  <div class="tab-content">
    <div class="tab-pane fade show active p-3" id="overview">
        <div id="overviewContent">Đang tải dữ liệu...</div>
    </div>
    
    <div class="tab-pane fade p-3" id="matches">
      <div class="d-flex gap-2 mb-3 flex-wrap">
        <label for="viewMode" class="form-label mb-0 align-self-center text-nowrap">Chế độ xem:</label>
        <select id="viewMode" class="form-select form-select-sm w-auto" onchange="renderMatchesView()">
            <option value="table">Theo Bảng đấu</option>
            <option value="court" selected>Theo Sân thi đấu</option>
        </select>
        
        <button class="btn btn-sm btn-info ms-auto" onclick="document.getElementById('fileInput').click()">Import Lịch (CSV)</button>
        <input type="file" id="fileInput" accept=".csv" style="display: none;" onchange="handleFileSelect(event)">
        
        <button class="btn btn-sm btn-warning" onclick="exportSchedule()">Export Lịch (CSV)</button>
      </div>
      
      <div id="matchesViewContent">
        <h6 id="scheduleAHeader" class="mt-4">Bảng A (Nam - Nữ)</h6><div id="tableMatchesA">Chưa có lịch thi đấu.</div>
        
        <h6 class="mt-4">Bảng B (Nam)</h6><div id="tableMatchesB">Chưa có lịch thi đấu.</div>
      </div>

      <button class="btn btn-warning mt-4" onclick="scheduleFinalsAuto()">Lên lịch Vòng Chung kết (Tự động hóa)</button>
    </div>

    <div class="tab-pane fade p-3" id="finals">
        <div id="finalsContent">
            <h6 class="mt-4">Vòng Bán kết (SF1: 16:40, SF2: 17:05, Sân 3)</h6>
            <div id="semifinalMatches">Chưa có lịch thi đấu bán kết. Kết quả Vòng Bảng sẽ tự động cập nhật lịch.</div>

            <h6 class="mt-4">Trận Chung kết (17:30, Sân 3)</h6>
            <div id="finalMatch">Chưa có lịch thi đấu chung kết.</div>
        </div>
    </div>

    <div class="tab-pane fade p-3" id="results">
        <h5 class="mb-3">Bảng xếp hạng Vòng Bảng (Ưu tiên: W > Đối đầu > Hiệu số > Tổng điểm)</h5>
        <div id="rankingTables" class="ranking-container">
            </div>

        <hr class="my-4">

        <h5 class="mb-3">Danh hiệu Chung cuộc</h5>
        <p id="champion">Vô địch: Đang chờ kết quả...</p>
        <p id="runnerUp">Á quân: Đang chờ kết quả...</p>
        <p id="thirdPlace">Hạng Ba Đồng Hạng: Đang chờ kết quả...</p>
    </div>

    <div class="tab-pane fade p-3" id="config">
      <h5 class="mb-3">Công cụ Lập & Điền Lịch Thi đấu</h5>
      <div class="d-flex gap-2 mb-4 flex-wrap">
        <button class="btn btn-sm btn-primary" onclick="taoLichThiDauCungGio()">Tạo lịch thi đấu Tối ưu (Tự động)</button>
        <button class="btn btn-sm btn-secondary" onclick="taoLichCoDinh()">Tải lịch Mẫu (**CalendarTKD30**)</button>
        <button class="btn btn-sm btn-success" onclick="autoFillScores()">Điền kết quả Tự động (11 - X)</button>
        <button class="btn btn-sm btn-danger" onclick="clearAllSchedules()">Xóa Toàn bộ Lịch</button>
      </div>
      
      <hr>

      <h5 class="mt-4">⚙️ Cấu hình Sân thi đấu & Lịch Tối ưu</h5>
      <p class="text-muted small">Quản lý danh sách sân thi đấu. Sân được gán loại bảng đấu (A/B) để phục vụ chức năng tạo lịch Tối ưu.</p>
      <div class="d-flex gap-2 mb-3 flex-wrap">
          <button class="btn btn-sm btn-primary" onclick="openCourtModal()">+ Thêm Sân Mới</button>
          <button class="btn btn-sm btn-outline-info" onclick="loadDefaultCourtConfig()">Tải cấu hình Mặc định</button>
      </div>
      <div id="courtListContainer">
          </div>
      <div id="courtConfigStatus"></div>
      <hr>
      
      <h5 class="mt-4">🛠️ Cấu hình Tối ưu Lịch thi đấu</h5>
      <div class="row g-2 mb-4">
        <div class="col-md-6">
          <label for="preferredCourtType" class="form-label">Ưu tiên Sân nào cho trận đầu tiên (Chức năng Tạo lịch Tối ưu)?</label>
          <select id="preferredCourtType" class="form-select" onchange="updatePreferredCourtType()">
            <option value="mixed">Bảng A (Nam - Nữ) - Mặc định</option>
            <option value="male">Bảng B (Nam)</option>
          </select>
          <div class="form-text">Xác định loại sân sẽ được ưu tiên gán trận đấu đầu tiên trong thuật toán tạo lịch.</div>
        </div>
      </div>
      <hr>
      <h5 class="mt-4">💾 Cấu hình Kết nối GitHub</h5>
      <p class="text-muted">Nhập thông tin kho lưu trữ GitHub để tự động lưu trữ dữ liệu giải đấu.</p>
      <div class="row g-2 mb-2">
        <div class="col-md-3"><input id="cfgOwner" class="form-control" placeholder="Owner (Ví dụ: user_name)"></div>
        <div class="col-md-3"><input id="cfgRepo" class="form-control" placeholder="Repo (Ví dụ: my-data-repo)"></div>
        <div class="col-md-3"><input id="cfgFolder" class="form-control" value="data"></div>
        <div class="col-md-3"><input id="cfgFile" class="form-control" value="state.json"></div>
      </div>
      <input id="cfgToken" type="password" class="form-control mb-2" placeholder="Dán GitHub Personal Access Token (PAT) tại đây">
      <div class="d-flex gap-2">
        <button class="btn btn-primary" onclick="saveConfig()">Lưu cấu hình Local</button>
        <button class="btn btn-success" onclick="checkConnection()">Kiểm tra & Tải Dữ liệu</button>
      </div>
      <div class="mt-2" id="configStatus"></div>
      
      <div class="card bg-light mt-4 shadow-sm">
        <div class="card-body">
            <h5 class="card-title text-info">🔑 Hướng dẫn lấy GitHub Token (PAT)</h5>
            <ol class="small mb-0">
                <li>Truy cập <a href="https://github.com/settings/tokens" target="_blank" class="text-info">GitHub Tokens Settings</a> (Bạn cần đăng nhập).</li>
                <li>Chọn **Generate new token** (hoặc **Generate new token (classic)** nếu bạn dùng tài khoản cũ).</li>
                <li>**Tên Token:** Đặt tên dễ nhớ (ví dụ: `TKDManager_AutoSave`).</li>
                <li>**Thời hạn:** Chọn tùy ý (nên chọn 90 ngày hoặc Tùy chỉnh).</li>
                <li>**Phạm vi (Scopes):** **BẮT BUỘC** tích chọn ô **`repo`** (cho phép truy cập vào kho lưu trữ).</li>
                <li>Nhấn **Generate token** và **SAO CHÉP** chuỗi Token vừa được tạo.</li>
                <li>Dán chuỗi Token đó vào ô "Dán GitHub Personal Access Token (PAT) tại đây" bên trên.</li>
            </ol>
            <p class="mt-2 mb-0 text-danger small">⚠️ **Lưu ý:** Token chỉ hiển thị **MỘT LẦN**. Hãy sao chép ngay lập tức và giữ bí mật. Nếu mất, bạn phải tạo lại Token mới.</p>
        </div>
      </div>
      </div>
  </div>
</div>

<div class="modal fade" id="courtModal" tabindex="-1" aria-labelledby="courtModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="courtModalLabel">Thêm/Sửa Cấu hình Sân</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="courtForm">
          <input type="hidden" id="courtIndex" value="">
          <div class="mb-3">
            <label for="courtName" class="form-label">Tên Sân</label>
            <input type="text" class="form-control" id="courtName" required>
          </div>
          <div class="mb-3">
            <label for="courtStartTime" class="form-label">Giờ Bắt Đầu (HH:mm)</label>
            <input type="time" class="form-control" id="courtStartTime" required>
          </div>
          <div class="mb-3">
            <label for="courtMaxDuration" class="form-label">Thời Lượng Tối Đa (Phút)</label>
            <input type="number" class="form-control" id="courtMaxDuration" min="1" required>
          </div>
          <div class="form-check mb-3">
            <input class="form-check-input" type="checkbox" id="courtIsMixed">
            <label class="form-check-label" for="courtIsMixed">
              Dành cho Bảng A (Nam - Nữ)
            </label>
            <div class="form-text">Nếu không chọn, sân sẽ dành cho Bảng B (Nam).</div>
          </div>
          <div id="courtFormStatus" class="mt-2"></div>
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Hủy</button>
        <button type="button" class="btn btn-primary" onclick="saveCourtChanges()">Lưu Thay Đổi</button>
      </div>
    </div>
  </div>
</div>
<div class="modal fade" id="customAlertModal" tabindex="-1" aria-labelledby="customAlertModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="customAlertModalLabel">Thông báo</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="customAlertModalBody">
        Nội dung thông báo
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Đóng</button>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script> 

<script>
// Dữ liệu lịch cố định từ file CalendarTKD30.csv (ĐÃ CẬP NHẬT theo yêu cầu)
const FIXED_SCHEDULE_CSV = `teamA,teamB,time,court,bang,scoreA,scoreB
Triều/Minh,Hiển/P.Hùng,14:00,Sân 1,B,,
Giang/Long,Hường/Đạt,14:00,Sân 2,A,,
Hậu/Dũng,Hạnh/Tiến,14:00,Sân 3,A,,
Huyền/Luân,Linh/M.Hùng,14:00,Sân 7,A,,
Tiệp/Thủy,Phương/Thanh,14:15,Sân 1,B,,
Tín/Khiêm,Ánh/Toàn,14:15,Sân 2,B,,
Hậu/Dũng,Hường/Đạt,14:15,Sân 3,A,,
Giang/Long,Huyền/Luân,14:15,Sân 7,A,,
Triều/Minh,Tín/Khiêm,14:30,Sân 1,B,,
Tiệp/Thủy,Hiển/P.Hùng,14:30,Sân 2,B,,
Hạnh/Tiến,Linh/M.Hùng,14:30,Sân 3,A,,
Phương/Thanh,Ánh/Toàn,14:30,Sân 7,B,,
Huyền/Luân,Hường/Đạt,14:45,Sân 2,A,,
Hạnh/Tiến,Giang/Long,14:45,Sân 3,A,,
Hậu/Dũng,Linh/M.Hùng,14:45,Sân 7,A,,
Tiệp/Thủy,Ánh/Toàn,15:00,Sân 2,B,,
Tín/Khiêm,Hiển/P.Hùng,15:00,Sân 3,B,,
Phương/Thanh,Triều/Minh,15:15,Sân 2,B,,
Giang/Long,Linh/M.Hùng,15:15,Sân 3,A,,
Hạnh/Tiến,Hường/Đạt,15:30,Sân 2,A,,
Hậu/Dũng,Huyền/Luân,15:30,Sân 3,A,,
Tiệp/Thủy,Tín/Khiêm,15:45,Sân 2,B,,
Phương/Thanh,Hiển/P.Hùng,15:45,Sân 3,B,,
Triều/Minh,Ánh/Toàn,16:00,Sân 2,B,,
Hậu/Dũng,Giang/Long,16:00,Sân 3,A,,
Hạnh/Tiến,Huyền/Luân,16:15,Sân 2,A,,
Linh/M.Hùng,Hường/Đạt,16:15,Sân 3,A,,
Tiệp/Thủy,Triều/Minh,16:30,Sân 2,B,,
Ánh/Toàn,Hiển/P.Hùng,16:30,Sân 3,B,,
Phương/Thanh,Tín/Khiêm,16:45,Sân 2,B,`;

// Biến state lưu trữ dữ liệu chính của ứng dụng.
let state = { 
  mixedTeams: [], // Sẽ được tải từ players.json
  maleTeams: [],  // Sẽ được tải từ players.json
  matchesA: [], 
  matchesB: [],
  tableA: [], // Bảng xếp hạng A
  tableB: [], // Bảng xếp hạng B
  
  // NEW: Court Configuration (ĐÃ CẬP NHẬT SÂN 1 -> SÂN 8)
  courts: [
    { name: 'Sân 1', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, // Bảng A (Mixed)
    { name: 'Sân 2', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, // Bảng A (Mixed)
    { name: 'Sân 3', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, // Bảng A (Mixed)
    { name: 'Sân 4', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, // Bảng A (Mixed)
    { name: 'Sân 5', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }, // Bảng B (Male)
    { name: 'Sân 6', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }, // Bảng B (Male)
    { name: 'Sân 7', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }, // Bảng B (Male)
    { name: 'Sân 8', startTime: '14:00', maxDurationMinutes: 180, isMixed: false } // Bảng B (Male)
  ],
  
  // LOGIC BÁN KẾT (ĐÃ CẬP NHẬT SÂN MẶC ĐỊNH LÀ SÂN 3 VÀ THỜI GIAN MỚI)
  semifinals: [
    { id: 'SF1', teamA: 'Nhất A', teamB: 'Nhì A', scoreA: null, scoreB: null, time: '16:40', court: 'Sân 3', winner: null, loser: null }, // Đã điều chỉnh
    { id: 'SF2', teamA: 'Nhất B', teamB: 'Nhì B', scoreA: null, scoreB: null, time: '17:05', court: 'Sân 3', winner: null, loser: null }  // Đã điều chỉnh
  ],
  final: { id: 'F', teamA: 'Thắng SF1', teamB: 'Thắng SF2', scoreA: null, scoreB: null, time: '17:30', court: 'Sân 3', winner: null, runnerUp: null }, // Đã điều chỉnh
  config: { 
    preferredCourtType: 'mixed' // NEW: Ưu tiên sân cho thuật toán xếp lịch
  }
};

let stateChanged = false; // Biến cờ theo dõi thay đổi dữ liệu
let currentSha = null; // Biến lưu trữ SHA của file trên GitHub
let autoSaveInterval = null; // Biến lưu trữ ID của interval

// --- Custom Modal Function ---
function showModal(title, body) {
    document.getElementById('customAlertModalLabel').textContent = title;
    document.getElementById('customAlertModalBody').innerHTML = body;
    const modal = new bootstrap.Modal(document.getElementById('customAlertModal'));
    modal.show();
}

/**
 * Hàm chuyển đổi tab
 * @param {string} tabId - ID của tab cần chuyển (ví dụ: 'matches', 'overview')
 */
function switchTab(tabId) {
    const tabElement = document.querySelector(`#mainTabs button[data-bs-target="#${tabId}"]`);
    if (tabElement) {
        // Tắt tab đang active
        document.querySelectorAll('#mainTabs .nav-link').forEach(btn => btn.classList.remove('active'));
        document.querySelectorAll('.tab-content .tab-pane').forEach(pane => pane.classList.remove('show', 'active'));

        // Bật tab mới
        tabElement.classList.add('active');
        document.getElementById(tabId).classList.add('show', 'active');
        
        // Cập nhật view cho tab matches nếu chuyển đến
        if (tabId === 'matches') {
            renderMatchesView();
        }
    }
}

// --- Helper Functions cho Base64 ---
function b64EncodeUnicode(str) {
  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g,
    function(match, p1) {
      return String.fromCharCode('0x' + p1);
    }));
}

function b64DecodeUnicode(str) {
  return decodeURIComponent(atob(str).split('').map(function(c) {
    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
  }).join(''));
}

// --- GitHub API Functions ---

/**
 * Lấy SHA mới nhất của file state.json trên GitHub.
 * @param {object} cfg - Cấu hình GitHub (owner, repo, folder, file, token)
 * @returns {Promise<{sha: string|null, content: string|null}>}
 */
async function fetchFileSha(cfg, fileName = cfg.file) {
    const filePath = `${cfg.folder}/${fileName}`;
    const apiUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}/contents/${filePath}`;
    
    try {
        const response = await fetch(apiUrl, {
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });
        
        if (response.ok) {
            const data = await response.json();
            if (fileName === cfg.file) {
                 currentSha = data.sha; // Chỉ lưu SHA của state.json
            }
            return { sha: data.sha, content: data.content };
        } else if (response.status === 404) {
            if (fileName === cfg.file) {
                 currentSha = null; 
            }
            return { sha: null, content: null };
        } else {
            throw new Error(`Lỗi khi lấy SHA: ${response.statusText}`);
        }
    } catch (error) {
        console.error(`Lỗi Fetch SHA (${fileName}):`, error);
        throw new Error(`Lỗi kết nối hoặc API: ${error.message}`);
    }
}

/**
 * Tải danh sách đội từ players.json
 */
async function loadPlayersFromGitHub(cfg) {
    // players.json phải nằm cùng thư mục với state.json
    const fileName = 'players.json';
    
    try {
        updateStatus('configStatus', 'info', 'Đang tải danh sách đội từ GitHub (players.json)...');
        const result = await fetchFileSha(cfg, fileName); 
        
        if (result.content) {
            const jsonString = b64DecodeUnicode(result.content);
            const loadedTeams = JSON.parse(jsonString);

            if (Array.isArray(loadedTeams.mixedTeams) && Array.isArray(loadedTeams.maleTeams)) {
                state.mixedTeams = loadedTeams.mixedTeams;
                state.maleTeams = loadedTeams.maleTeams;
                updateStatus('configStatus', 'success', `Tải danh sách đội thành công (${state.mixedTeams.length + state.maleTeams.length} đội).`);
                return true;
            } else {
                throw new Error("File players.json không đúng định dạng (thiếu mixedTeams/maleTeams).");
            }
        } else {
             // 404 hoặc không có content
            updateStatus('configStatus', 'warning', 'Không tìm thấy file players.json. Dùng danh sách đội khởi tạo (trống).');
            return false;
        }
    } catch (error) {
        console.error("Lỗi khi tải players.json:", error);
        updateStatus('configStatus', 'danger', `Lỗi tải danh sách đội: ${error.message}`);
        return false;
    }
}

/**
 * Tải trạng thái giải đấu (state.json) từ GitHub.
 */
async function loadFromGitHub() {
    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) return;

    // 1. Load Teams (danh sách đội)
    await loadPlayersFromGitHub(cfg); 

    // 2. Load App State (state.json)
    try {
        updateStatus('configStatus', 'info', 'Đang tải trạng thái giải đấu từ GitHub (state.json)...');
        // fetchFileSha sẽ tự động cập nhật currentSha
        const result = await fetchFileSha(cfg, cfg.file); 
        
        if (result.content) {
            const jsonString = b64DecodeUnicode(result.content);
            const loadedState = JSON.parse(jsonString);

            // Ghi đè các giá trị khác ngoài teams (teams đã được load từ players.json)
            state.matchesA = loadedState.matchesA || [];
            state.matchesB = loadedState.matchesB || [];
            
            // Tải cấu hình sân (NEW) - nếu không có, giữ nguyên mặc định
            if (loadedState.courts) {
                state.courts = loadedState.courts;
            }
            
            // Xử lý logic tải cho semifinals và final (đảm bảo không ghi đè lịch tự động)
            const loadedSemifinals = loadedState.semifinals;
            
            // Cấu trúc mặc định mới: Nhất A vs Nhì A, Nhất B vs Nhì B, Sân 3, Time mới
            const defaultSF1 = { teamA: 'Nhất A', teamB: 'Nhì A', court: 'Sân 3', time: '16:40' };
            const defaultSF2 = { teamA: 'Nhất B', teamB: 'Nhì B', court: 'Sân 3', time: '17:05' };
            const defaultFinal = { teamA: 'Thắng SF1', teamB: 'Thắng SF2', court: 'Sân 3', time: '17:30' };

            
            if (loadedSemifinals && loadedSemifinals.length === 2 && 
                (loadedSemifinals[0].teamA !== defaultSF1.teamA || loadedSemifinals[0].teamB !== defaultSF1.teamB ||
                 loadedSemifinals[1].teamA !== defaultSF2.teamA || loadedSemifinals[1].teamB !== defaultSF2.teamB)
            ) {
                // Nếu đã có đội thực tế được gán, giữ nguyên (đã tính từ data vòng bảng)
                state.semifinals = loadedSemifinals;
            } else if (loadedSemifinals && loadedSemifinals.length === 2) {
                // Nếu là trạng thái rỗng, vẫn load (nhưng đảm bảo court và time là mới)
                 state.semifinals = loadedSemifinals.map((sf, index) => {
                    const defaultTime = index === 0 ? '16:40' : '17:05';
                    if (sf.teamA === 'Nhất A' || sf.teamA === 'Nhất B') {
                        return { ...sf, court: 'Sân 3', time: defaultTime };
                    }
                    return sf;
                });
            }

            // Đảm bảo final court và time là mới nếu chưa có winner
            state.final = loadedState.final || state.final;
            if (!state.final.winner) {
                state.final.court = defaultFinal.court;
                state.final.time = defaultFinal.time;
            } else if (loadedState.final && !loadedState.final.time) {
                // Nếu có winner nhưng không có time (từ phiên bản cũ), cập nhật time
                 state.final.time = defaultFinal.time;
            }
            
            // Cập nhật giao diện
            renderMatchesView(); 
            tinhVaCapNhatXepHang();
            renderFinals();
            renderFinalResults();
            renderOverview();
            
            updateStatus('configStatus', 'success', `Tải trạng thái giải đấu thành công từ: ${cfg.owner}/${cfg.repo}/${cfg.folder}/${cfg.file}`);
            document.getElementById('lastSaved').textContent = `Lần tải: ${new Date().toLocaleTimeString('vi-VN')}`;
        } else {
            updateStatus('configStatus', 'warning', 'File trạng thái (state.json) chưa tồn tại. Vui lòng nhấn Lưu hoặc Tự động lưu để tạo file.');
        }

        startAutoSave();

    } catch (error) {
        updateStatus('configStatus', 'danger', `Lỗi tải trạng thái giải đấu: ${error.message}. Vui lòng kiểm tra lại Token/Repo.`);
        console.error("Lỗi khi tải trạng thái giải đấu từ GitHub:", error);
    }
}

async function saveToGitHub() {
    // Bỏ qua nếu không có thay đổi
    if (!stateChanged) return;

    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) {
        console.warn("Không thể tự động lưu: Thiếu cấu hình GitHub.");
        document.getElementById('autoState').className = 'text-warning';
        document.getElementById('autoState').textContent = 'Tạm dừng (Thiếu Config)';
        return;
    }

    document.getElementById('autoState').className = 'text-info';
    document.getElementById('autoState').textContent = 'Đang lưu...';

    const apiUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}/contents/${cfg.folder}/${cfg.file}`;
    
    // Chỉ lưu các trường cần thiết, loại bỏ config và table (vì chúng được tính lại)
    const stateToSave = {
        mixedTeams: state.mixedTeams,
        maleTeams: state.maleTeams,
        matchesA: state.matchesA,
        matchesB: state.matchesB,
        courts: state.courts,
        semifinals: state.semifinals,
        final: state.final
    };
    const content = b64EncodeUnicode(JSON.stringify(stateToSave));
    
    try {
        // Luôn fetch SHA mới nhất trước khi cố gắng lưu
        const result = await fetchFileSha(cfg, cfg.file); // Lấy SHA của state.json
        const sha = result.sha; 
        
        const payload = {
            message: `[Auto-save] Cập nhật trạng thái giải đấu TKD lúc ${new Date().toLocaleString('vi-VN')}`,
            content: content
        };
        
        // Chỉ thêm SHA vào payload nếu nó đã tồn tại (để cập nhật), 
        if (sha) {
             payload.sha = sha;
        }

        const response = await fetch(apiUrl, {
            method: 'PUT',
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Content-Type': 'application/json',
                'Accept': 'application/vnd.github.v3+json'
            },
            body: JSON.stringify(payload)
        });

        if (response.ok) {
            const data = await response.json();
            currentSha = data.content.sha;
            stateChanged = false;
            document.getElementById('lastSaved').textContent = `Lần lưu: ${new Date().toLocaleTimeString('vi-VN')}`;
            document.getElementById('autoState').className = 'text-success';
            document.getElementById('autoState').textContent = 'Đã Lưu';
        } else {
            // Trường hợp lỗi 409 Conflict (SHA cũ)
            if (response.status === 409) {
                console.warn("Lỗi 409 Conflict: Dữ liệu đã thay đổi trên GitHub. Đang cố gắng lấy SHA mới.");
                
                // Lấy lại SHA mới nhất. stateChanged vẫn là true, 
                // để AutoSave interval sẽ thử lại với SHA mới trong lần tiếp theo.
                await fetchFileSha(cfg, cfg.file); 
                
                document.getElementById('autoState').className = 'text-warning';
                document.getElementById('autoState').textContent = 'Conflict. Sẽ thử lưu lại sau 1 phút.';
            } else {
                throw new Error(`Lỗi HTTP: ${response.status} - ${response.statusText}`);
            }
        }
    } catch (error) {
        console.error("Lỗi khi lưu lên GitHub:", error);
        document.getElementById('autoState').className = 'text-danger';
        document.getElementById('autoState').textContent = 'Lỗi Lưu';
    }
}

async function checkConnection() {
    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) {
        updateStatus('configStatus', 'warning', 'Vui lòng nhập đầy đủ Owner, Repo và Token.');
        return;
    }

    try {
        updateStatus('configStatus', 'info', 'Đang kiểm tra kết nối...');
        
        const repoCheckUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}`;
        const repoResponse = await fetch(repoCheckUrl, {
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });

        if (!repoResponse.ok) {
            throw new Error(`Lỗi truy cập kho lưu trữ. Mã: ${repoResponse.status}. (Kiểm tra Token/Repo/Owner)`);
        }
        
        updateStatus('configStatus', 'success', 'Kết nối GitHub thành công! Đang tải dữ liệu...');
        await loadFromGitHub();

    } catch (error) {
        updateStatus('configStatus', 'danger', `Kiểm tra kết nối thất bại: ${error.message}.`);
        console.error("Lỗi kiểm tra kết nối:", error);
    }
}

/**
 * Cập nhật cấu hình ưu tiên sân cho tính năng Tạo lịch Tối ưu và lưu vào LocalStorage.
 */
function updatePreferredCourtType() {
    const select = document.getElementById('preferredCourtType');
    if (select) {
        state.config.preferredCourtType = select.value;
        saveConfig(); // Lưu cấu hình Local (bao gồm cả court preference)
        updateStatus('configStatus', 'success', `Đã cập nhật ưu tiên sân thành: ${select.options[select.selectedIndex].text}.`);
    }
}

// --- Cấu hình & Khởi tạo ---

function renderConfig() {
    // Chỉ cần hiển thị cấu hình sân hiện tại
    renderCourtList();
    document.getElementById('courtConfigStatus').innerHTML = '';
    
    // Cập nhật UI cho preferredCourtType khi vào tab config
    const select = document.getElementById('preferredCourtType');
    if (select) {
         select.value = state.config.preferredCourtType || 'mixed';
    }
}

/**
 * Hiển thị danh sách sân dưới dạng bảng với nút Sửa/Xóa.
 */
function renderCourtList() {
    const container = document.getElementById('courtListContainer');
    if (!container) return;
    
    if (state.courts.length === 0) {
        container.innerHTML = `<div class="alert alert-warning">Chưa có sân nào được cấu hình.</div>`;
        return;
    }
    
    let html = `<div class='table-responsive'><table class='table table-striped table-sm'>
        <thead>
            <tr>
                <th>Tên Sân</th>
                <th>Giờ Bắt Đầu</th>
                <th>Thời Lượng Max (Phút)</th>
                <th>Phân Loại</th>
                <th class="text-center">Hành động</th>
            </tr>
        </thead>
        <tbody>`;
        
    state.courts.forEach((court, index) => {
        const type = court.isMixed ? 'Bảng A (Nam - Nữ)' : 'Bảng B (Nam)';
        const typeClass = court.isMixed ? 'badge bg-primary' : 'badge bg-info';
        
        html += `<tr>
            <td>${court.name}</td>
            <td>${court.startTime}</td>
            <td>${court.maxDurationMinutes}</td>
            <td><span class="${typeClass}">${type}</span></td>
            <td class="text-center">
                <button class="btn btn-sm btn-outline-secondary me-1" onclick="openCourtModal(${index})">Sửa</button>
                <button class="btn btn-sm btn-outline-danger" onclick="deleteCourt(${index})">Xóa</button>
            </td>
        </tr>`;
    });
    
    html += `</tbody></table></div>`;
    container.innerHTML = html;
}

/**
 * Mở modal thêm/sửa sân và điền dữ liệu nếu là chế độ sửa.
 * @param {number | null} index - Chỉ số của sân cần sửa, hoặc null nếu thêm mới.
 */
function openCourtModal(index = null) {
    const modal = new bootstrap.Modal(document.getElementById('courtModal'));
    document.getElementById('courtFormStatus').innerHTML = '';

    document.getElementById('courtIndex').value = index !== null ? index : '';
    document.getElementById('courtModalLabel').textContent = index !== null ? 'Sửa Cấu hình Sân' : 'Thêm Sân Mới';

    if (index !== null) {
        const court = state.courts[index];
        document.getElementById('courtName').value = court.name || '';
        document.getElementById('courtStartTime').value = court.startTime || '14:00';
        document.getElementById('courtMaxDuration').value = court.maxDurationMinutes || 180;
        document.getElementById('courtIsMixed').checked = court.isMixed || false;
    } else {
        // Chế độ thêm mới: Reset form
        document.getElementById('courtName').value = '';
        document.getElementById('courtStartTime').value = '14:00';
        document.getElementById('courtMaxDuration').value = '180';
        document.getElementById('courtIsMixed').checked = true; // Default to Mixed (Bảng A)
    }

    modal.show();
}

/**
 * Lưu thay đổi từ modal vào state.courts
 */
function saveCourtChanges() {
    const indexStr = document.getElementById('courtIndex').value;
    const index = indexStr === '' ? null : parseInt(indexStr);
    
    const name = document.getElementById('courtName').value.trim();
    const startTime = document.getElementById('courtStartTime').value;
    const maxDurationMinutes = parseInt(document.getElementById('courtMaxDuration').value);
    const isMixed = document.getElementById('courtIsMixed').checked;

    const statusDiv = document.getElementById('courtFormStatus');

    // Validation
    if (!name || !startTime || isNaN(maxDurationMinutes) || maxDurationMinutes <= 0) {
        statusDiv.innerHTML = `<div class="alert alert-danger p-2">Vui lòng nhập đầy đủ và hợp lệ các trường (Tên, Giờ, Thời lượng > 0).</div>`;
        return;
    }
    
    // Check for duplicate name (excluding the current edited court)
    const isDuplicate = state.courts.some((c, i) => i !== index && c.name.toLowerCase() === name.toLowerCase()
    );
    if (isDuplicate) {
        statusDiv.innerHTML = `<div class="alert alert-danger p-2">Tên sân "${name}" đã tồn tại.</div>`;
        return;
    }

    const newCourt = { name, startTime, maxDurationMinutes, isMixed };

    if (index !== null) {
        // Edit mode
        state.courts[index] = newCourt;
    } else {
        // Add mode
        state.courts.push(newCourt);
    }

    // Close modal
    bootstrap.Modal.getInstance(document.getElementById('courtModal')).hide();

    // Update UI and save
    renderCourtList();
    stateChanged = true;
    updateStatus('courtConfigStatus', 'success', `Đã ${index !== null ? 'cập nhật' : 'thêm'} sân "${name}". Dữ liệu sẽ được tự động lưu lên GitHub.`);
    saveToGitHub();
}

/**
 * Xóa sân khỏi danh sách.
 * @param {number} index - Chỉ số của sân cần xóa.
 */
function deleteCourt(index) {
    if (confirm(`Bạn có chắc chắn muốn xóa sân "${state.courts[index].name}"?`)) {
        const deletedCourtName = state.courts[index].name;
        state.courts.splice(index, 1);
        renderCourtList();
        stateChanged = true;
        updateStatus('courtConfigStatus', 'success', `Đã xóa sân "${deletedCourtName}". Dữ liệu sẽ được tự động lưu lên GitHub.`);
        saveToGitHub();
    }
}

/**
 * Tải cấu hình mặc định (ĐÃ CẬP NHẬT SÂN 1 -> SÂN 8)
 */
function loadDefaultCourtConfig() {
    state.courts = [
      { name: 'Sân 1', startTime: '14:00', maxDurationMinutes: 180, isMixed: true },
      { name: 'Sân 2', startTime: '14:00', maxDurationMinutes: 180, isMixed: true },
      { name: 'Sân 3', startTime: '14:00', maxDurationMinutes: 180, isMixed: true },
      { name: 'Sân 4', startTime: '14:00', maxDurationMinutes: 180, isMixed: true },
      { name: 'Sân 5', startTime: '14:00', maxDurationMinutes: 180, isMixed: false },
      { name: 'Sân 6', startTime: '14:00', maxDurationMinutes: 180, isMixed: false },
      { name: 'Sân 7', startTime: '14:00', maxDurationMinutes: 180, isMixed: false },
      { name: 'Sân 8', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }
    ];
    renderCourtList();
    stateChanged = true;
    updateStatus('courtConfigStatus', 'success', 'Đã tải cấu hình sân Mặc định (Sân 1 -> Sân 8). Dữ liệu sẽ được tự động lưu lên GitHub.');
    saveToGitHub();
}

function loadConfig() {
    const savedConfig = localStorage.getItem('pkb_config');
    if (savedConfig) {
        state.config = JSON.parse(savedConfig);
        document.getElementById('cfgOwner').value = state.config.owner || '';
        document.getElementById('cfgRepo').value = state.config.repo || '';
        document.getElementById('cfgFolder').value = state.config.folder || 'data';
        document.getElementById('cfgFile').value = state.config.file || 'state.json';
        document.getElementById('cfgToken').value = state.config.token || '';

        // NEW: Load preferredCourtType và cập nhật UI (nếu có)
        state.config.preferredCourtType = state.config.preferredCourtType || 'mixed'; 
        const select = document.getElementById('preferredCourtType');
        if (select) {
             select.value = state.config.preferredCourtType;
        }
    } else {
        // Đảm bảo preferredCourtType có giá trị mặc định nếu chưa có config
        state.config.preferredCourtType = 'mixed';
    }
}

function saveConfig(){
    const cfg = {
        owner: document.getElementById('cfgOwner').value,
        repo: document.getElementById('cfgRepo').value,
        folder: document.getElementById('cfgFolder').value,
        file: document.getElementById('cfgFile').value,
        token: document.getElementById('cfgToken').value,
        // NEW: Lưu cấu hình ưu tiên sân
        preferredCourtType: state.config.preferredCourtType || 'mixed'
    };
    state.config = cfg;
    localStorage.setItem('pkb_config', JSON.stringify(cfg));
    updateStatus('configStatus', 'success', 'Đã lưu cấu hình GitHub vào trình duyệt. Vui lòng Kiểm tra & Tải Dữ liệu.');
}

function updateStatus(id, type, message) {
    const statusDiv = document.getElementById(id);
    statusDiv.innerHTML = `<div class="alert alert-${type} p-2 mt-2">${message}</div>`;
}

function startAutoSave() {
    if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
    }
    if (state.config.token && state.config.owner && state.config.repo) {
        autoSaveInterval = setInterval(saveToGitHub, 60000);
        document.getElementById('autoState').className = 'text-warning';
        document.getElementById('autoState').textContent = 'Hoạt động...';
    } else {
        document.getElementById('autoState').className = 'text-danger';
        document.getElementById('autoState').textContent = 'Tắt';
    }
}

window.onload = function() {
    loadConfig(); // Đã bao gồm load preferredCourtType

    // Đặt mặc định cho select box thành 'court' khi load trang (dù đã có 'selected' trong HTML)
    const viewModeSelect = document.getElementById('viewMode');
    if (viewModeSelect && viewModeSelect.value !== 'court') {
        viewModeSelect.value = 'court';
    }

    if (state.config.token) {
        // Bắt đầu quy trình tải Teams và App State từ GitHub
        loadFromGitHub();
    } else {
        // Tải cấu hình sân mặc định nếu không có kết nối GitHub
        renderConfig();
        renderMatchesView();
        tinhVaCapNhatXepHang();
        renderFinals();
        renderFinalResults();
        renderOverview();
        startAutoSave();
    }
};

// --- Tab Tổng quan ---
/**
 * Render danh sách đội đầy đủ cho Overview
 */
function renderTeamList(teams, title) {
    if (!teams || teams.length === 0) {
        return `<p class="small text-muted text-center">Chưa có danh sách đội cho ${title}.</p>`;
    }

    let html = `
        <div class="card mt-3 mb-3 shadow-sm">
            <div class="card-header bg-secondary text-white p-2">
                <h6 class="mb-0 small">${title} (${teams.length} đội)</h6>
            </div>
            <div class="card-body p-2">
                <ul class="list-unstyled mb-0 d-flex flex-wrap gap-3">`;
    teams.forEach(team => {
        html += `<li class="small text-nowrap"><strong>${team}</strong></li>`;
    });
    html += `
                </ul>
            </div>
        </div>
    `;
    return html;
}

function renderOverview() {
    const totalMatches = state.matchesA.length + state.matchesB.length;
    const completedMatches = [...state.matchesA, ...state.matchesB].filter(m => m.winner).length;

    // Đếm số trận đã hoàn thành và sắp xếp theo sân
    const matchesByCourt = {};
    const allMatches = [...state.matchesA, ...state.matchesB];

    // Lấy danh sách sân từ cấu hình
    const courtNames = state.courts.map(c => c.name);
    courtNames.forEach(name => {
        matchesByCourt[name] = { total: 0, completed: 0, matches: [] };
    });

    allMatches.forEach(match => {
        if (match.court) {
            if (!matchesByCourt[match.court]) {
                matchesByCourt[match.court] = { total: 0, completed: 0, matches: [] };
            }
            matchesByCourt[match.court].total += 1;
            if (match.winner) {
                matchesByCourt[match.court].completed += 1;
            }
            matchesByCourt[match.court].matches.push(match);
        }
    });

    let courtSummaryHTML = `<ul class="list-group">`;
    Object.entries(matchesByCourt).forEach(([courtName, data]) => {
        if (data.total > 0) {
            const progress = data.total > 0 ? ((data.completed / data.total) * 100).toFixed(0) : 0;
            const progressClass = progress == 100 ? 'bg-success' : (progress > 50 ? 'bg-warning' : 'bg-info');

            courtSummaryHTML += `
                <li class="list-group-item">
                    <div class="d-flex w-100 justify-content-between">
                        <h6 class="mb-1">${courtName}</h6>
                        <small>${data.completed}/${data.total} trận (${progress}%)</small>
                    </div>
                    <div class="progress mt-1" role="progressbar" style="height: 5px;">
                        <div class="progress-bar ${progressClass}" style="width: ${progress}%"></div>
                    </div>
                </li>
            `;
        }
    });
    courtSummaryHTML += `</ul>`;

    // Tổng quan
    let html = `
        ${renderTeamList(state.mixedTeams, 'Danh sách Đội Bảng A (Nam - Nữ)')}
        ${renderTeamList(state.maleTeams, 'Danh sách Đội Bảng B (Nam)')}
        
        <div class="card mb-4 shadow-sm">
            <div class="card-header bg-primary text-white">
                <h6>Tình hình Vòng Bảng</h6>
            </div>
            <div class="card-body">
                <p class="card-text">Tổng số trận đấu: <strong>${totalMatches}</strong></p>
                <p class="card-text">Số trận đã hoàn thành: <strong>${completedMatches}</strong></p>
                <p class="card-text">Tỉ lệ hoàn thành: <strong>${totalMatches > 0 ? ((completedMatches / totalMatches) * 100).toFixed(2) : 0}%</strong></p>
                <button class="btn btn-sm btn-outline-primary" onclick="switchTab('matches')">Xem chi tiết lịch thi đấu</button>
            </div>
        </div>

        <div class="card mb-4 shadow-sm">
            <div class="card-header bg-info text-white">
                <h6>Tiến độ theo Sân thi đấu</h6>
            </div>
            <div class="card-body p-0">
                ${courtSummaryHTML}
            </div>
        </div>

        <div class="row">
            <div class="col-md-6">
                <div class="card shadow-sm">
                    <div class="card-header bg-success text-white">
                        <h6>Bảng A (Nam - Nữ)</h6>
                    </div>
                    <div class="card-body p-2">
                        ${renderSimpleRanking(state.tableA)}
                    </div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="card shadow-sm">
                    <div class="card-header bg-danger text-white">
                        <h6>Bảng B (Nam)</h6>
                    </div>
                    <div class="card-body p-2">
                        ${renderSimpleRanking(state.tableB)}
                    </div>
                </div>
            </div>
        </div>
    `;

    document.getElementById('overviewContent').innerHTML = html;
}

/**
 * Hiển thị bảng xếp hạng đơn giản (Chỉ Top 4)
 */
function renderSimpleRanking(table) {
    if (table.length === 0) return `<p class="small text-muted p-2">Chưa đủ dữ liệu vòng bảng để xếp hạng.</p>`;
    
    let html = `<ol class="list-group list-group-flush small">`;
    table.slice(0, 4).forEach((team, index) => {
        const rank = index + 1;
        const rankClass = rank === 1 ? 'bg-warning' : (rank === 2 ? 'bg-info' : 'bg-secondary');

        html += `
            <li class="list-group-item d-flex justify-content-between align-items-center p-1">
                <span class="badge ${rankClass} me-2">${rank}</span>
                <strong class="text-truncate">${team.team}</strong>
                <small class="text-muted ms-auto">(${team.W}W-${team.L}L)</small>
            </li>
        `;
    });
    html += `</ol>`;
    return html;
}

// --- Tab Vòng Bảng (Matches) ---

/**
 * Render giao diện Vòng Bảng theo chế độ xem đã chọn (Table/Court)
 */
function renderMatchesView() {
    const viewMode = document.getElementById('viewMode').value;
    const container = document.getElementById('matchesViewContent');
    container.innerHTML = ''; // Clear previous content

    if (viewMode === 'table') {
        renderMatchesByGroup(container);
    } else if (viewMode === 'court') {
        renderMatchesByCourt(container);
    }
}

/**
 * Render Vòng Bảng theo cấu trúc Bảng A / Bảng B
 */
function renderMatchesByGroup(container) {
    const teamsA = state.mixedTeams.map(t => t.name); // Chỉ lấy tên đội
    const teamsB = state.maleTeams.map(t => t.name);

    let html = ``;

    // Bảng A
    html += `<h6 id="scheduleAHeader" class="mt-4">Bảng A (Nam - Nữ) - ${state.matchesA.length} trận</h6>`;
    html += renderMatchTable(state.matchesA, 'matchesA', teamsA);

    // Bảng B
    html += `<h6 class="mt-4">Bảng B (Nam) - ${state.matchesB.length} trận</h6>`;
    html += renderMatchTable(state.matchesB, 'matchesB', teamsB);

    container.innerHTML = html;
}

/**
 * Render Vòng Bảng theo cấu trúc Sân thi đấu
 */
function renderMatchesByCourt(container) {
    // 1. Gộp tất cả trận đấu
    const allMatches = [...state.matchesA.map(m => ({ ...m, group: 'matchesA', originalIndex: state.matchesA.indexOf(m) })), 
                        ...state.matchesB.map(m => ({ ...m, group: 'matchesB', originalIndex: state.matchesB.indexOf(m) }))]
                        .sort((a, b) => {
                            // Sắp xếp theo giờ thi đấu
                            const timeA = a.time || '99:99';
                            const timeB = b.time || '99:99';
                            if (timeA < timeB) return -1;
                            if (timeA > timeB) return 1;
                            
                            // Cùng giờ thì sắp xếp theo Sân
                            if (a.court < b.court) return -1;
                            if (a.court > b.court) return 1;
                            
                            return 0;
                        });
                        
    // 2. Gom nhóm theo Sân
    const matchesByCourt = allMatches.reduce((acc, match) => {
        const courtName = match.court || 'Chưa xếp sân';
        if (!acc[courtName]) {
            acc[courtName] = [];
        }
        acc[courtName].push(match);
        return acc;
    }, {});
    
    // 3. Render
    let html = ``;
    const courtNames = Object.keys(matchesByCourt).sort(); // Sắp xếp theo tên sân
    
    courtNames.forEach(courtName => {
        const courtMatches = matchesByCourt[courtName];
        const teams = courtMatches[0].bang === 'A' ? state.mixedTeams.map(t => t.name) : state.maleTeams.map(t => t.name);
        
        const completedCount = courtMatches.filter(m => m.winner).length;
        const totalCount = courtMatches.length;
        const progress = totalCount > 0 ? ((completedCount / totalCount) * 100).toFixed(0) : 0;
        
        html += `<h6 class="mt-4">${courtName} (Bảng ${courtMatches[0].bang || '?'}) - ${completedCount}/${totalCount} trận (${progress}%)</h6>`;
        
        // Cần truyền đúng group (matchesA/matchesB) và index của trận đấu trong group đó
        // Vì match trong courtMatches đã có group và index gốc
        html += renderMatchTable(courtMatches, 'dynamic', teams); 
    });

    container.innerHTML = html;
}

/**
 * Tạo HTML cho bảng kết quả các trận đấu
 * @param {Array} matches - Mảng các trận đấu (matchesA hoặc matchesB)
 * @param {string} group - Tên nhóm ('matchesA', 'matchesB', hoặc 'dynamic')
 * @param {Array} teams - Danh sách đội của bảng (để kiểm tra xem đội có tồn tại không)
 */
function renderMatchTable(matches, group, teams) {
    if (matches.length === 0) {
        return `<div class="alert alert-info">Chưa có lịch thi đấu cho nhóm này.</div>`;
    }

    let html = `
        <div class="table-responsive">
        <table class="table table-striped table-hover table-sm">
            <thead>
                <tr>
                    <th>Giờ</th>
                    <th>Sân</th>
                    <th>Đội A</th>
                    <th>Đội B</th>
                    <th class="text-center">A</th>
                    <th class="text-center">B</th>
                    <th>Thắng</th>
                </tr>
            </thead>
            <tbody>
    `;

    matches.forEach((match, index) => {
        // Nếu là chế độ 'dynamic', cần lấy index gốc từ trường 'originalIndex' và group gốc
        const matchIndex = group === 'dynamic' ? match.originalIndex : index;
        const matchGroup = group === 'dynamic' ? match.group : group;
        
        const teamA_Class = match.winner === match.teamA ? 'winner' : (match.loser === match.teamA ? 'loser' : '');
        const teamB_Class = match.winner === match.teamB ? 'winner' : (match.loser === match.teamB ? 'loser' : '');
        const matchRowClass = match.winner ? 'table-light' : '';
        
        // Kiểm tra xem đội có còn tồn tại trong danh sách không (tránh lỗi nếu danh sách đội bị load lại)
        const teamAValid = teams.includes(match.teamA);
        const teamBValid = teams.includes(match.teamB);
        const invalidClass = (match.teamA && !teamAValid) || (match.teamB && !teamBValid) ? 'table-danger' : '';

        html += `
            <tr class="${matchRowClass} ${invalidClass}">
                <td>${match.time || '-'}</td>
                <td>${match.court || '-'}</td>
                <td class="text-truncate ${teamA_Class}">${match.teamA}</td>
                <td class="text-truncate ${teamB_Class}">${match.teamB}</td>
                <td class="match-score-cell">
                    <input type="number" id="score-${matchGroup}-${matchIndex}-A" 
                        value="${match.scoreA !== null ? match.scoreA : ''}" 
                        min="0" onchange="updateScore('${matchGroup}', ${matchIndex})">
                </td>
                <td class="match-score-cell">
                    <input type="number" id="score-${matchGroup}-${matchIndex}-B" 
                        value="${match.scoreB !== null ? match.scoreB : ''}" 
                        min="0" onchange="updateScore('${matchGroup}', ${matchIndex})">
                </td>
                <td class="text-truncate small ${match.winner ? 'winner' : ''}">${match.winner || '-'}</td>
            </tr>
        `;
    });

    html += `
            </tbody>
        </table>
        </div>
    `;
    return html;
}

/**
 * Cập nhật điểm và xác định người thắng cuộc
 */
function updateScore(group, index) {
    const matchArray = group === 'matchesA' ? state.matchesA : state.matchesB;
    const match = matchArray[index];

    const scoreAInput = document.getElementById(`score-${group}-${index}-A`);
    const scoreBInput = document.getElementById(`score-${group}-${index}-B`);
    
    // Đảm bảo giá trị là số hoặc null
    const scoreA = scoreAInput.value === '' ? null : parseInt(scoreAInput.value);
    const scoreB = scoreBInput.value === '' ? null : parseInt(scoreBInput.value);

    // Cập nhật state
    match.scoreA = scoreA;
    match.scoreB = scoreB;
    match.winner = null;
    match.loser = null;

    if (scoreA !== null && scoreB !== null && scoreA !== scoreB) {
        if (scoreA > scoreB) {
            match.winner = match.teamA;
            match.loser = match.teamB;
        } else {
            match.winner = match.teamB;
            match.loser = match.teamA;
        }
    }

    // Cập nhật lại UI sau khi tính toán
    renderMatchesView(); 
    tinhVaCapNhatXepHang(); // Cần tính lại xếp hạng
    renderFinals(); // Cập nhật Vòng Chung kết
    
    stateChanged = true;
    saveToGitHub();
}

// --- Xếp hạng (Ranking) ---

/**
 * Hàm tính toán và cập nhật bảng xếp hạng cho cả hai bảng A và B.
 */
function tinhVaCapNhatXepHang() {
    state.tableA = tinhXepHang(state.mixedTeams, state.matchesA);
    state.tableB = tinhXepHang(state.maleTeams, state.matchesB);
    
    // Cập nhật lại giao diện Kết quả Chung cuộc (vì nó cũng dùng ranking)
    renderFinalResults();
    renderOverview();
}

/**
 * Hàm tính toán bảng xếp hạng
 * @param {Array<string>} teams - Danh sách tên các đội trong bảng (mixedTeams, maleTeams)
 * @param {Array} matches - Danh sách các trận đấu trong bảng (matchesA, matchesB)
 * @returns {Array<Object>} Bảng xếp hạng đã sắp xếp
 */
function tinhXepHang(teams, matches) {
    // 1. Khởi tạo bảng thống kê
    const stats = {};
    teams.forEach(team => {
        stats[team] = {
            team: team,
            W: 0, 
            L: 0, 
            PF: 0, // Points For (Điểm thắng)
            PA: 0, // Points Against (Điểm thua)
            PD: 0, // Point Difference (Hiệu số)
            matchesPlayed: 0
        };
    });

    // 2. Điền dữ liệu từ các trận đã hoàn thành
    matches.forEach(match => {
        if (match.winner) {
            const statA = stats[match.teamA];
            const statB = stats[match.teamB];

            if (!statA || !statB) return; // Bỏ qua nếu đội không còn trong danh sách

            statA.matchesPlayed++;
            statB.matchesPlayed++;
            
            // Cập nhật điểm PF/PA
            statA.PF += match.scoreA;
            statA.PA += match.scoreB;
            statB.PF += match.scoreB;
            statB.PA += match.scoreA;
            
            // Cập nhật W/L
            if (match.winner === match.teamA) {
                statA.W++;
                statB.L++;
            } else {
                statA.L++;
                statB.W++;
            }
        }
    });

    // 3. Tính hiệu số (PD)
    Object.values(stats).forEach(stat => {
        stat.PD = stat.PF - stat.PA;
    });

    // 4. Chuyển thành mảng và lọc các đội chưa đấu
    let table = Object.values(stats).filter(stat => stat.matchesPlayed > 0);
    
    // 5. Sắp xếp sơ bộ (W > Hiệu số)
    table.sort((a, b) => {
        if (b.W !== a.W) return b.W - a.W;      // 1. Thắng nhiều hơn
        if (b.PD !== a.PD) return b.PD - a.PD;  // 2. Hiệu số cao hơn
        if (b.PF !== a.PF) return b.PF - a.PF;  // 3. Tổng điểm thắng cao hơn
        return 0;
    });
    
    // 6. Xử lý tie-breaker bằng đối đầu (chỉ cho W bằng nhau)
    
    // Tìm các nhóm bị tie (cùng W)
    let finalTable = [];
    let i = 0;
    while (i < table.length) {
        let j = i;
        while (j < table.length && table[j].W === table[i].W) {
            j++;
        }
        
        const tiedGroup = table.slice(i, j);
        
        if (tiedGroup.length > 1) {
            // Chỉ áp dụng tie-breaker đối đầu nếu W, PD, PF BẰNG NHAU (tức là chỉ có W bằng nhau thôi)
            // Thay đổi logic: chỉ cần W bằng nhau, sau đó mới xét đến các tiêu chí phụ
            
            // Tìm các nhóm bị tie (cùng W)
            let subGroups = [];
            let k = i;
            while (k < j) {
                let l = k;
                while (l < j && table[l].W === table[k].W && table[l].PD === table[k].PD && table[l].PF === table[k].PF) {
                    l++;
                }
                subGroups.push(table.slice(k, l));
                k = l;
            }

            subGroups.forEach(subGroup => {
                if (subGroup.length > 1) {
                    // Áp dụng tie-breaker đối đầu cho nhóm có W, PD, PF bằng nhau
                    const headToHeadTable = tinhDiemDoiDau(subGroup, matches);
                    
                    // Sắp xếp lại nhóm con theo luật đối đầu (W > Hiệu số > Tổng điểm thắng)
                    headToHeadTable.sort((a, b) => {
                        if (b.W_H2H !== a.W_H2H) return b.W_H2H - a.W_H2H;
                        if (b.PD_H2H !== a.PD_H2H) return b.PD_H2H - a.PD_H2H;
                        if (b.PF_H2H !== a.PF_H2H) return b.PF_H2H - a.PF_H2H;
                        return 0; // Nếu vẫn hòa, giữ nguyên thứ tự ban đầu (hoặc bằng bốc thăm)
                    });
                    
                    // Gán lại các trường H2H và gộp vào finalTable
                    headToHeadTable.forEach(h2hStat => {
                        const originalStat = subGroup.find(s => s.team === h2hStat.team);
                        finalTable.push(originalStat);
                    });

                } else {
                    // Nhóm chỉ có 1 đội hoặc đã được sắp xếp
                    finalTable.push(subGroup[0]);
                }
            });
            
        } else {
            // Nhóm chỉ có 1 đội (không cần xử lý tie)
            finalTable.push(tiedGroup[0]);
        }
        
        i = j;
    }

    return finalTable;
}

/**
 * Tính toán thống kê đối đầu giữa các đội trong một nhóm.
 * @param {Array<Object>} teamsStat - Danh sách các đội cần xét (đã bị tie)
 * @param {Array} matches - Tất cả trận đấu của bảng
 * @returns {Array<Object>} Danh sách thống kê đối đầu
 */
function tinhDiemDoiDau(teamsStat, matches) {
    const tiedTeams = teamsStat.map(t => t.team);
    const h2hStats = {};

    teamsStat.forEach(stat => {
        h2hStats[stat.team] = {
            team: stat.team,
            W_H2H: 0, 
            L_H2H: 0,
            PF_H2H: 0,
            PA_H2H: 0,
            PD_H2H: 0
        };
    });

    matches.forEach(match => {
        // Chỉ xét các trận đấu giữa các đội trong nhóm bị tie
        if (tiedTeams.includes(match.teamA) && tiedTeams.includes(match.teamB) && match.winner) {
            const statA = h2hStats[match.teamA];
            const statB = h2hStats[match.teamB];

            // Cập nhật PF/PA đối đầu
            statA.PF_H2H += match.scoreA;
            statA.PA_H2H += match.scoreB;
            statB.PF_H2H += match.scoreB;
            statB.PA_H2H += match.scoreA;

            // Cập nhật W/L đối đầu
            if (match.winner === match.teamA) {
                statA.W_H2H++;
                statB.L_H2H++;
            } else {
                statA.L_H2H++;
                statB.W_H2H++;
            }
        }
    });

    Object.values(h2hStats).forEach(stat => {
        stat.PD_H2H = stat.PF_H2H - stat.PA_H2H;
    });
    
    return Object.values(h2hStats);
}


// --- Tab Vòng Chung Kết (Finals) ---

/**
 * Tự động lên lịch và điền đội cho Vòng Bán kết và Chung kết dựa trên kết quả Vòng Bảng.
 */
function scheduleFinalsAuto() {
    tinhVaCapNhatXepHang(); // Đảm bảo bảng xếp hạng là mới nhất

    const tableA = state.tableA.filter(t => t.matchesPlayed > 0);
    const tableB = state.tableB.filter(t => t.matchesPlayed > 0);

    if (tableA.length < 2 || tableB.length < 2) {
        showModal('Lỗi Lên Lịch Chung Kết', 'Chưa có đủ dữ liệu (ít nhất 2 đội đã thi đấu) từ Bảng A hoặc Bảng B để lên lịch Bán kết.');
        return;
    }

    // 1. Xác định đội Bán kết
    const nhatA = tableA[0]?.team;
    const nhiA = tableA[1]?.team;
    const nhatB = tableB[0]?.team;
    const nhiB = tableB[1]?.team;
    
    // Cấu hình Sân & Giờ mới (Sân 3, 16:40, 17:05, 17:30)
    const SF1_TIME = '16:40';
    const SF2_TIME = '17:05';
    const FINAL_TIME = '17:30';
    const FINAL_COURT = 'Sân 3';

    // 2. Cập nhật Vòng Bán kết (SF)
    state.semifinals[0].teamA = nhatA;
    state.semifinals[0].teamB = nhiA;
    state.semifinals[0].time = SF1_TIME;
    state.semifinals[0].court = FINAL_COURT;

    state.semifinals[1].teamA = nhatB;
    state.semifinals[1].teamB = nhiB;
    state.semifinals[1].time = SF2_TIME;
    state.semifinals[1].court = FINAL_COURT;

    // Reset kết quả nếu đội thay đổi
    if (state.semifinals.some(sf => sf.winner) || state.final.winner) {
         // Chỉ hỏi xác nhận nếu tên đội đã thay đổi so với lần gần nhất
        const sf1Changed = state.semifinals[0].winner && (state.semifinals[0].teamA !== nhatA || state.semifinals[0].teamB !== nhiA);
        const sf2Changed = state.semifinals[1].winner && (state.semifinals[1].teamA !== nhatB || state.semifinals[1].teamB !== nhiB);

        if (sf1Changed || sf2Changed || state.final.winner) {
            if(confirm("Lịch thi đấu Vòng Bảng đã thay đổi, dẫn đến việc đổi đội vào Bán kết. Bạn có muốn xóa kết quả Bán kết và Chung kết cũ để lên lịch lại không?")) {
                state.semifinals.forEach(sf => {
                    sf.scoreA = null; sf.scoreB = null; sf.winner = null; sf.loser = null;
                });
                state.final.scoreA = null; state.final.scoreB = null; state.final.winner = null; state.final.runnerUp = null;
                state.final.teamA = 'Thắng SF1'; 
                state.final.teamB = 'Thắng SF2';
            }
        }
    }
    
    // Đảm bảo thông tin Sân/Giờ Chung kết luôn đúng
    state.final.time = FINAL_TIME;
    state.final.court = FINAL_COURT;
    
    // 3. Cập nhật Vòng Chung kết (F) - Chỉ khi đã có người thắng
    updateFinalsFromSemifinals();

    // 4. Render và Save
    renderFinals();
    renderFinalResults();
    stateChanged = true;
    saveToGitHub();
    showModal('Lên Lịch Chung Kết Thành Công', `Đã lên lịch Bán kết:
        <ul class="list-unstyled small mt-2">
            <li><strong>SF1 (${SF1_TIME}):</strong> ${nhatA} vs ${nhiA} (${FINAL_COURT})</li>
            <li><strong>SF2 (${SF2_TIME}):</strong> ${nhatB} vs ${nhiB} (${FINAL_COURT})</li>
        </ul>
        Vòng Chung kết (${FINAL_TIME}) sẽ được cập nhật sau khi có kết quả Bán kết.
    `);
}

/**
 * Cập nhật đội vào trận chung kết nếu đã có người thắng bán kết.
 */
function updateFinalsFromSemifinals() {
    const winnerSF1 = state.semifinals[0].winner;
    const winnerSF2 = state.semifinals[1].winner;

    if (winnerSF1 && winnerSF2) {
        // Cập nhật trận Chung kết
        if (state.final.teamA !== winnerSF1 || state.final.teamB !== winnerSF2) {
            state.final.teamA = winnerSF1;
            state.final.teamB = winnerSF2;
            state.final.scoreA = null;
            state.final.scoreB = null;
            state.final.winner = null;
            state.final.runnerUp = null;
        }
    } else {
        // Đảm bảo trạng thái default nếu chưa có đủ winner
        if (!state.final.winner) {
            state.final.teamA = 'Thắng SF1'; 
            state.final.teamB = 'Thắng SF2';
        }
    }
}

/**
 * Cập nhật điểm và xác định người thắng Vòng Chung kết
 * @param {number} index - Chỉ số trận đấu trong semifinals (0 hoặc 1)
 * @param {string} group - 'semifinals' hoặc 'final'
 */
function updateFinalScore(group, index) {
    const matchArray = group === 'semifinals' ? state.semifinals : [state.final];
    const match = matchArray[index];

    const scoreAInput = document.getElementById(`final-score-${group}-${index}-A`);
    const scoreBInput = document.getElementById(`final-score-${group}-${index}-B`);
    
    const scoreA = scoreAInput.value === '' ? null : parseInt(scoreAInput.value);
    const scoreB = scoreBInput.value === '' ? null : parseInt(scoreBInput.value);

    // Cập nhật state
    match.scoreA = scoreA;
    match.scoreB = scoreB;
    match.winner = null;
    match.loser = null;
    if (group === 'final') match.runnerUp = null;

    if (scoreA !== null && scoreB !== null && scoreA !== scoreB) {
        if (scoreA > scoreB) {
            match.winner = match.teamA;
            if (group === 'final') match.runnerUp = match.teamB;
            else match.loser = match.teamB;
        } else {
            match.winner = match.teamB;
            if (group === 'final') match.runnerUp = match.teamA;
            else match.loser = match.teamA;
        }
    }
    
    updateFinalsFromSemifinals();
    renderFinals();
    renderFinalResults();
    
    stateChanged = true;
    saveToGitHub();
}

/**
 * Render giao diện Vòng Chung kết
 */
function renderFinals() {
    const containerSF = document.getElementById('semifinalMatches');
    const containerF = document.getElementById('finalMatch');
    
    // Cấu hình Sân & Giờ mới
    const SF1_TIME = '16:40';
    const SF2_TIME = '17:05';
    const FINAL_TIME = '17:30';
    const FINAL_COURT = 'Sân 3';

    // Render Bán kết
    let sfHtml = renderFinalMatchTable(state.semifinals, 'semifinals');
    containerSF.innerHTML = sfHtml;

    // Render Chung kết
    let fHtml = renderFinalMatchTable([state.final], 'final');
    containerF.innerHTML = fHtml;
    
    // Cập nhật tiêu đề HTML trong tab finals
    document.querySelector('#finalsContent h6:nth-child(1)').innerHTML = `Vòng Bán kết (SF1: ${SF1_TIME}, SF2: ${SF2_TIME}, ${FINAL_COURT})`;
    document.querySelector('#finalsContent h6:nth-child(3)').innerHTML = `Trận Chung kết (${FINAL_TIME}, ${FINAL_COURT})`;
}

/**
 * Tạo HTML cho bảng kết quả trận Bán kết/Chung kết
 */
function renderFinalMatchTable(matches, group) {
    if (matches.length === 0 || (!matches[0].teamA && group === 'final')) {
        return `<div class="alert alert-info">Chưa có lịch thi đấu. Vui lòng bấm "Lên lịch Vòng Chung kết" ở tab Vòng Bảng.</div>`;
    }

    let finalHtml = `
        <div class="table-responsive">
        <table class="table table-striped table-hover table-sm">
            <thead>
                <tr>
                    <th>Trận</th>
                    <th>Giờ</th>
                    <th>Đội A</th>
                    <th>Đội B</th>
                    <th class="text-center">A</th>
                    <th class="text-center">B</th>
                    <th>Thắng</th>
                </tr>
            </thead>
            <tbody>
    `;

    matches.forEach((match, index) => {
        const teamA_Class = match.winner === match.teamA ? 'winner' : (match.loser === match.teamA ? 'loser' : '');
        const teamB_Class = match.winner === match.teamB ? 'winner' : (match.loser === match.teamB ? 'loser' : '');
        const matchRowClass = match.winner ? 'table-light' : '';
        
        // Kiểm tra xem có phải là trận chờ kết quả hay không
        const isWaiting = match.teamA === 'Thắng SF1' || match.teamA === 'Thắng SF2';

        finalHtml += `
            <tr class="${matchRowClass}">
                <td>${match.id} (${match.court || '-'})</td>
                <td>${match.time || '-'}</td>
                <td class="text-truncate ${teamA_Class}">${match.teamA}</td>
                <td class="text-truncate ${teamB_Class}">${match.teamB}</td>
                <td class="match-score-cell">
                    <input type="number" id="final-score-${group}-${index}-A" 
                        value="${match.scoreA !== null ? match.scoreA : ''}" 
                        min="0" onchange="updateFinalScore('${group}', ${index})" 
                        ${isWaiting ? 'disabled' : ''}>
                </td>
                <td class="match-score-cell">
                    <input type="number" id="final-score-${group}-${index}-B" 
                        value="${match.scoreB !== null ? match.scoreB : ''}" 
                        min="0" onchange="updateFinalScore('${group}', ${index})" 
                        ${isWaiting ? 'disabled' : ''}>
                </td>
                <td class="text-truncate small ${match.winner ? 'winner' : ''}">
                    ${match.winner || (isWaiting ? 'Chờ KQ' : '-')}
                </td>
            </tr>
        `;
    });

    finalHtml += `
            </tbody>
        </table>
        </div>
    `;
    
    return finalHtml;
}

// --- Tab Kết quả Chung cuộc (Results) ---

/**
 * Render Bảng xếp hạng Vòng Bảng và Danh hiệu Chung cuộc
 */
function renderFinalResults() {
    // 1. Render Ranking Tables
    const rankingContainer = document.getElementById('rankingTables');
    let rankingHtml = `
        <div>
            <h6>Bảng A (Nam - Nữ)</h6>
            ${renderFullRankingTable(state.tableA)}
        </div>
        <div>
            <h6>Bảng B (Nam)</h6>
            ${renderFullRankingTable(state.tableB)}
        </div>
    `;
    rankingContainer.innerHTML = rankingHtml;
    
    // 2. Render Final Titles
    const final = state.final;
    const thirdPlaceTeams = getThirdPlaceTeams();

    document.getElementById('champion').innerHTML = `🏆 Vô địch: <strong>${final.winner || 'Đang chờ kết quả...'}</strong>`;
    document.getElementById('runnerUp').innerHTML = `🥈 Á quân: <strong>${final.runnerUp || 'Đang chờ kết quả...'}</strong>`;
    
    let thirdPlaceText = thirdPlaceTeams.join(' & ');
    document.getElementById('thirdPlace').innerHTML = `🥉 Hạng Ba Đồng Hạng: <strong>${thirdPlaceText || 'Đang chờ kết quả...'}</strong>`;
}

/**
 * Lấy đội hạng ba (hai đội thua Bán kết)
 */
function getThirdPlaceTeams() {
    const loserSF1 = state.semifinals[0].loser;
    const loserSF2 = state.semifinals[1].loser;
    
    const thirdPlaceTeams = [];
    if (loserSF1) thirdPlaceTeams.push(loserSF1);
    if (loserSF2 && loserSF2 !== loserSF1) thirdPlaceTeams.push(loserSF2);
    
    return thirdPlaceTeams;
}

/**
 * Render bảng xếp hạng đầy đủ
 */
function renderFullRankingTable(table) {
    if (table.length === 0) return `<div class="alert alert-info small">Chưa đủ dữ liệu vòng bảng để xếp hạng.</div>`;

    let html = `
        <div class="table-responsive">
        <table class="table table-bordered table-striped table-sm small">
            <thead>
                <tr>
                    <th>Hạng</th>
                    <th>Đội</th>
                    <th>W-L</th>
                    <th>PF-PA</th>
                    <th>Hiệu số</th>
                </tr>
            </thead>
            <tbody>
    `;

    table.forEach((team, index) => {
        const rankClass = index === 0 ? 'table-warning' : (index === 1 ? 'table-info' : '');
        html += `
            <tr class="${rankClass}">
                <td>${index + 1}</td>
                <td class="text-truncate"><strong>${team.team}</strong></td>
                <td>${team.W}-${team.L}</td>
                <td>${team.PF}-${team.PA}</td>
                <td>${team.PD > 0 ? '+' : ''}${team.PD}</td>
            </tr>
        `;
    });

    html += `
            </tbody>
        </table>
        </div>
    `;
    return html;
}

// --- Công cụ Tạo Lịch (Scheduling Tools) ---

// Chuyển đổi HH:mm thành số phút từ 00:00
function timeToMinutes(timeStr) {
    const [hours, minutes] = timeStr.split(':').map(Number);
    return hours * 60 + minutes;
}

// Chuyển đổi số phút thành HH:mm
function minutesToTime(minutes) {
    const h = Math.floor(minutes / 60);
    const m = minutes % 60;
    return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
}

/**
 * Tải lịch cố định từ biến FIXED_SCHEDULE_CSV
 */
function taoLichCoDinh() {
    const csvContent = FIXED_SCHEDULE_CSV;
    const matches = parseCSV(csvContent);
    
    if (matches.length > 0) {
        // Phân loại trận đấu
        state.matchesA = matches.filter(m => m.bang === 'A');
        state.matchesB = matches.filter(m => m.bang === 'B');
        
        // Gán originalIndex cho chế độ xem theo sân
        state.matchesA.forEach((m, i) => m.originalIndex = i);
        state.matchesB.forEach((m, i) => m.originalIndex = i);
        
        renderMatchesView();
        tinhVaCapNhatXepHang();
        
        stateChanged = true;
        saveToGitHub();
        showModal('Tải Lịch Mẫu Thành Công', `Đã tải thành công ${state.matchesA.length + state.matchesB.length} trận đấu (Lịch mẫu CalendarTKD30).`);
    } else {
        showModal('Lỗi Tải Lịch', 'Không thể đọc dữ liệu lịch mẫu (CSV trống hoặc lỗi định dạng).');
    }
}


/**
 * Tạo lịch thi đấu tối ưu (cùng giờ) dựa trên cấu hình sân
 */
function taoLichThiDauCungGio() {
    const allTeams = [...state.mixedTeams, ...state.maleTeams];
    if (allTeams.length === 0) {
        showModal('Lỗi Tạo Lịch', 'Không có danh sách đội. Vui lòng kiểm tra lại kết nối GitHub để tải players.json hoặc nhập đội thủ công.');
        return;
    }
    
    if (state.courts.length === 0) {
        showModal('Lỗi Tạo Lịch', 'Chưa có cấu hình sân thi đấu. Vui lòng cấu hình sân trong tab "Cấu hình".');
        return;
    }

    // Lọc ra các đội đã hoàn thành ít nhất 2 trận (để loại đội dự bị/chưa chính thức)
    const teamsA = state.mixedTeams.filter(t => t.name).map(t => t.name); // Chỉ lấy tên đội
    const teamsB = state.maleTeams.filter(t => t.name).map(t => t.name);

    if (teamsA.length < 2 && teamsB.length < 2) {
        showModal('Lỗi Tạo Lịch', 'Cần ít nhất 2 đội cho Bảng A hoặc Bảng B để tạo lịch thi đấu.');
        return;
    }

    const matchesA = generateAllMatches(teamsA, 'A');
    const matchesB = generateAllMatches(teamsB, 'B');

    const totalMatches = [...matchesA, ...matchesB];
    const courts = state.courts;
    const startTimeMinutes = Math.min(...courts.map(c => timeToMinutes(c.startTime)));
    const endTimeMinutes = Math.max(...courts.map(c => timeToMinutes(c.startTime) + c.maxDurationMinutes));
    const totalDurationMinutes = endTimeMinutes - startTimeMinutes;

    if (totalDurationMinutes <= 0) {
        showModal('Lỗi Cấu Hình Sân', 'Thời gian kết thúc sân (maxDuration) phải lớn hơn thời gian bắt đầu.');
        return;
    }

    // Sắp xếp các trận đấu theo ưu tiên (A trước B)
    const sortedMatches = [...matchesA, ...matchesB]; 

    // 1. Khởi tạo lịch sân
    const courtSchedules = courts.map(court => ({
        ...court,
        currentMinutes: timeToMinutes(court.startTime),
        schedule: []
    }));
    
    // 2. Thuật toán xếp lịch (Xếp theo giờ sớm nhất và ưu tiên loại sân)
    const finalSchedule = [];
    const scheduledMatches = new Set();
    
    // Lấy cấu hình ưu tiên sân
    const preferredType = state.config.preferredCourtType || 'mixed';
    
    // Hàm tìm sân phù hợp và sớm nhất
    const findNextAvailableCourt = (matchIsMixed) => {
        
        let bestCourt = null;
        let minTime = Infinity;
        let preferenceScore = -Infinity; // Điểm ưu tiên: Cao nhất nếu khớp với preferredType

        courtSchedules.forEach(court => {
            // Kiểm tra xem sân có phù hợp với loại trận đấu (Mixed/Male) không
            const courtIsMixed = court.isMixed;
            const courtMatchesType = matchIsMixed === courtIsMixed;
            
            // Tính điểm ưu tiên
            let currentPreferenceScore = 0;
            if (preferredType === 'mixed' && courtIsMixed) {
                currentPreferenceScore = 1;
            } else if (preferredType === 'male' && !courtIsMixed) {
                currentPreferenceScore = 1;
            }

            // Kiểm tra xem sân có còn trong thời gian hoạt động không
            const courtEndTime = timeToMinutes(court.startTime) + court.maxDurationMinutes;
            const matchDuration = 15; // Giả sử mỗi trận 15 phút
            const isWithinDuration = court.currentMinutes + matchDuration <= courtEndTime;

            if (courtMatchesType && isWithinDuration) {
                const currentTime = court.currentMinutes;
                
                // Tiêu chí 1: Sân có ưu tiên cao hơn
                if (currentPreferenceScore > preferenceScore) {
                    preferenceScore = currentPreferenceScore;
                    minTime = currentTime;
                    bestCourt = court;
                } 
                // Tiêu chí 2: Cùng mức ưu tiên, chọn sân bắt đầu sớm nhất (cùng giờ)
                else if (currentPreferenceScore === preferenceScore && currentTime < minTime) {
                    minTime = currentTime;
                    bestCourt = court;
                }
                // Tiêu chí 3: Cùng mức ưu tiên và cùng giờ, chọn sân có tên nhỏ hơn (Sân 1 < Sân 2)
                else if (currentPreferenceScore === preferenceScore && currentTime === minTime && (!bestCourt || court.name < bestCourt.name)) {
                     minTime = currentTime;
                     bestCourt = court;
                }
            }
        });

        // Nếu không tìm được sân ưu tiên, tìm sân hợp lệ khác
        if (!bestCourt) {
             courtSchedules.forEach(court => {
                const courtIsMixed = court.isMixed;
                const courtMatchesType = matchIsMixed === courtIsMixed;
                const courtEndTime = timeToMinutes(court.startTime) + court.maxDurationMinutes;
                const matchDuration = 15;
                const isWithinDuration = court.currentMinutes + matchDuration <= courtEndTime;
                
                if (courtMatchesType && isWithinDuration && court.currentMinutes < minTime) {
                    minTime = court.currentMinutes;
                    bestCourt = court;
                }
             });
        }

        return bestCourt;
    };
    
    // Vòng lặp xếp lịch
    while (finalSchedule.length < totalMatches.length) {
        let matchPlaced = false;
        
        // Vòng lặp qua tất cả các trận đấu chưa xếp lịch
        for (let i = 0; i < sortedMatches.length; i++) {
            const match = sortedMatches[i];
            if (scheduledMatches.has(match)) continue;

            const matchIsMixed = match.bang === 'A';
            const bestCourt = findNextAvailableCourt(matchIsMixed);

            if (bestCourt) {
                const matchDuration = 15; // Giả sử cố định 15 phút/trận
                
                const scheduledMatch = {
                    ...match,
                    time: minutesToTime(bestCourt.currentMinutes),
                    court: bestCourt.name,
                    originalIndex: i // Lưu index gốc để dễ dàng update score
                };

                finalSchedule.push(scheduledMatch);
                scheduledMatches.add(match);
                
                // Cập nhật thời gian bắt đầu của sân
                bestCourt.currentMinutes += matchDuration;
                
                matchPlaced = true;
                break; // Sau khi xếp được 1 trận, khởi tạo lại vòng lặp để đảm bảo tìm sân sớm nhất
            }
        }
        
        if (!matchPlaced) {
            // Không còn trận nào xếp được vào sân còn trống/còn thời gian
            break; 
        }
    }
    
    if (finalSchedule.length < totalMatches.length) {
        console.warn(`Chỉ xếp lịch được ${finalSchedule.length} / ${totalMatches.length} trận. Sân có thể đã hết giờ.`);
    }

    // 4. Cập nhật state và UI
    state.matchesA = finalSchedule.filter(m => m.bang === 'A');
    state.matchesB = finalSchedule.filter(m => m.bang === 'B');
    
    // Cập nhật originalIndex (dùng để updateScore)
    state.matchesA.forEach((m, i) => m.originalIndex = i);
    state.matchesB.forEach((m, i) => m.originalIndex = i);

    renderMatchesView();
    tinhVaCapNhatXepHang();
    
    stateChanged = true;
    saveToGitHub();
    showModal('Tạo Lịch Tối Ưu Thành Công', `Đã tạo và xếp lịch thành công ${finalSchedule.length} trận đấu. Vui lòng kiểm tra tab "Vòng Bảng" theo chế độ "Theo Sân thi đấu".`);
}

/**
 * Hàm tạo tất cả các cặp đấu (All-Play-All)
 */
function generateAllMatches(teams, group) {
    const matches = [];
    for (let i = 0; i < teams.length; i++) {
        for (let j = i + 1; j < teams.length; j++) {
            matches.push({
                teamA: teams[i],
                teamB: teams[j],
                scoreA: null,
                scoreB: null,
                winner: null,
                loser: null,
                time: null, // Sẽ được xếp lịch sau
                court: null, // Sẽ được xếp lịch sau
                bang: group
            });
        }
    }
    return matches;
}


// --- Công cụ Import/Export CSV ---

/**
 * Xử lý file CSV được upload
 */
function handleFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const csvContent = e.target.result;
            const matches = parseCSV(csvContent);
            
            if (matches.length > 0) {
                 // Xóa lịch cũ trước khi import
                state.matchesA = [];
                state.matchesB = [];
                
                // Phân loại và gán index
                matches.forEach((m, i) => {
                    m.originalIndex = i;
                    if (m.bang === 'A') {
                        state.matchesA.push(m);
                    } else if (m.bang === 'B') {
                        state.matchesB.push(m);
                    }
                });

                renderMatchesView();
                tinhVaCapNhatXepHang();
                
                stateChanged = true;
                saveToGitHub();
                showModal('Import Lịch Thành Công', `Đã nhập thành công ${matches.length} trận đấu từ file CSV.`);
            } else {
                showModal('Lỗi Import', 'File CSV không chứa dữ liệu lịch thi đấu hợp lệ.');
            }
        } catch (error) {
            showModal('Lỗi Import', `Lỗi xử lý file CSV: ${error.message}`);
            console.error("Lỗi xử lý CSV:", error);
        }
    };
    reader.readAsText(file);
}

/**
 * Phân tích cú pháp CSV thành mảng trận đấu
 */
function parseCSV(csvContent) {
    const lines = csvContent.trim().split('\n');
    if (lines.length < 2) return [];

    const headers = lines[0].split(',').map(h => h.trim());
    const dataLines = lines.slice(1);
    const matches = [];

    dataLines.forEach(line => {
        const values = line.split(',');
        if (values.length !== headers.length) return; // Bỏ qua dòng bị lỗi

        const match = {};
        headers.forEach((header, index) => {
            const value = values[index].trim();
            switch (header) {
                case 'scoreA':
                case 'scoreB':
                    match[header] = value === '' ? null : parseInt(value);
                    break;
                case 'originalIndex':
                    match[header] = parseInt(value);
                    break;
                case 'winner':
                case 'loser':
                    match[header] = value === '' ? null : value;
                    break;
                case 'time':
                case 'court':
                case 'bang':
                case 'teamA':
                case 'teamB':
                    match[header] = value;
                    break;
                default:
                    // Bỏ qua các header không mong muốn
                    break;
            }
        });

        // Nếu có điểm, tính winner/loser
        if (match.scoreA !== null && match.scoreB !== null && match.scoreA !== match.scoreB) {
            if (match.scoreA > match.scoreB) {
                match.winner = match.teamA;
                match.loser = match.teamB;
            } else {
                match.winner = match.teamB;
                match.loser = match.teamA;
            }
        }

        matches.push(match);
    });

    return matches;
}

/**
 * Export lịch thi đấu ra file CSV
 */
function exportSchedule() {
    const allMatches = [...state.matchesA, ...state.matchesB];
    if (allMatches.length === 0) {
        showModal('Export Lịch', 'Không có trận đấu nào để xuất ra CSV.');
        return;
    }

    const headers = ["teamA", "teamB", "time", "court", "bang", "scoreA", "scoreB", "winner", "loser"];
    let csvContent = headers.join(",") + "\n";

    allMatches.forEach(match => {
        const row = [
            match.teamA || '',
            match.teamB || '',
            match.time || '',
            match.court || '',
            match.bang || '',
            match.scoreA !== null ? match.scoreA : '',
            match.scoreB !== null ? match.scoreB : '',
            match.winner || '',
            match.loser || ''
        ];
        csvContent += row.join(",") + "\n";
    });

    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute("download", "lich_thi_dau_tkd.csv");
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    showModal('Export Lịch Thành Công', 'Đã tải xuống file **lich_thi_dau_tkd.csv**.');
}

/**
 * Điền kết quả tự động (11-X) cho tất cả các trận chưa đấu.
 */
function autoFillScores() {
    let filledCount = 0;
    
    // Vòng bảng
    [state.matchesA, state.matchesB].forEach(matchArray => {
        matchArray.forEach(match => {
            if (!match.winner) {
                // Điền 11 - X (X là số ngẫu nhiên từ 5 đến 9)
                const randomLossScore = Math.floor(Math.random() * 5) + 5; // 5, 6, 7, 8, 9
                
                // Ngẫu nhiên đội thắng
                if (Math.random() < 0.5) { // Team A thắng
                    match.scoreA = 11;
                    match.scoreB = randomLossScore;
                } else { // Team B thắng
                    match.scoreA = randomLossScore;
                    match.scoreB = 11;
                }
                
                // Tính lại winner/loser
                if (match.scoreA > match.scoreB) {
                    match.winner = match.teamA;
                    match.loser = match.teamB;
                } else {
                    match.winner = match.teamB;
                    match.loser = match.teamA;
                }
                
                filledCount++;
            }
        });
    });

    // Bán kết và Chung kết (Nếu đã lên lịch)
    [...state.semifinals, state.final].forEach(match => {
        if (!match.winner && match.teamA !== 'Thắng SF1' && match.teamA !== 'Nhất A') {
            const randomLossScore = Math.floor(Math.random() * 5) + 5; 
            if (Math.random() < 0.5) {
                match.scoreA = 11;
                match.scoreB = randomLossScore;
            } else {
                match.scoreA = randomLossScore;
                match.scoreB = 11;
            }
            
            if (match.scoreA > match.scoreB) {
                match.winner = match.teamA;
                if (match.id === 'F') match.runnerUp = match.teamB;
                else match.loser = match.teamB;
            } else {
                match.winner = match.teamB;
                if (match.id === 'F') match.runnerUp = match.teamA;
                else match.loser = match.teamA;
            }
            filledCount++;
        }
    });

    if (filledCount > 0) {
        // Sau khi điền, cập nhật lại mọi thứ
        updateFinalsFromSemifinals();
        renderMatchesView(); 
        tinhVaCapNhatXepHang(); 
        renderFinals();
        
        stateChanged = true;
        saveToGitHub();
        showModal('Điền Kết Quả Tự Động Thành Công', `Đã tự động điền kết quả cho ${filledCount} trận đấu chưa hoàn thành.`);
    } else {
        showModal('Điền Kết Quả Tự Động', 'Không còn trận đấu nào chưa hoàn thành để điền kết quả tự động.');
    }
}

/**
 * Xóa toàn bộ lịch thi đấu và kết quả
 */
function clearAllSchedules() {
    if (confirm("Bạn có chắc chắn muốn XÓA TOÀN BỘ lịch thi đấu và kết quả vòng bảng/chung kết? (Danh sách đội vẫn được giữ lại)")) {
        state.matchesA = [];
        state.matchesB = [];
        state.tableA = [];
        state.tableB = [];
        
        // Đảm bảo cập nhật thời gian mới khi reset
        const SF1_TIME = '16:40';
        const SF2_TIME = '17:05';
        const FINAL_TIME = '17:30';
        const FINAL_COURT = 'Sân 3';
        
        state.semifinals = [
            { id: 'SF1', teamA: 'Nhất A', teamB: 'Nhì A', scoreA: null, scoreB: null, time: SF1_TIME, court: FINAL_COURT, winner: null, loser: null },
            { id: 'SF2', teamA: 'Nhất B', teamB: 'Nhì B', scoreA: null, scoreB: null, time: SF2_TIME, court: FINAL_COURT, winner: null, loser: null }
        ];
        state.final = { id: 'F', teamA: 'Thắng SF1', teamB: 'Thắng SF2', scoreA: null, scoreB: null, time: FINAL_TIME, court: FINAL_COURT, winner: null, runnerUp: null };

        renderMatchesView();
        renderFinals();
        renderFinalResults();
        renderOverview();
        
        stateChanged = true;
        saveToGitHub();
        showModal('Thành Công', 'Đã xóa toàn bộ lịch thi đấu và kết quả.');
    }
}
</script>
</body>
</html>
