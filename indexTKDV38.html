<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TKD Championship 2025 ‚Äî Qu·∫£n l√Ω gi·∫£i Pickleball V21 GitHub (S√¢n CK l√† S√¢n 3 & S·ª≠a L·ªãch m·∫´u & S√¢n 1-8)</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body { background:#f7f9fc; font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial; color:#222; padding:18px; }
    .tab-content { margin-top: 18px; }
    .logo { 
      width:64px; 
      height:64px; 
      object-fit:contain; 
      border-radius:8px; 
      border:1px solid #e6eefc; 
      padding:6px; 
      background:#fff; 
    }
    table th { background:#0d6efd; color:#fff; position:sticky; top:0; }
    .status { font-size:0.95rem; color:#555; }
    /* Responsive adjustment for match inputs */
    .match-score-cell input {
      width: 45px;
      text-align: center;
      padding: 0.1rem;
    }
    @media (max-width: 576px) {
      .match-score-cell input {
        width: 35px;
      }
    }
    .winner { font-weight: bold; color: green; }
    .loser { color: red; }
    .ranking-container { display: flex; flex-direction: column; gap: 20px; }
    @media (min-width: 768px) {
        .ranking-container { flex-direction: row; }
        .ranking-container > div { flex: 1; }
    }
  </style>
</head>
<body>
<div class="container">
  <div class="d-flex justify-content-between align-items-center mb-3">
    <div class="d-flex align-items-center gap-2">
      <img class="logo" src="data/logoTKD.png" alt="Logo TKD">
      <div>
        <h3 class="mb-0">TKD Championship 2025</h3>
        <div>Ng√†y thi ƒë·∫•u: 18/10/2025 (**V21**)</div>
      </div>
    </div>
    <div>
      <div id="autoSaveStatus" class="text-end status">Auto-save: <span id="autoState" class="text-danger">T·∫Øt</span></div>
      <div id="lastSaved" class="text-end status">Ch∆∞a l∆∞u</div>
    </div>
  </div>

  <ul class="nav nav-tabs" id="mainTabs">
    <li class="nav-item"><button class="nav-link active" data-bs-toggle="tab" data-bs-target="#overview" onclick="renderOverview()">T·ªïng quan</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#matches" id="matchesTabButton" onclick="renderMatchesView()">V√≤ng B·∫£ng</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#finals" onclick="renderFinals()">V√≤ng Chung K·∫øt</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#results" onclick="tinhVaCapNhatXepHang(); renderFinalResults();">K·∫øt qu·∫£ Chung cu·ªôc</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#config" id="configTabButton" onclick="renderConfig()">C·∫•u h√¨nh</button></li>
  </ul>

  <div class="tab-content">
    <div class="tab-pane fade show active p-3" id="overview">
        <div id="overviewContent">ƒêang t·∫£i d·ªØ li·ªáu...</div>
    </div>
    
    <div class="tab-pane fade p-3" id="matches">
      <div class="d-flex gap-2 mb-3 flex-wrap">
        <label for="viewMode" class="form-label mb-0 align-self-center text-nowrap">Ch·∫ø ƒë·ªô xem:</label>
        <select id="viewMode" class="form-select form-select-sm w-auto" onchange="renderMatchesView()">
            <option value="table">Theo B·∫£ng ƒë·∫•u</option>
            <option value="court" selected>Theo S√¢n thi ƒë·∫•u</option>
        </select>
        
        <button class="btn btn-sm btn-info ms-auto" onclick="document.getElementById('fileInput').click()">Import L·ªãch (CSV)</button>
        <input type="file" id="fileInput" accept=".csv" style="display: none;" onchange="handleFileSelect(event)">
        
        <button class="btn btn-sm btn-warning" onclick="exportSchedule()">Export L·ªãch (CSV)</button>
      </div>
      
      <div id="matchesViewContent">
        <h6 id="scheduleAHeader" class="mt-4">B·∫£ng A (Nam - N·ªØ)</h6><div id="tableMatchesA">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u.</div>
        
        <h6 class="mt-4">B·∫£ng B (Nam)</h6><div id="tableMatchesB">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u.</div>
      </div>

      <button class="btn btn-warning mt-4" onclick="scheduleFinalsAuto()">L√™n l·ªãch V√≤ng Chung k·∫øt (T·ª± ƒë·ªông h√≥a)</button>
    </div>

    <div class="tab-pane fade p-3" id="finals">
        <div id="finalsContent">
            <h6 class="mt-4">V√≤ng B√°n k·∫øt (SF1: 16:40, SF2: 17:05, S√¢n 3)</h6>
            <div id="semifinalMatches">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u b√°n k·∫øt. K·∫øt qu·∫£ V√≤ng B·∫£ng s·∫Ω t·ª± ƒë·ªông c·∫≠p nh·∫≠t l·ªãch.</div>

            <h6 class="mt-4">Tr·∫≠n Chung k·∫øt (17:30, S√¢n 3)</h6>
            <div id="finalMatch">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u chung k·∫øt.</div>
        </div>
    </div>

    <div class="tab-pane fade p-3" id="results">
        <h5 class="mb-3">B·∫£ng x·∫øp h·∫°ng V√≤ng B·∫£ng (∆Øu ti√™n: W > ƒê·ªëi ƒë·∫ßu > Hi·ªáu s·ªë > T·ªïng ƒëi·ªÉm)</h5>
        <div id="rankingTables" class="ranking-container">
            </div>

        <hr class="my-4">

        <h5 class="mb-3">Danh hi·ªáu Chung cu·ªôc</h5>
        <p id="champion">V√¥ ƒë·ªãch: ƒêang ch·ªù k·∫øt qu·∫£...</p>
        <p id="runnerUp">√Å qu√¢n: ƒêang ch·ªù k·∫øt qu·∫£...</p>
        <p id="thirdPlace">H·∫°ng Ba ƒê·ªìng H·∫°ng: ƒêang ch·ªù k·∫øt qu·∫£...</p>
    </div>

    <div class="tab-pane fade p-3" id="config">
      <h5 class="mb-3">C√¥ng c·ª• L·∫≠p & ƒêi·ªÅn L·ªãch Thi ƒë·∫•u</h5>
      <div class="d-flex gap-2 mb-4 flex-wrap">
        <button class="btn btn-sm btn-primary" onclick="taoLichThiDauCungGio()">T·∫°o l·ªãch thi ƒë·∫•u T·ªëi ∆∞u (T·ª± ƒë·ªông)</button>
        <button class="btn btn-sm btn-secondary" onclick="taoLichCoDinh()">T·∫£i l·ªãch M·∫´u (**CalendarTKD30**)</button>
        <button class="btn btn-sm btn-success" onclick="autoFillScores()">ƒêi·ªÅn k·∫øt qu·∫£ T·ª± ƒë·ªông (11 - X)</button>
        <button class="btn btn-sm btn-danger" onclick="clearAllSchedules()">X√≥a To√†n b·ªô L·ªãch</button>
      </div>
      
      <hr>

      <h5 class="mt-4">‚öôÔ∏è C·∫•u h√¨nh S√¢n thi ƒë·∫•u & L·ªãch T·ªëi ∆∞u</h5>
      <p class="text-muted small">Qu·∫£n l√Ω danh s√°ch s√¢n thi ƒë·∫•u. S√¢n ƒë∆∞·ª£c g√°n lo·∫°i b·∫£ng ƒë·∫•u (A/B) ƒë·ªÉ ph·ª•c v·ª• ch·ª©c nƒÉng t·∫°o l·ªãch T·ªëi ∆∞u.</p>
      <div class="d-flex gap-2 mb-3 flex-wrap">
          <button class="btn btn-sm btn-primary" onclick="openCourtModal()">+ Th√™m S√¢n M·ªõi</button>
          <button class="btn btn-sm btn-outline-info" onclick="loadDefaultCourtConfig()">T·∫£i c·∫•u h√¨nh M·∫∑c ƒë·ªãnh</button>
      </div>
      <div id="courtListContainer">
          </div>
      <div id="courtConfigStatus"></div>
      <hr>
      
      <h5 class="mt-4">üõ†Ô∏è C·∫•u h√¨nh T·ªëi ∆∞u L·ªãch thi ƒë·∫•u</h5>
      <div class="row g-2 mb-4">
        <div class="col-md-6">
          <label for="preferredCourtType" class="form-label">∆Øu ti√™n S√¢n n√†o cho tr·∫≠n ƒë·∫ßu ti√™n (Ch·ª©c nƒÉng T·∫°o l·ªãch T·ªëi ∆∞u)?</label>
          <select id="preferredCourtType" class="form-select" onchange="updatePreferredCourtType()">
            <option value="mixed">B·∫£ng A (Nam - N·ªØ) - M·∫∑c ƒë·ªãnh</option>
            <option value="male">B·∫£ng B (Nam)</option>
          </select>
          <div class="form-text">X√°c ƒë·ªãnh lo·∫°i s√¢n s·∫Ω ƒë∆∞·ª£c ∆∞u ti√™n g√°n tr·∫≠n ƒë·∫•u ƒë·∫ßu ti√™n trong thu·∫≠t to√°n t·∫°o l·ªãch.</div>
        </div>
      </div>
      <hr>
      <h5 class="mt-4">üíæ C·∫•u h√¨nh K·∫øt n·ªëi GitHub</h5>
      <p class="text-muted">Nh·∫≠p th√¥ng tin kho l∆∞u tr·ªØ GitHub ƒë·ªÉ t·ª± ƒë·ªông l∆∞u tr·ªØ d·ªØ li·ªáu gi·∫£i ƒë·∫•u.</p>
      <div class="row g-2 mb-2">
        <div class="col-md-3"><input id="cfgOwner" class="form-control" placeholder="Owner (V√≠ d·ª•: user_name)"></div>
        <div class="col-md-3"><input id="cfgRepo" class="form-control" placeholder="Repo (V√≠ d·ª•: my-data-repo)"></div>
        <div class="col-md-3"><input id="cfgFolder" class="form-control" value="data"></div>
        <div class="col-md-3"><input id="cfgFile" class="form-control" value="state.json"></div>
      </div>
      <input id="cfgToken" type="password" class="form-control mb-2" placeholder="D√°n GitHub Personal Access Token (PAT) t·∫°i ƒë√¢y">
      <div class="d-flex gap-2">
        <button class="btn btn-primary" onclick="saveConfig()">L∆∞u c·∫•u h√¨nh Local</button>
        <button class="btn btn-success" onclick="checkConnection()">Ki·ªÉm tra & T·∫£i D·ªØ li·ªáu</button>
      </div>
      <div class="mt-2" id="configStatus"></div>
      
      <div class="card bg-light mt-4 shadow-sm">
        <div class="card-body">
            <h5 class="card-title text-info">üîë H∆∞·ªõng d·∫´n l·∫•y GitHub Token (PAT)</h5>
            <ol class="small mb-0">
                <li>Truy c·∫≠p <a href="https://github.com/settings/tokens" target="_blank" class="text-info">GitHub Tokens Settings</a> (B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p).</li>
                <li>Ch·ªçn **Generate new token** (ho·∫∑c **Generate new token (classic)** n·∫øu b·∫°n d√πng t√†i kho·∫£n c≈©).</li>
                <li>**T√™n Token:** ƒê·∫∑t t√™n d·ªÖ nh·ªõ (v√≠ d·ª•: `TKDManager_AutoSave`).</li>
                <li>**Th·ªùi h·∫°n:** Ch·ªçn t√πy √Ω (n√™n ch·ªçn 90 ng√†y ho·∫∑c T√πy ch·ªânh).</li>
                <li>**Ph·∫°m vi (Scopes):** **B·∫ÆT BU·ªòC** t√≠ch ch·ªçn √¥ **`repo`** (cho ph√©p truy c·∫≠p v√†o kho l∆∞u tr·ªØ).</li>
                <li>Nh·∫•n **Generate token** v√† **SAO CH√âP** chu·ªói Token v·ª´a ƒë∆∞·ª£c t·∫°o.</li>
                <li>D√°n chu·ªói Token ƒë√≥ v√†o √¥ "D√°n GitHub Personal Access Token (PAT) t·∫°i ƒë√¢y" b√™n tr√™n.</li>
            </ol>
            <p class="mt-2 mb-0 text-danger small">‚ö†Ô∏è **L∆∞u √Ω:** Token ch·ªâ hi·ªÉn th·ªã **M·ªòT L·∫¶N**. H√£y sao ch√©p ngay l·∫≠p t·ª©c v√† gi·ªØ b√≠ m·∫≠t. N·∫øu m·∫•t, b·∫°n ph·∫£i t·∫°o l·∫°i Token m·ªõi.</p>
        </div>
      </div>
      </div>
  </div>
</div>

<div class="modal fade" id="courtModal" tabindex="-1" aria-labelledby="courtModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="courtModalLabel">Th√™m/S·ª≠a C·∫•u h√¨nh S√¢n</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="courtForm">
          <input type="hidden" id="courtIndex" value="">
          <div class="mb-3">
            <label for="courtName" class="form-label">T√™n S√¢n</label>
            <input type="text" class="form-control" id="courtName" required>
          </div>
          <div class="mb-3">
            <label for="courtStartTime" class="form-label">Gi·ªù B·∫Øt ƒê·∫ßu (HH:mm)</label>
            <input type="time" class="form-control" id="courtStartTime" required>
          </div>
          <div class="mb-3">
            <label for="courtMaxDuration" class="form-label">Th·ªùi L∆∞·ª£ng T·ªëi ƒêa (Ph√∫t)</label>
            <input type="number" class="form-control" id="courtMaxDuration" min="1" required>
          </div>
          <div class="form-check mb-3">
            <input class="form-check-input" type="checkbox" id="courtIsMixed">
            <label class="form-check-label" for="courtIsMixed">
              D√†nh cho B·∫£ng A (Nam - N·ªØ)
            </label>
            <div class="form-text">N·∫øu kh√¥ng ch·ªçn, s√¢n s·∫Ω d√†nh cho B·∫£ng B (Nam).</div>
          </div>
          <div id="courtFormStatus" class="mt-2"></div>
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">H·ªßy</button>
        <button type="button" class="btn btn-primary" onclick="saveCourtChanges()">L∆∞u Thay ƒê·ªïi</button>
      </div>
    </div>
  </div>
</div>
<div class="modal fade" id="customAlertModal" tabindex="-1" aria-labelledby="customAlertModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="customAlertModalLabel">Th√¥ng b√°o</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="customAlertModalBody">
        N·ªôi dung th√¥ng b√°o
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-primary" data-bs-dismiss="modal">ƒê√≥ng</button>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script> 

<script>
// D·ªØ li·ªáu l·ªãch c·ªë ƒë·ªãnh t·ª´ file CalendarTKD30.csv (ƒê√É C·∫¨P NH·∫¨T theo y√™u c·∫ßu)
const FIXED_SCHEDULE_CSV = `teamA,teamB,time,court,bang,scoreA,scoreB
Tri·ªÅu/Minh,Hi·ªÉn/P.H√πng,14:00,S√¢n 1,B,,
Giang/Long,H∆∞·ªùng/ƒê·∫°t,14:00,S√¢n 2,A,,
H·∫≠u/D≈©ng,H·∫°nh/Ti·∫øn,14:00,S√¢n 3,A,,
Huy·ªÅn/Lu√¢n,Linh/M.H√πng,14:00,S√¢n 7,A,,
Ti·ªáp/Th·ªßy,Ph∆∞∆°ng/Thanh,14:15,S√¢n 1,B,,
T√≠n/Khi√™m,√Ånh/To√†n,14:15,S√¢n 2,B,,
H·∫≠u/D≈©ng,H∆∞·ªùng/ƒê·∫°t,14:15,S√¢n 3,A,,
Giang/Long,Huy·ªÅn/Lu√¢n,14:15,S√¢n 7,A,,
Tri·ªÅu/Minh,T√≠n/Khi√™m,14:30,S√¢n 1,B,,
Ti·ªáp/Th·ªßy,Hi·ªÉn/P.H√πng,14:30,S√¢n 2,B,,
H·∫°nh/Ti·∫øn,Linh/M.H√πng,14:30,S√¢n 3,A,,
Ph∆∞∆°ng/Thanh,√Ånh/To√†n,14:30,S√¢n 7,B,,
Huy·ªÅn/Lu√¢n,H∆∞·ªùng/ƒê·∫°t,14:45,S√¢n 2,A,,
H·∫°nh/Ti·∫øn,Giang/Long,14:45,S√¢n 3,A,,
H·∫≠u/D≈©ng,Linh/M.H√πng,14:45,S√¢n 7,A,,
Ti·ªáp/Th·ªßy,√Ånh/To√†n,15:00,S√¢n 2,B,,
T√≠n/Khi√™m,Hi·ªÉn/P.H√πng,15:00,S√¢n 3,B,,
Ph∆∞∆°ng/Thanh,Tri·ªÅu/Minh,15:15,S√¢n 2,B,,
Giang/Long,Linh/M.H√πng,15:15,S√¢n 3,A,,
H·∫°nh/Ti·∫øn,H∆∞·ªùng/ƒê·∫°t,15:30,S√¢n 2,A,,
H·∫≠u/D≈©ng,Huy·ªÅn/Lu√¢n,15:30,S√¢n 3,A,,
Ti·ªáp/Th·ªßy,T√≠n/Khi√™m,15:45,S√¢n 2,B,,
Ph∆∞∆°ng/Thanh,Hi·ªÉn/P.H√πng,15:45,S√¢n 3,B,,
Tri·ªÅu/Minh,√Ånh/To√†n,16:00,S√¢n 2,B,,
H·∫≠u/D≈©ng,Giang/Long,16:00,S√¢n 3,A,,
H·∫°nh/Ti·∫øn,Huy·ªÅn/Lu√¢n,16:15,S√¢n 2,A,,
Linh/M.H√πng,H∆∞·ªùng/ƒê·∫°t,16:15,S√¢n 3,A,,
Ti·ªáp/Th·ªßy,Tri·ªÅu/Minh,16:30,S√¢n 2,B,,
√Ånh/To√†n,Hi·ªÉn/P.H√πng,16:30,S√¢n 3,B,,
Ph∆∞∆°ng/Thanh,T√≠n/Khi√™m,16:45,S√¢n 2,B,`;

// Bi·∫øn state l∆∞u tr·ªØ d·ªØ li·ªáu ch√≠nh c·ªßa ·ª©ng d·ª•ng.
let state = { 
  mixedTeams: [], // S·∫Ω ƒë∆∞·ª£c t·∫£i t·ª´ players.json
  maleTeams: [],  // S·∫Ω ƒë∆∞·ª£c t·∫£i t·ª´ players.json
  matchesA: [], 
  matchesB: [],
  tableA: [], // B·∫£ng x·∫øp h·∫°ng A
  tableB: [], // B·∫£ng x·∫øp h·∫°ng B
  
  // NEW: Court Configuration (ƒê√É C·∫¨P NH·∫¨T S√ÇN 1 -> S√ÇN 8)
  courts: [
    { name: 'S√¢n 1', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, // B·∫£ng A (Mixed)
    { name: 'S√¢n 2', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, // B·∫£ng A (Mixed)
    { name: 'S√¢n 3', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, // B·∫£ng A (Mixed)
    { name: 'S√¢n 4', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, // B·∫£ng A (Mixed)
    { name: 'S√¢n 5', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }, // B·∫£ng B (Male)
    { name: 'S√¢n 6', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }, // B·∫£ng B (Male)
    { name: 'S√¢n 7', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }, // B·∫£ng B (Male)
    { name: 'S√¢n 8', startTime: '14:00', maxDurationMinutes: 180, isMixed: false } // B·∫£ng B (Male)
  ],
  
  // LOGIC B√ÅN K·∫æT (ƒê√É C·∫¨P NH·∫¨T S√ÇN M·∫∂C ƒê·ªäNH L√Ä S√ÇN 3 V√Ä TH·ªúI GIAN M·ªöI)
  semifinals: [
    { id: 'SF1', teamA: 'Nh·∫•t A', teamB: 'Nh√¨ A', scoreA: null, scoreB: null, time: '16:40', court: 'S√¢n 3', winner: null, loser: null }, // ƒê√£ ƒëi·ªÅu ch·ªânh
    { id: 'SF2', teamA: 'Nh·∫•t B', teamB: 'Nh√¨ B', scoreA: null, scoreB: null, time: '17:05', court: 'S√¢n 3', winner: null, loser: null }  // ƒê√£ ƒëi·ªÅu ch·ªânh
  ],
  final: { id: 'F', teamA: 'Th·∫Øng SF1', teamB: 'Th·∫Øng SF2', scoreA: null, scoreB: null, time: '17:30', court: 'S√¢n 3', winner: null, runnerUp: null }, // ƒê√£ ƒëi·ªÅu ch·ªânh
  config: { 
    preferredCourtType: 'mixed' // NEW: ∆Øu ti√™n s√¢n cho thu·∫≠t to√°n x·∫øp l·ªãch
  }
};

let stateChanged = false; // Bi·∫øn c·ªù theo d√µi thay ƒë·ªïi d·ªØ li·ªáu
let currentSha = null; // Bi·∫øn l∆∞u tr·ªØ SHA c·ªßa file tr√™n GitHub
let autoSaveInterval = null; // Bi·∫øn l∆∞u tr·ªØ ID c·ªßa interval

// --- Custom Modal Function ---
function showModal(title, body) {
    document.getElementById('customAlertModalLabel').textContent = title;
    document.getElementById('customAlertModalBody').innerHTML = body;
    const modal = new bootstrap.Modal(document.getElementById('customAlertModal'));
    modal.show();
}

/**
 * H√†m chuy·ªÉn ƒë·ªïi tab
 * @param {string} tabId - ID c·ªßa tab c·∫ßn chuy·ªÉn (v√≠ d·ª•: 'matches', 'overview')
 */
function switchTab(tabId) {
    const tabElement = document.querySelector(`#mainTabs button[data-bs-target="#${tabId}"]`);
    if (tabElement) {
        // T·∫Øt tab ƒëang active
        document.querySelectorAll('#mainTabs .nav-link').forEach(btn => btn.classList.remove('active'));
        document.querySelectorAll('.tab-content .tab-pane').forEach(pane => pane.classList.remove('show', 'active'));

        // B·∫≠t tab m·ªõi
        tabElement.classList.add('active');
        document.getElementById(tabId).classList.add('show', 'active');
        
        // C·∫≠p nh·∫≠t view cho tab matches n·∫øu chuy·ªÉn ƒë·∫øn
        if (tabId === 'matches') {
            renderMatchesView();
        }
    }
}

// --- Helper Functions cho Base64 ---
function b64EncodeUnicode(str) {
  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g,
    function(match, p1) {
      return String.fromCharCode('0x' + p1);
    }));
}

function b64DecodeUnicode(str) {
  return decodeURIComponent(atob(str).split('').map(function(c) {
    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
  }).join(''));
}

// --- GitHub API Functions ---

/**
 * L·∫•y SHA m·ªõi nh·∫•t c·ªßa file state.json tr√™n GitHub.
 * @param {object} cfg - C·∫•u h√¨nh GitHub (owner, repo, folder, file, token)
 * @returns {Promise<{sha: string|null, content: string|null}>}
 */
async function fetchFileSha(cfg, fileName = cfg.file) {
    const filePath = `${cfg.folder}/${fileName}`;
    const apiUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}/contents/${filePath}`;
    
    try {
        const response = await fetch(apiUrl, {
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });
        
        if (response.ok) {
            const data = await response.json();
            if (fileName === cfg.file) {
                 currentSha = data.sha; // Ch·ªâ l∆∞u SHA c·ªßa state.json
            }
            return { sha: data.sha, content: data.content };
        } else if (response.status === 404) {
            if (fileName === cfg.file) {
                 currentSha = null; 
            }
            return { sha: null, content: null };
        } else {
            throw new Error(`L·ªói khi l·∫•y SHA: ${response.statusText}`);
        }
    } catch (error) {
        console.error(`L·ªói Fetch SHA (${fileName}):`, error);
        throw new Error(`L·ªói k·∫øt n·ªëi ho·∫∑c API: ${error.message}`);
    }
}

/**
 * T·∫£i danh s√°ch ƒë·ªôi t·ª´ players.json
 */
async function loadPlayersFromGitHub(cfg) {
    // players.json ph·∫£i n·∫±m c√πng th∆∞ m·ª•c v·ªõi state.json
    const fileName = 'players.json';
    
    try {
        updateStatus('configStatus', 'info', 'ƒêang t·∫£i danh s√°ch ƒë·ªôi t·ª´ GitHub (players.json)...');
        const result = await fetchFileSha(cfg, fileName); 
        
        if (result.content) {
            const jsonString = b64DecodeUnicode(result.content);
            const loadedTeams = JSON.parse(jsonString);

            if (Array.isArray(loadedTeams.mixedTeams) && Array.isArray(loadedTeams.maleTeams)) {
                state.mixedTeams = loadedTeams.mixedTeams;
                state.maleTeams = loadedTeams.maleTeams;
                updateStatus('configStatus', 'success', `T·∫£i danh s√°ch ƒë·ªôi th√†nh c√¥ng (${state.mixedTeams.length + state.maleTeams.length} ƒë·ªôi).`);
                return true;
            } else {
                throw new Error("File players.json kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng (thi·∫øu mixedTeams/maleTeams).");
            }
        } else {
             // 404 ho·∫∑c kh√¥ng c√≥ content
            updateStatus('configStatus', 'warning', 'Kh√¥ng t√¨m th·∫•y file players.json. D√πng danh s√°ch ƒë·ªôi kh·ªüi t·∫°o (tr·ªëng).');
            return false;
        }
    } catch (error) {
        console.error("L·ªói khi t·∫£i players.json:", error);
        updateStatus('configStatus', 'danger', `L·ªói t·∫£i danh s√°ch ƒë·ªôi: ${error.message}`);
        return false;
    }
}

/**
 * T·∫£i tr·∫°ng th√°i gi·∫£i ƒë·∫•u (state.json) t·ª´ GitHub.
 */
async function loadFromGitHub() {
    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) return;

    // 1. Load Teams (danh s√°ch ƒë·ªôi)
    await loadPlayersFromGitHub(cfg); 

    // 2. Load App State (state.json)
    try {
        updateStatus('configStatus', 'info', 'ƒêang t·∫£i tr·∫°ng th√°i gi·∫£i ƒë·∫•u t·ª´ GitHub (state.json)...');
        // fetchFileSha s·∫Ω t·ª± ƒë·ªông c·∫≠p nh·∫≠t currentSha
        const result = await fetchFileSha(cfg, cfg.file); 
        
        if (result.content) {
            const jsonString = b64DecodeUnicode(result.content);
            const loadedState = JSON.parse(jsonString);

            // Ghi ƒë√® c√°c gi√° tr·ªã kh√°c ngo√†i teams (teams ƒë√£ ƒë∆∞·ª£c load t·ª´ players.json)
            state.matchesA = loadedState.matchesA || [];
            state.matchesB = loadedState.matchesB || [];
            
            // T·∫£i c·∫•u h√¨nh s√¢n (NEW) - n·∫øu kh√¥ng c√≥, gi·ªØ nguy√™n m·∫∑c ƒë·ªãnh
            if (loadedState.courts) {
                state.courts = loadedState.courts;
            }
            
            // X·ª≠ l√Ω logic t·∫£i cho semifinals v√† final (ƒë·∫£m b·∫£o kh√¥ng ghi ƒë√® l·ªãch t·ª± ƒë·ªông)
            const loadedSemifinals = loadedState.semifinals;
            
            // C·∫•u tr√∫c m·∫∑c ƒë·ªãnh m·ªõi: Nh·∫•t A vs Nh√¨ A, Nh·∫•t B vs Nh√¨ B, S√¢n 3, Time m·ªõi
            const defaultSF1 = { teamA: 'Nh·∫•t A', teamB: 'Nh√¨ A', court: 'S√¢n 3', time: '16:40' };
            const defaultSF2 = { teamA: 'Nh·∫•t B', teamB: 'Nh√¨ B', court: 'S√¢n 3', time: '17:05' };
            const defaultFinal = { teamA: 'Th·∫Øng SF1', teamB: 'Th·∫Øng SF2', court: 'S√¢n 3', time: '17:30' };

            
            if (loadedSemifinals && loadedSemifinals.length === 2 && 
                (loadedSemifinals[0].teamA !== defaultSF1.teamA || loadedSemifinals[0].teamB !== defaultSF1.teamB ||
                 loadedSemifinals[1].teamA !== defaultSF2.teamA || loadedSemifinals[1].teamB !== defaultSF2.teamB)
            ) {
                // N·∫øu ƒë√£ c√≥ ƒë·ªôi th·ª±c t·∫ø ƒë∆∞·ª£c g√°n, gi·ªØ nguy√™n (ƒë√£ t√≠nh t·ª´ data v√≤ng b·∫£ng)
                state.semifinals = loadedSemifinals;
            } else if (loadedSemifinals && loadedSemifinals.length === 2) {
                // N·∫øu l√† tr·∫°ng th√°i r·ªóng, v·∫´n load (nh∆∞ng ƒë·∫£m b·∫£o court v√† time l√† m·ªõi)
                 state.semifinals = loadedSemifinals.map((sf, index) => {
                    const defaultTime = index === 0 ? '16:40' : '17:05';
                    if (sf.teamA === 'Nh·∫•t A' || sf.teamA === 'Nh·∫•t B') {
                        return { ...sf, court: 'S√¢n 3', time: defaultTime };
                    }
                    return sf;
                });
            }

            // ƒê·∫£m b·∫£o final court v√† time l√† m·ªõi n·∫øu ch∆∞a c√≥ winner
            state.final = loadedState.final || state.final;
            if (!state.final.winner) {
                state.final.court = defaultFinal.court;
                state.final.time = defaultFinal.time;
            } else if (loadedState.final && !loadedState.final.time) {
                // N·∫øu c√≥ winner nh∆∞ng kh√¥ng c√≥ time (t·ª´ phi√™n b·∫£n c≈©), c·∫≠p nh·∫≠t time
                 state.final.time = defaultFinal.time;
            }
            
            // C·∫≠p nh·∫≠t giao di·ªán
            renderMatchesView(); 
            tinhVaCapNhatXepHang();
            renderFinals();
            renderFinalResults();
            renderOverview();
            
            updateStatus('configStatus', 'success', `T·∫£i tr·∫°ng th√°i gi·∫£i ƒë·∫•u th√†nh c√¥ng t·ª´: ${cfg.owner}/${cfg.repo}/${cfg.folder}/${cfg.file}`);
            document.getElementById('lastSaved').textContent = `L·∫ßn t·∫£i: ${new Date().toLocaleTimeString('vi-VN')}`;
        } else {
            updateStatus('configStatus', 'warning', 'File tr·∫°ng th√°i (state.json) ch∆∞a t·ªìn t·∫°i. Vui l√≤ng nh·∫•n L∆∞u ho·∫∑c T·ª± ƒë·ªông l∆∞u ƒë·ªÉ t·∫°o file.');
        }

        startAutoSave();

    } catch (error) {
        updateStatus('configStatus', 'danger', `L·ªói t·∫£i tr·∫°ng th√°i gi·∫£i ƒë·∫•u: ${error.message}. Vui l√≤ng ki·ªÉm tra l·∫°i Token/Repo.`);
        console.error("L·ªói khi t·∫£i tr·∫°ng th√°i gi·∫£i ƒë·∫•u t·ª´ GitHub:", error);
    }
}

async function saveToGitHub() {
    // B·ªè qua n·∫øu kh√¥ng c√≥ thay ƒë·ªïi
    if (!stateChanged) return;

    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) {
        console.warn("Kh√¥ng th·ªÉ t·ª± ƒë·ªông l∆∞u: Thi·∫øu c·∫•u h√¨nh GitHub.");
        document.getElementById('autoState').className = 'text-warning';
        document.getElementById('autoState').textContent = 'T·∫°m d·ª´ng (Thi·∫øu Config)';
        return;
    }

    document.getElementById('autoState').className = 'text-info';
    document.getElementById('autoState').textContent = 'ƒêang l∆∞u...';

    const apiUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}/contents/${cfg.folder}/${cfg.file}`;
    
    // Ch·ªâ l∆∞u c√°c tr∆∞·ªùng c·∫ßn thi·∫øt, lo·∫°i b·ªè config v√† table (v√¨ ch√∫ng ƒë∆∞·ª£c t√≠nh l·∫°i)
    const stateToSave = {
        mixedTeams: state.mixedTeams,
        maleTeams: state.maleTeams,
        matchesA: state.matchesA,
        matchesB: state.matchesB,
        courts: state.courts,
        semifinals: state.semifinals,
        final: state.final
    };
    const content = b64EncodeUnicode(JSON.stringify(stateToSave));
    
    try {
        // Lu√¥n fetch SHA m·ªõi nh·∫•t tr∆∞·ªõc khi c·ªë g·∫Øng l∆∞u
        const result = await fetchFileSha(cfg, cfg.file); // L·∫•y SHA c·ªßa state.json
        const sha = result.sha; 
        
        const payload = {
            message: `[Auto-save] C·∫≠p nh·∫≠t tr·∫°ng th√°i gi·∫£i ƒë·∫•u TKD l√∫c ${new Date().toLocaleString('vi-VN')}`,
            content: content
        };
        
        // Ch·ªâ th√™m SHA v√†o payload n·∫øu n√≥ ƒë√£ t·ªìn t·∫°i (ƒë·ªÉ c·∫≠p nh·∫≠t), 
        if (sha) {
             payload.sha = sha;
        }

        const response = await fetch(apiUrl, {
            method: 'PUT',
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Content-Type': 'application/json',
                'Accept': 'application/vnd.github.v3+json'
            },
            body: JSON.stringify(payload)
        });

        if (response.ok) {
            const data = await response.json();
            currentSha = data.content.sha;
            stateChanged = false;
            document.getElementById('lastSaved').textContent = `L·∫ßn l∆∞u: ${new Date().toLocaleTimeString('vi-VN')}`;
            document.getElementById('autoState').className = 'text-success';
            document.getElementById('autoState').textContent = 'ƒê√£ L∆∞u';
        } else {
            // Tr∆∞·ªùng h·ª£p l·ªói 409 Conflict (SHA c≈©)
            if (response.status === 409) {
                console.warn("L·ªói 409 Conflict: D·ªØ li·ªáu ƒë√£ thay ƒë·ªïi tr√™n GitHub. ƒêang c·ªë g·∫Øng l·∫•y SHA m·ªõi.");
                
                // L·∫•y l·∫°i SHA m·ªõi nh·∫•t. stateChanged v·∫´n l√† true, 
                // ƒë·ªÉ AutoSave interval s·∫Ω th·ª≠ l·∫°i v·ªõi SHA m·ªõi trong l·∫ßn ti·∫øp theo.
                await fetchFileSha(cfg, cfg.file); 
                
                document.getElementById('autoState').className = 'text-warning';
                document.getElementById('autoState').textContent = 'Conflict. S·∫Ω th·ª≠ l∆∞u l·∫°i sau 1 ph√∫t.';
            } else {
                throw new Error(`L·ªói HTTP: ${response.status} - ${response.statusText}`);
            }
        }
    } catch (error) {
        console.error("L·ªói khi l∆∞u l√™n GitHub:", error);
        document.getElementById('autoState').className = 'text-danger';
        document.getElementById('autoState').textContent = 'L·ªói L∆∞u';
    }
}

async function checkConnection() {
    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) {
        updateStatus('configStatus', 'warning', 'Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß Owner, Repo v√† Token.');
        return;
    }

    try {
        updateStatus('configStatus', 'info', 'ƒêang ki·ªÉm tra k·∫øt n·ªëi...');
        
        const repoCheckUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}`;
        const repoResponse = await fetch(repoCheckUrl, {
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });

        if (!repoResponse.ok) {
            throw new Error(`L·ªói truy c·∫≠p kho l∆∞u tr·ªØ. M√£: ${repoResponse.status}. (Ki·ªÉm tra Token/Repo/Owner)`);
        }
        
        updateStatus('configStatus', 'success', 'K·∫øt n·ªëi GitHub th√†nh c√¥ng! ƒêang t·∫£i d·ªØ li·ªáu...');
        await loadFromGitHub();

    } catch (error) {
        updateStatus('configStatus', 'danger', `Ki·ªÉm tra k·∫øt n·ªëi th·∫•t b·∫°i: ${error.message}.`);
        console.error("L·ªói ki·ªÉm tra k·∫øt n·ªëi:", error);
    }
}

/**
 * C·∫≠p nh·∫≠t c·∫•u h√¨nh ∆∞u ti√™n s√¢n cho t√≠nh nƒÉng T·∫°o l·ªãch T·ªëi ∆∞u v√† l∆∞u v√†o LocalStorage.
 */
function updatePreferredCourtType() {
    const select = document.getElementById('preferredCourtType');
    if (select) {
        state.config.preferredCourtType = select.value;
        saveConfig(); // L∆∞u c·∫•u h√¨nh Local (bao g·ªìm c·∫£ court preference)
        updateStatus('configStatus', 'success', `ƒê√£ c·∫≠p nh·∫≠t ∆∞u ti√™n s√¢n th√†nh: ${select.options[select.selectedIndex].text}.`);
    }
}

// --- C·∫•u h√¨nh & Kh·ªüi t·∫°o ---

function renderConfig() {
    // Ch·ªâ c·∫ßn hi·ªÉn th·ªã c·∫•u h√¨nh s√¢n hi·ªán t·∫°i
    renderCourtList();
    document.getElementById('courtConfigStatus').innerHTML = '';
    
    // C·∫≠p nh·∫≠t UI cho preferredCourtType khi v√†o tab config
    const select = document.getElementById('preferredCourtType');
    if (select) {
         select.value = state.config.preferredCourtType || 'mixed';
    }
}

/**
 * Hi·ªÉn th·ªã danh s√°ch s√¢n d∆∞·ªõi d·∫°ng b·∫£ng v·ªõi n√∫t S·ª≠a/X√≥a.
 */
function renderCourtList() {
    const container = document.getElementById('courtListContainer');
    if (!container) return;
    
    if (state.courts.length === 0) {
        container.innerHTML = `<div class="alert alert-warning">Ch∆∞a c√≥ s√¢n n√†o ƒë∆∞·ª£c c·∫•u h√¨nh.</div>`;
        return;
    }
    
    let html = `<div class='table-responsive'><table class='table table-striped table-sm'>
        <thead>
            <tr>
                <th>T√™n S√¢n</th>
                <th>Gi·ªù B·∫Øt ƒê·∫ßu</th>
                <th>Th·ªùi L∆∞·ª£ng Max (Ph√∫t)</th>
                <th>Ph√¢n Lo·∫°i</th>
                <th class="text-center">H√†nh ƒë·ªông</th>
            </tr>
        </thead>
        <tbody>`;
        
    state.courts.forEach((court, index) => {
        const type = court.isMixed ? 'B·∫£ng A (Nam - N·ªØ)' : 'B·∫£ng B (Nam)';
        const typeClass = court.isMixed ? 'badge bg-primary' : 'badge bg-info';
        
        html += `<tr>
            <td>${court.name}</td>
            <td>${court.startTime}</td>
            <td>${court.maxDurationMinutes}</td>
            <td><span class="${typeClass}">${type}</span></td>
            <td class="text-center">
                <button class="btn btn-sm btn-outline-secondary me-1" onclick="openCourtModal(${index})">S·ª≠a</button>
                <button class="btn btn-sm btn-outline-danger" onclick="deleteCourt(${index})">X√≥a</button>
            </td>
        </tr>`;
    });
    
    html += `</tbody></table></div>`;
    container.innerHTML = html;
}

/**
 * M·ªü modal th√™m/s·ª≠a s√¢n v√† ƒëi·ªÅn d·ªØ li·ªáu n·∫øu l√† ch·∫ø ƒë·ªô s·ª≠a.
 * @param {number | null} index - Ch·ªâ s·ªë c·ªßa s√¢n c·∫ßn s·ª≠a, ho·∫∑c null n·∫øu th√™m m·ªõi.
 */
function openCourtModal(index = null) {
    const modal = new bootstrap.Modal(document.getElementById('courtModal'));
    document.getElementById('courtFormStatus').innerHTML = '';

    document.getElementById('courtIndex').value = index !== null ? index : '';
    document.getElementById('courtModalLabel').textContent = index !== null ? 'S·ª≠a C·∫•u h√¨nh S√¢n' : 'Th√™m S√¢n M·ªõi';

    if (index !== null) {
        const court = state.courts[index];
        document.getElementById('courtName').value = court.name || '';
        document.getElementById('courtStartTime').value = court.startTime || '14:00';
        document.getElementById('courtMaxDuration').value = court.maxDurationMinutes || 180;
        document.getElementById('courtIsMixed').checked = court.isMixed || false;
    } else {
        // Ch·∫ø ƒë·ªô th√™m m·ªõi: Reset form
        document.getElementById('courtName').value = '';
        document.getElementById('courtStartTime').value = '14:00';
        document.getElementById('courtMaxDuration').value = '180';
        document.getElementById('courtIsMixed').checked = true; // Default to Mixed (B·∫£ng A)
    }

    modal.show();
}

/**
 * L∆∞u thay ƒë·ªïi t·ª´ modal v√†o state.courts
 */
function saveCourtChanges() {
    const indexStr = document.getElementById('courtIndex').value;
    const index = indexStr === '' ? null : parseInt(indexStr);
    
    const name = document.getElementById('courtName').value.trim();
    const startTime = document.getElementById('courtStartTime').value;
    const maxDurationMinutes = parseInt(document.getElementById('courtMaxDuration').value);
    const isMixed = document.getElementById('courtIsMixed').checked;

    const statusDiv = document.getElementById('courtFormStatus');

    // Validation
    if (!name || !startTime || isNaN(maxDurationMinutes) || maxDurationMinutes <= 0) {
        statusDiv.innerHTML = `<div class="alert alert-danger p-2">Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß v√† h·ª£p l·ªá c√°c tr∆∞·ªùng (T√™n, Gi·ªù, Th·ªùi l∆∞·ª£ng > 0).</div>`;
        return;
    }
    
    // Check for duplicate name (excluding the current edited court)
    const isDuplicate = state.courts.some((c, i) => i !== index && c.name.toLowerCase() === name.toLowerCase()
    );
    if (isDuplicate) {
        statusDiv.innerHTML = `<div class="alert alert-danger p-2">T√™n s√¢n "${name}" ƒë√£ t·ªìn t·∫°i.</div>`;
        return;
    }

    const newCourt = { name, startTime, maxDurationMinutes, isMixed };

    if (index !== null) {
        // Edit mode
        state.courts[index] = newCourt;
    } else {
        // Add mode
        state.courts.push(newCourt);
    }

    // Close modal
    bootstrap.Modal.getInstance(document.getElementById('courtModal')).hide();

    // Update UI and save
    renderCourtList();
    stateChanged = true;
    updateStatus('courtConfigStatus', 'success', `ƒê√£ ${index !== null ? 'c·∫≠p nh·∫≠t' : 'th√™m'} s√¢n "${name}". D·ªØ li·ªáu s·∫Ω ƒë∆∞·ª£c t·ª± ƒë·ªông l∆∞u l√™n GitHub.`);
    saveToGitHub();
}

/**
 * X√≥a s√¢n kh·ªèi danh s√°ch.
 * @param {number} index - Ch·ªâ s·ªë c·ªßa s√¢n c·∫ßn x√≥a.
 */
function deleteCourt(index) {
    if (confirm(`B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a s√¢n "${state.courts[index].name}"?`)) {
        const deletedCourtName = state.courts[index].name;
        state.courts.splice(index, 1);
        renderCourtList();
        stateChanged = true;
        updateStatus('courtConfigStatus', 'success', `ƒê√£ x√≥a s√¢n "${deletedCourtName}". D·ªØ li·ªáu s·∫Ω ƒë∆∞·ª£c t·ª± ƒë·ªông l∆∞u l√™n GitHub.`);
        saveToGitHub();
    }
}

/**
 * T·∫£i c·∫•u h√¨nh m·∫∑c ƒë·ªãnh (ƒê√É C·∫¨P NH·∫¨T S√ÇN 1 -> S√ÇN 8)
 */
function loadDefaultCourtConfig() {
    state.courts = [
      { name: 'S√¢n 1', startTime: '14:00', maxDurationMinutes: 180, isMixed: true },
      { name: 'S√¢n 2', startTime: '14:00', maxDurationMinutes: 180, isMixed: true },
      { name: 'S√¢n 3', startTime: '14:00', maxDurationMinutes: 180, isMixed: true },
      { name: 'S√¢n 4', startTime: '14:00', maxDurationMinutes: 180, isMixed: true },
      { name: 'S√¢n 5', startTime: '14:00', maxDurationMinutes: 180, isMixed: false },
      { name: 'S√¢n 6', startTime: '14:00', maxDurationMinutes: 180, isMixed: false },
      { name: 'S√¢n 7', startTime: '14:00', maxDurationMinutes: 180, isMixed: false },
      { name: 'S√¢n 8', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }
    ];
    renderCourtList();
    stateChanged = true;
    updateStatus('courtConfigStatus', 'success', 'ƒê√£ t·∫£i c·∫•u h√¨nh s√¢n M·∫∑c ƒë·ªãnh (S√¢n 1 -> S√¢n 8). D·ªØ li·ªáu s·∫Ω ƒë∆∞·ª£c t·ª± ƒë·ªông l∆∞u l√™n GitHub.');
    saveToGitHub();
}

function loadConfig() {
    const savedConfig = localStorage.getItem('pkb_config');
    if (savedConfig) {
        state.config = JSON.parse(savedConfig);
        document.getElementById('cfgOwner').value = state.config.owner || '';
        document.getElementById('cfgRepo').value = state.config.repo || '';
        document.getElementById('cfgFolder').value = state.config.folder || 'data';
        document.getElementById('cfgFile').value = state.config.file || 'state.json';
        document.getElementById('cfgToken').value = state.config.token || '';

        // NEW: Load preferredCourtType v√† c·∫≠p nh·∫≠t UI (n·∫øu c√≥)
        state.config.preferredCourtType = state.config.preferredCourtType || 'mixed'; 
        const select = document.getElementById('preferredCourtType');
        if (select) {
             select.value = state.config.preferredCourtType;
        }
    } else {
        // ƒê·∫£m b·∫£o preferredCourtType c√≥ gi√° tr·ªã m·∫∑c ƒë·ªãnh n·∫øu ch∆∞a c√≥ config
        state.config.preferredCourtType = 'mixed';
    }
}

function saveConfig(){
    const cfg = {
        owner: document.getElementById('cfgOwner').value,
        repo: document.getElementById('cfgRepo').value,
        folder: document.getElementById('cfgFolder').value,
        file: document.getElementById('cfgFile').value,
        token: document.getElementById('cfgToken').value,
        // NEW: L∆∞u c·∫•u h√¨nh ∆∞u ti√™n s√¢n
        preferredCourtType: state.config.preferredCourtType || 'mixed'
    };
    state.config = cfg;
    localStorage.setItem('pkb_config', JSON.stringify(cfg));
    updateStatus('configStatus', 'success', 'ƒê√£ l∆∞u c·∫•u h√¨nh GitHub v√†o tr√¨nh duy·ªát. Vui l√≤ng Ki·ªÉm tra & T·∫£i D·ªØ li·ªáu.');
}

function updateStatus(id, type, message) {
    const statusDiv = document.getElementById(id);
    statusDiv.innerHTML = `<div class="alert alert-${type} p-2 mt-2">${message}</div>`;
}

function startAutoSave() {
    if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
    }
    if (state.config.token && state.config.owner && state.config.repo) {
        autoSaveInterval = setInterval(saveToGitHub, 60000);
        document.getElementById('autoState').className = 'text-warning';
        document.getElementById('autoState').textContent = 'Ho·∫°t ƒë·ªông...';
    } else {
        document.getElementById('autoState').className = 'text-danger';
        document.getElementById('autoState').textContent = 'T·∫Øt';
    }
}

window.onload = function() {
    loadConfig(); // ƒê√£ bao g·ªìm load preferredCourtType

    // ƒê·∫∑t m·∫∑c ƒë·ªãnh cho select box th√†nh 'court' khi load trang (d√π ƒë√£ c√≥ 'selected' trong HTML)
    const viewModeSelect = document.getElementById('viewMode');
    if (viewModeSelect && viewModeSelect.value !== 'court') {
        viewModeSelect.value = 'court';
    }

    if (state.config.token) {
        // B·∫Øt ƒë·∫ßu quy tr√¨nh t·∫£i Teams v√† App State t·ª´ GitHub
        loadFromGitHub();
    } else {
        // T·∫£i c·∫•u h√¨nh s√¢n m·∫∑c ƒë·ªãnh n·∫øu kh√¥ng c√≥ k·∫øt n·ªëi GitHub
        renderConfig();
        renderMatchesView();
        tinhVaCapNhatXepHang();
        renderFinals();
        renderFinalResults();
        renderOverview();
        startAutoSave();
    }
};

// --- Tab T·ªïng quan ---
/**
 * Render danh s√°ch ƒë·ªôi ƒë·∫ßy ƒë·ªß cho Overview
 */
function renderTeamList(teams, title) {
    if (!teams || teams.length === 0) {
        return `<p class="small text-muted text-center">Ch∆∞a c√≥ danh s√°ch ƒë·ªôi cho ${title}.</p>`;
    }

    let html = `
        <div class="card mt-3 mb-3 shadow-sm">
            <div class="card-header bg-secondary text-white p-2">
                <h6 class="mb-0 small">${title} (${teams.length} ƒë·ªôi)</h6>
            </div>
            <div class="card-body p-2">
                <ul class="list-unstyled mb-0 d-flex flex-wrap gap-3">`;
    teams.forEach(team => {
        html += `<li class="small text-nowrap"><strong>${team}</strong></li>`;
    });
    html += `
                </ul>
            </div>
        </div>
    `;
    return html;
}

function renderOverview() {
    const totalMatches = state.matchesA.length + state.matchesB.length;
    const completedMatches = [...state.matchesA, ...state.matchesB].filter(m => m.winner).length;

    // ƒê·∫øm s·ªë tr·∫≠n ƒë√£ ho√†n th√†nh v√† s·∫Øp x·∫øp theo s√¢n
    const matchesByCourt = {};
    const allMatches = [...state.matchesA, ...state.matchesB];

    // L·∫•y danh s√°ch s√¢n t·ª´ c·∫•u h√¨nh
    const courtNames = state.courts.map(c => c.name);
    courtNames.forEach(name => {
        matchesByCourt[name] = { total: 0, completed: 0, matches: [] };
    });

    allMatches.forEach(match => {
        if (match.court) {
            if (!matchesByCourt[match.court]) {
                matchesByCourt[match.court] = { total: 0, completed: 0, matches: [] };
            }
            matchesByCourt[match.court].total += 1;
            if (match.winner) {
                matchesByCourt[match.court].completed += 1;
            }
            matchesByCourt[match.court].matches.push(match);
        }
    });

    let courtSummaryHTML = `<ul class="list-group">`;
    Object.entries(matchesByCourt).forEach(([courtName, data]) => {
        if (data.total > 0) {
            const progress = data.total > 0 ? ((data.completed / data.total) * 100).toFixed(0) : 0;
            const progressClass = progress == 100 ? 'bg-success' : (progress > 50 ? 'bg-warning' : 'bg-info');

            courtSummaryHTML += `
                <li class="list-group-item">
                    <div class="d-flex w-100 justify-content-between">
                        <h6 class="mb-1">${courtName}</h6>
                        <small>${data.completed}/${data.total} tr·∫≠n (${progress}%)</small>
                    </div>
                    <div class="progress mt-1" role="progressbar" style="height: 5px;">
                        <div class="progress-bar ${progressClass}" style="width: ${progress}%"></div>
                    </div>
                </li>
            `;
        }
    });
    courtSummaryHTML += `</ul>`;

    // T·ªïng quan
    let html = `
        ${renderTeamList(state.mixedTeams, 'Danh s√°ch ƒê·ªôi B·∫£ng A (Nam - N·ªØ)')}
        ${renderTeamList(state.maleTeams, 'Danh s√°ch ƒê·ªôi B·∫£ng B (Nam)')}
        
        <div class="card mb-4 shadow-sm">
            <div class="card-header bg-primary text-white">
                <h6>T√¨nh h√¨nh V√≤ng B·∫£ng</h6>
            </div>
            <div class="card-body">
                <p class="card-text">T·ªïng s·ªë tr·∫≠n ƒë·∫•u: <strong>${totalMatches}</strong></p>
                <p class="card-text">S·ªë tr·∫≠n ƒë√£ ho√†n th√†nh: <strong>${completedMatches}</strong></p>
                <p class="card-text">T·ªâ l·ªá ho√†n th√†nh: <strong>${totalMatches > 0 ? ((completedMatches / totalMatches) * 100).toFixed(2) : 0}%</strong></p>
                <button class="btn btn-sm btn-outline-primary" onclick="switchTab('matches')">Xem chi ti·∫øt l·ªãch thi ƒë·∫•u</button>
            </div>
        </div>

        <div class="card mb-4 shadow-sm">
            <div class="card-header bg-info text-white">
                <h6>Ti·∫øn ƒë·ªô theo S√¢n thi ƒë·∫•u</h6>
            </div>
            <div class="card-body p-0">
                ${courtSummaryHTML}
            </div>
        </div>

        <div class="row">
            <div class="col-md-6">
                <div class="card shadow-sm">
                    <div class="card-header bg-success text-white">
                        <h6>B·∫£ng A (Nam - N·ªØ)</h6>
                    </div>
                    <div class="card-body p-2">
                        ${renderSimpleRanking(state.tableA)}
                    </div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="card shadow-sm">
                    <div class="card-header bg-danger text-white">
                        <h6>B·∫£ng B (Nam)</h6>
                    </div>
                    <div class="card-body p-2">
                        ${renderSimpleRanking(state.tableB)}
                    </div>
                </div>
            </div>
        </div>
    `;

    document.getElementById('overviewContent').innerHTML = html;
}

/**
 * Hi·ªÉn th·ªã b·∫£ng x·∫øp h·∫°ng ƒë∆°n gi·∫£n (Ch·ªâ Top 4)
 */
function renderSimpleRanking(table) {
    if (table.length === 0) return `<p class="small text-muted p-2">Ch∆∞a ƒë·ªß d·ªØ li·ªáu v√≤ng b·∫£ng ƒë·ªÉ x·∫øp h·∫°ng.</p>`;
    
    let html = `<ol class="list-group list-group-flush small">`;
    table.slice(0, 4).forEach((team, index) => {
        const rank = index + 1;
        const rankClass = rank === 1 ? 'bg-warning' : (rank === 2 ? 'bg-info' : 'bg-secondary');

        html += `
            <li class="list-group-item d-flex justify-content-between align-items-center p-1">
                <span class="badge ${rankClass} me-2">${rank}</span>
                <strong class="text-truncate">${team.team}</strong>
                <small class="text-muted ms-auto">(${team.W}W-${team.L}L)</small>
            </li>
        `;
    });
    html += `</ol>`;
    return html;
}

// --- Tab V√≤ng B·∫£ng (Matches) ---

/**
 * Render giao di·ªán V√≤ng B·∫£ng theo ch·∫ø ƒë·ªô xem ƒë√£ ch·ªçn (Table/Court)
 */
function renderMatchesView() {
    const viewMode = document.getElementById('viewMode').value;
    const container = document.getElementById('matchesViewContent');
    container.innerHTML = ''; // Clear previous content

    if (viewMode === 'table') {
        renderMatchesByGroup(container);
    } else if (viewMode === 'court') {
        renderMatchesByCourt(container);
    }
}

/**
 * Render V√≤ng B·∫£ng theo c·∫•u tr√∫c B·∫£ng A / B·∫£ng B
 */
function renderMatchesByGroup(container) {
    const teamsA = state.mixedTeams.map(t => t.name); // Ch·ªâ l·∫•y t√™n ƒë·ªôi
    const teamsB = state.maleTeams.map(t => t.name);

    let html = ``;

    // B·∫£ng A
    html += `<h6 id="scheduleAHeader" class="mt-4">B·∫£ng A (Nam - N·ªØ) - ${state.matchesA.length} tr·∫≠n</h6>`;
    html += renderMatchTable(state.matchesA, 'matchesA', teamsA);

    // B·∫£ng B
    html += `<h6 class="mt-4">B·∫£ng B (Nam) - ${state.matchesB.length} tr·∫≠n</h6>`;
    html += renderMatchTable(state.matchesB, 'matchesB', teamsB);

    container.innerHTML = html;
}

/**
 * Render V√≤ng B·∫£ng theo c·∫•u tr√∫c S√¢n thi ƒë·∫•u
 */
function renderMatchesByCourt(container) {
    // 1. G·ªôp t·∫•t c·∫£ tr·∫≠n ƒë·∫•u
    const allMatches = [...state.matchesA.map(m => ({ ...m, group: 'matchesA', originalIndex: state.matchesA.indexOf(m) })), 
                        ...state.matchesB.map(m => ({ ...m, group: 'matchesB', originalIndex: state.matchesB.indexOf(m) }))]
                        .sort((a, b) => {
                            // S·∫Øp x·∫øp theo gi·ªù thi ƒë·∫•u
                            const timeA = a.time || '99:99';
                            const timeB = b.time || '99:99';
                            if (timeA < timeB) return -1;
                            if (timeA > timeB) return 1;
                            
                            // C√πng gi·ªù th√¨ s·∫Øp x·∫øp theo S√¢n
                            if (a.court < b.court) return -1;
                            if (a.court > b.court) return 1;
                            
                            return 0;
                        });
                        
    // 2. Gom nh√≥m theo S√¢n
    const matchesByCourt = allMatches.reduce((acc, match) => {
        const courtName = match.court || 'Ch∆∞a x·∫øp s√¢n';
        if (!acc[courtName]) {
            acc[courtName] = [];
        }
        acc[courtName].push(match);
        return acc;
    }, {});
    
    // 3. Render
    let html = ``;
    const courtNames = Object.keys(matchesByCourt).sort(); // S·∫Øp x·∫øp theo t√™n s√¢n
    
    courtNames.forEach(courtName => {
        const courtMatches = matchesByCourt[courtName];
        const teams = courtMatches[0].bang === 'A' ? state.mixedTeams.map(t => t.name) : state.maleTeams.map(t => t.name);
        
        const completedCount = courtMatches.filter(m => m.winner).length;
        const totalCount = courtMatches.length;
        const progress = totalCount > 0 ? ((completedCount / totalCount) * 100).toFixed(0) : 0;
        
        html += `<h6 class="mt-4">${courtName} (B·∫£ng ${courtMatches[0].bang || '?'}) - ${completedCount}/${totalCount} tr·∫≠n (${progress}%)</h6>`;
        
        // C·∫ßn truy·ªÅn ƒë√∫ng group (matchesA/matchesB) v√† index c·ªßa tr·∫≠n ƒë·∫•u trong group ƒë√≥
        // V√¨ match trong courtMatches ƒë√£ c√≥ group v√† index g·ªëc
        html += renderMatchTable(courtMatches, 'dynamic', teams); 
    });

    container.innerHTML = html;
}

/**
 * T·∫°o HTML cho b·∫£ng k·∫øt qu·∫£ c√°c tr·∫≠n ƒë·∫•u
 * @param {Array} matches - M·∫£ng c√°c tr·∫≠n ƒë·∫•u (matchesA ho·∫∑c matchesB)
 * @param {string} group - T√™n nh√≥m ('matchesA', 'matchesB', ho·∫∑c 'dynamic')
 * @param {Array} teams - Danh s√°ch ƒë·ªôi c·ªßa b·∫£ng (ƒë·ªÉ ki·ªÉm tra xem ƒë·ªôi c√≥ t·ªìn t·∫°i kh√¥ng)
 */
function renderMatchTable(matches, group, teams) {
    if (matches.length === 0) {
        return `<div class="alert alert-info">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u cho nh√≥m n√†y.</div>`;
    }

    let html = `
        <div class="table-responsive">
        <table class="table table-striped table-hover table-sm">
            <thead>
                <tr>
                    <th>Gi·ªù</th>
                    <th>S√¢n</th>
                    <th>ƒê·ªôi A</th>
                    <th>ƒê·ªôi B</th>
                    <th class="text-center">A</th>
                    <th class="text-center">B</th>
                    <th>Th·∫Øng</th>
                </tr>
            </thead>
            <tbody>
    `;

    matches.forEach((match, index) => {
        // N·∫øu l√† ch·∫ø ƒë·ªô 'dynamic', c·∫ßn l·∫•y index g·ªëc t·ª´ tr∆∞·ªùng 'originalIndex' v√† group g·ªëc
        const matchIndex = group === 'dynamic' ? match.originalIndex : index;
        const matchGroup = group === 'dynamic' ? match.group : group;
        
        const teamA_Class = match.winner === match.teamA ? 'winner' : (match.loser === match.teamA ? 'loser' : '');
        const teamB_Class = match.winner === match.teamB ? 'winner' : (match.loser === match.teamB ? 'loser' : '');
        const matchRowClass = match.winner ? 'table-light' : '';
        
        // Ki·ªÉm tra xem ƒë·ªôi c√≥ c√≤n t·ªìn t·∫°i trong danh s√°ch kh√¥ng (tr√°nh l·ªói n·∫øu danh s√°ch ƒë·ªôi b·ªã load l·∫°i)
        const teamAValid = teams.includes(match.teamA);
        const teamBValid = teams.includes(match.teamB);
        const invalidClass = (match.teamA && !teamAValid) || (match.teamB && !teamBValid) ? 'table-danger' : '';

        html += `
            <tr class="${matchRowClass} ${invalidClass}">
                <td>${match.time || '-'}</td>
                <td>${match.court || '-'}</td>
                <td class="text-truncate ${teamA_Class}">${match.teamA}</td>
                <td class="text-truncate ${teamB_Class}">${match.teamB}</td>
                <td class="match-score-cell">
                    <input type="number" id="score-${matchGroup}-${matchIndex}-A" 
                        value="${match.scoreA !== null ? match.scoreA : ''}" 
                        min="0" onchange="updateScore('${matchGroup}', ${matchIndex})">
                </td>
                <td class="match-score-cell">
                    <input type="number" id="score-${matchGroup}-${matchIndex}-B" 
                        value="${match.scoreB !== null ? match.scoreB : ''}" 
                        min="0" onchange="updateScore('${matchGroup}', ${matchIndex})">
                </td>
                <td class="text-truncate small ${match.winner ? 'winner' : ''}">${match.winner || '-'}</td>
            </tr>
        `;
    });

    html += `
            </tbody>
        </table>
        </div>
    `;
    return html;
}

/**
 * C·∫≠p nh·∫≠t ƒëi·ªÉm v√† x√°c ƒë·ªãnh ng∆∞·ªùi th·∫Øng cu·ªôc
 */
function updateScore(group, index) {
    const matchArray = group === 'matchesA' ? state.matchesA : state.matchesB;
    const match = matchArray[index];

    const scoreAInput = document.getElementById(`score-${group}-${index}-A`);
    const scoreBInput = document.getElementById(`score-${group}-${index}-B`);
    
    // ƒê·∫£m b·∫£o gi√° tr·ªã l√† s·ªë ho·∫∑c null
    const scoreA = scoreAInput.value === '' ? null : parseInt(scoreAInput.value);
    const scoreB = scoreBInput.value === '' ? null : parseInt(scoreBInput.value);

    // C·∫≠p nh·∫≠t state
    match.scoreA = scoreA;
    match.scoreB = scoreB;
    match.winner = null;
    match.loser = null;

    if (scoreA !== null && scoreB !== null && scoreA !== scoreB) {
        if (scoreA > scoreB) {
            match.winner = match.teamA;
            match.loser = match.teamB;
        } else {
            match.winner = match.teamB;
            match.loser = match.teamA;
        }
    }

    // C·∫≠p nh·∫≠t l·∫°i UI sau khi t√≠nh to√°n
    renderMatchesView(); 
    tinhVaCapNhatXepHang(); // C·∫ßn t√≠nh l·∫°i x·∫øp h·∫°ng
    renderFinals(); // C·∫≠p nh·∫≠t V√≤ng Chung k·∫øt
    
    stateChanged = true;
    saveToGitHub();
}

// --- X·∫øp h·∫°ng (Ranking) ---

/**
 * H√†m t√≠nh to√°n v√† c·∫≠p nh·∫≠t b·∫£ng x·∫øp h·∫°ng cho c·∫£ hai b·∫£ng A v√† B.
 */
function tinhVaCapNhatXepHang() {
    state.tableA = tinhXepHang(state.mixedTeams, state.matchesA);
    state.tableB = tinhXepHang(state.maleTeams, state.matchesB);
    
    // C·∫≠p nh·∫≠t l·∫°i giao di·ªán K·∫øt qu·∫£ Chung cu·ªôc (v√¨ n√≥ c≈©ng d√πng ranking)
    renderFinalResults();
    renderOverview();
}

/**
 * H√†m t√≠nh to√°n b·∫£ng x·∫øp h·∫°ng
 * @param {Array<string>} teams - Danh s√°ch t√™n c√°c ƒë·ªôi trong b·∫£ng (mixedTeams, maleTeams)
 * @param {Array} matches - Danh s√°ch c√°c tr·∫≠n ƒë·∫•u trong b·∫£ng (matchesA, matchesB)
 * @returns {Array<Object>} B·∫£ng x·∫øp h·∫°ng ƒë√£ s·∫Øp x·∫øp
 */
function tinhXepHang(teams, matches) {
    // 1. Kh·ªüi t·∫°o b·∫£ng th·ªëng k√™
    const stats = {};
    teams.forEach(team => {
        stats[team] = {
            team: team,
            W: 0, 
            L: 0, 
            PF: 0, // Points For (ƒêi·ªÉm th·∫Øng)
            PA: 0, // Points Against (ƒêi·ªÉm thua)
            PD: 0, // Point Difference (Hi·ªáu s·ªë)
            matchesPlayed: 0
        };
    });

    // 2. ƒêi·ªÅn d·ªØ li·ªáu t·ª´ c√°c tr·∫≠n ƒë√£ ho√†n th√†nh
    matches.forEach(match => {
        if (match.winner) {
            const statA = stats[match.teamA];
            const statB = stats[match.teamB];

            if (!statA || !statB) return; // B·ªè qua n·∫øu ƒë·ªôi kh√¥ng c√≤n trong danh s√°ch

            statA.matchesPlayed++;
            statB.matchesPlayed++;
            
            // C·∫≠p nh·∫≠t ƒëi·ªÉm PF/PA
            statA.PF += match.scoreA;
            statA.PA += match.scoreB;
            statB.PF += match.scoreB;
            statB.PA += match.scoreA;
            
            // C·∫≠p nh·∫≠t W/L
            if (match.winner === match.teamA) {
                statA.W++;
                statB.L++;
            } else {
                statA.L++;
                statB.W++;
            }
        }
    });

    // 3. T√≠nh hi·ªáu s·ªë (PD)
    Object.values(stats).forEach(stat => {
        stat.PD = stat.PF - stat.PA;
    });

    // 4. Chuy·ªÉn th√†nh m·∫£ng v√† l·ªçc c√°c ƒë·ªôi ch∆∞a ƒë·∫•u
    let table = Object.values(stats).filter(stat => stat.matchesPlayed > 0);
    
    // 5. S·∫Øp x·∫øp s∆° b·ªô (W > Hi·ªáu s·ªë)
    table.sort((a, b) => {
        if (b.W !== a.W) return b.W - a.W;      // 1. Th·∫Øng nhi·ªÅu h∆°n
        if (b.PD !== a.PD) return b.PD - a.PD;  // 2. Hi·ªáu s·ªë cao h∆°n
        if (b.PF !== a.PF) return b.PF - a.PF;  // 3. T·ªïng ƒëi·ªÉm th·∫Øng cao h∆°n
        return 0;
    });
    
    // 6. X·ª≠ l√Ω tie-breaker b·∫±ng ƒë·ªëi ƒë·∫ßu (ch·ªâ cho W b·∫±ng nhau)
    
    // T√¨m c√°c nh√≥m b·ªã tie (c√πng W)
    let finalTable = [];
    let i = 0;
    while (i < table.length) {
        let j = i;
        while (j < table.length && table[j].W === table[i].W) {
            j++;
        }
        
        const tiedGroup = table.slice(i, j);
        
        if (tiedGroup.length > 1) {
            // Ch·ªâ √°p d·ª•ng tie-breaker ƒë·ªëi ƒë·∫ßu n·∫øu W, PD, PF B·∫∞NG NHAU (t·ª©c l√† ch·ªâ c√≥ W b·∫±ng nhau th√¥i)
            // Thay ƒë·ªïi logic: ch·ªâ c·∫ßn W b·∫±ng nhau, sau ƒë√≥ m·ªõi x√©t ƒë·∫øn c√°c ti√™u ch√≠ ph·ª•
            
            // T√¨m c√°c nh√≥m b·ªã tie (c√πng W)
            let subGroups = [];
            let k = i;
            while (k < j) {
                let l = k;
                while (l < j && table[l].W === table[k].W && table[l].PD === table[k].PD && table[l].PF === table[k].PF) {
                    l++;
                }
                subGroups.push(table.slice(k, l));
                k = l;
            }

            subGroups.forEach(subGroup => {
                if (subGroup.length > 1) {
                    // √Åp d·ª•ng tie-breaker ƒë·ªëi ƒë·∫ßu cho nh√≥m c√≥ W, PD, PF b·∫±ng nhau
                    const headToHeadTable = tinhDiemDoiDau(subGroup, matches);
                    
                    // S·∫Øp x·∫øp l·∫°i nh√≥m con theo lu·∫≠t ƒë·ªëi ƒë·∫ßu (W > Hi·ªáu s·ªë > T·ªïng ƒëi·ªÉm th·∫Øng)
                    headToHeadTable.sort((a, b) => {
                        if (b.W_H2H !== a.W_H2H) return b.W_H2H - a.W_H2H;
                        if (b.PD_H2H !== a.PD_H2H) return b.PD_H2H - a.PD_H2H;
                        if (b.PF_H2H !== a.PF_H2H) return b.PF_H2H - a.PF_H2H;
                        return 0; // N·∫øu v·∫´n h√≤a, gi·ªØ nguy√™n th·ª© t·ª± ban ƒë·∫ßu (ho·∫∑c b·∫±ng b·ªëc thƒÉm)
                    });
                    
                    // G√°n l·∫°i c√°c tr∆∞·ªùng H2H v√† g·ªôp v√†o finalTable
                    headToHeadTable.forEach(h2hStat => {
                        const originalStat = subGroup.find(s => s.team === h2hStat.team);
                        finalTable.push(originalStat);
                    });

                } else {
                    // Nh√≥m ch·ªâ c√≥ 1 ƒë·ªôi ho·∫∑c ƒë√£ ƒë∆∞·ª£c s·∫Øp x·∫øp
                    finalTable.push(subGroup[0]);
                }
            });
            
        } else {
            // Nh√≥m ch·ªâ c√≥ 1 ƒë·ªôi (kh√¥ng c·∫ßn x·ª≠ l√Ω tie)
            finalTable.push(tiedGroup[0]);
        }
        
        i = j;
    }

    return finalTable;
}

/**
 * T√≠nh to√°n th·ªëng k√™ ƒë·ªëi ƒë·∫ßu gi·ªØa c√°c ƒë·ªôi trong m·ªôt nh√≥m.
 * @param {Array<Object>} teamsStat - Danh s√°ch c√°c ƒë·ªôi c·∫ßn x√©t (ƒë√£ b·ªã tie)
 * @param {Array} matches - T·∫•t c·∫£ tr·∫≠n ƒë·∫•u c·ªßa b·∫£ng
 * @returns {Array<Object>} Danh s√°ch th·ªëng k√™ ƒë·ªëi ƒë·∫ßu
 */
function tinhDiemDoiDau(teamsStat, matches) {
    const tiedTeams = teamsStat.map(t => t.team);
    const h2hStats = {};

    teamsStat.forEach(stat => {
        h2hStats[stat.team] = {
            team: stat.team,
            W_H2H: 0, 
            L_H2H: 0,
            PF_H2H: 0,
            PA_H2H: 0,
            PD_H2H: 0
        };
    });

    matches.forEach(match => {
        // Ch·ªâ x√©t c√°c tr·∫≠n ƒë·∫•u gi·ªØa c√°c ƒë·ªôi trong nh√≥m b·ªã tie
        if (tiedTeams.includes(match.teamA) && tiedTeams.includes(match.teamB) && match.winner) {
            const statA = h2hStats[match.teamA];
            const statB = h2hStats[match.teamB];

            // C·∫≠p nh·∫≠t PF/PA ƒë·ªëi ƒë·∫ßu
            statA.PF_H2H += match.scoreA;
            statA.PA_H2H += match.scoreB;
            statB.PF_H2H += match.scoreB;
            statB.PA_H2H += match.scoreA;

            // C·∫≠p nh·∫≠t W/L ƒë·ªëi ƒë·∫ßu
            if (match.winner === match.teamA) {
                statA.W_H2H++;
                statB.L_H2H++;
            } else {
                statA.L_H2H++;
                statB.W_H2H++;
            }
        }
    });

    Object.values(h2hStats).forEach(stat => {
        stat.PD_H2H = stat.PF_H2H - stat.PA_H2H;
    });
    
    return Object.values(h2hStats);
}


// --- Tab V√≤ng Chung K·∫øt (Finals) ---

/**
 * T·ª± ƒë·ªông l√™n l·ªãch v√† ƒëi·ªÅn ƒë·ªôi cho V√≤ng B√°n k·∫øt v√† Chung k·∫øt d·ª±a tr√™n k·∫øt qu·∫£ V√≤ng B·∫£ng.
 */
function scheduleFinalsAuto() {
    tinhVaCapNhatXepHang(); // ƒê·∫£m b·∫£o b·∫£ng x·∫øp h·∫°ng l√† m·ªõi nh·∫•t

    const tableA = state.tableA.filter(t => t.matchesPlayed > 0);
    const tableB = state.tableB.filter(t => t.matchesPlayed > 0);

    if (tableA.length < 2 || tableB.length < 2) {
        showModal('L·ªói L√™n L·ªãch Chung K·∫øt', 'Ch∆∞a c√≥ ƒë·ªß d·ªØ li·ªáu (√≠t nh·∫•t 2 ƒë·ªôi ƒë√£ thi ƒë·∫•u) t·ª´ B·∫£ng A ho·∫∑c B·∫£ng B ƒë·ªÉ l√™n l·ªãch B√°n k·∫øt.');
        return;
    }

    // 1. X√°c ƒë·ªãnh ƒë·ªôi B√°n k·∫øt
    const nhatA = tableA[0]?.team;
    const nhiA = tableA[1]?.team;
    const nhatB = tableB[0]?.team;
    const nhiB = tableB[1]?.team;
    
    // C·∫•u h√¨nh S√¢n & Gi·ªù m·ªõi (S√¢n 3, 16:40, 17:05, 17:30)
    const SF1_TIME = '16:40';
    const SF2_TIME = '17:05';
    const FINAL_TIME = '17:30';
    const FINAL_COURT = 'S√¢n 3';

    // 2. C·∫≠p nh·∫≠t V√≤ng B√°n k·∫øt (SF)
    state.semifinals[0].teamA = nhatA;
    state.semifinals[0].teamB = nhiA;
    state.semifinals[0].time = SF1_TIME;
    state.semifinals[0].court = FINAL_COURT;

    state.semifinals[1].teamA = nhatB;
    state.semifinals[1].teamB = nhiB;
    state.semifinals[1].time = SF2_TIME;
    state.semifinals[1].court = FINAL_COURT;

    // Reset k·∫øt qu·∫£ n·∫øu ƒë·ªôi thay ƒë·ªïi
    if (state.semifinals.some(sf => sf.winner) || state.final.winner) {
         // Ch·ªâ h·ªèi x√°c nh·∫≠n n·∫øu t√™n ƒë·ªôi ƒë√£ thay ƒë·ªïi so v·ªõi l·∫ßn g·∫ßn nh·∫•t
        const sf1Changed = state.semifinals[0].winner && (state.semifinals[0].teamA !== nhatA || state.semifinals[0].teamB !== nhiA);
        const sf2Changed = state.semifinals[1].winner && (state.semifinals[1].teamA !== nhatB || state.semifinals[1].teamB !== nhiB);

        if (sf1Changed || sf2Changed || state.final.winner) {
            if(confirm("L·ªãch thi ƒë·∫•u V√≤ng B·∫£ng ƒë√£ thay ƒë·ªïi, d·∫´n ƒë·∫øn vi·ªác ƒë·ªïi ƒë·ªôi v√†o B√°n k·∫øt. B·∫°n c√≥ mu·ªën x√≥a k·∫øt qu·∫£ B√°n k·∫øt v√† Chung k·∫øt c≈© ƒë·ªÉ l√™n l·ªãch l·∫°i kh√¥ng?")) {
                state.semifinals.forEach(sf => {
                    sf.scoreA = null; sf.scoreB = null; sf.winner = null; sf.loser = null;
                });
                state.final.scoreA = null; state.final.scoreB = null; state.final.winner = null; state.final.runnerUp = null;
                state.final.teamA = 'Th·∫Øng SF1'; 
                state.final.teamB = 'Th·∫Øng SF2';
            }
        }
    }
    
    // ƒê·∫£m b·∫£o th√¥ng tin S√¢n/Gi·ªù Chung k·∫øt lu√¥n ƒë√∫ng
    state.final.time = FINAL_TIME;
    state.final.court = FINAL_COURT;
    
    // 3. C·∫≠p nh·∫≠t V√≤ng Chung k·∫øt (F) - Ch·ªâ khi ƒë√£ c√≥ ng∆∞·ªùi th·∫Øng
    updateFinalsFromSemifinals();

    // 4. Render v√† Save
    renderFinals();
    renderFinalResults();
    stateChanged = true;
    saveToGitHub();
    showModal('L√™n L·ªãch Chung K·∫øt Th√†nh C√¥ng', `ƒê√£ l√™n l·ªãch B√°n k·∫øt:
        <ul class="list-unstyled small mt-2">
            <li><strong>SF1 (${SF1_TIME}):</strong> ${nhatA} vs ${nhiA} (${FINAL_COURT})</li>
            <li><strong>SF2 (${SF2_TIME}):</strong> ${nhatB} vs ${nhiB} (${FINAL_COURT})</li>
        </ul>
        V√≤ng Chung k·∫øt (${FINAL_TIME}) s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t sau khi c√≥ k·∫øt qu·∫£ B√°n k·∫øt.
    `);
}

/**
 * C·∫≠p nh·∫≠t ƒë·ªôi v√†o tr·∫≠n chung k·∫øt n·∫øu ƒë√£ c√≥ ng∆∞·ªùi th·∫Øng b√°n k·∫øt.
 */
function updateFinalsFromSemifinals() {
    const winnerSF1 = state.semifinals[0].winner;
    const winnerSF2 = state.semifinals[1].winner;

    if (winnerSF1 && winnerSF2) {
        // C·∫≠p nh·∫≠t tr·∫≠n Chung k·∫øt
        if (state.final.teamA !== winnerSF1 || state.final.teamB !== winnerSF2) {
            state.final.teamA = winnerSF1;
            state.final.teamB = winnerSF2;
            state.final.scoreA = null;
            state.final.scoreB = null;
            state.final.winner = null;
            state.final.runnerUp = null;
        }
    } else {
        // ƒê·∫£m b·∫£o tr·∫°ng th√°i default n·∫øu ch∆∞a c√≥ ƒë·ªß winner
        if (!state.final.winner) {
            state.final.teamA = 'Th·∫Øng SF1'; 
            state.final.teamB = 'Th·∫Øng SF2';
        }
    }
}

/**
 * C·∫≠p nh·∫≠t ƒëi·ªÉm v√† x√°c ƒë·ªãnh ng∆∞·ªùi th·∫Øng V√≤ng Chung k·∫øt
 * @param {number} index - Ch·ªâ s·ªë tr·∫≠n ƒë·∫•u trong semifinals (0 ho·∫∑c 1)
 * @param {string} group - 'semifinals' ho·∫∑c 'final'
 */
function updateFinalScore(group, index) {
    const matchArray = group === 'semifinals' ? state.semifinals : [state.final];
    const match = matchArray[index];

    const scoreAInput = document.getElementById(`final-score-${group}-${index}-A`);
    const scoreBInput = document.getElementById(`final-score-${group}-${index}-B`);
    
    const scoreA = scoreAInput.value === '' ? null : parseInt(scoreAInput.value);
    const scoreB = scoreBInput.value === '' ? null : parseInt(scoreBInput.value);

    // C·∫≠p nh·∫≠t state
    match.scoreA = scoreA;
    match.scoreB = scoreB;
    match.winner = null;
    match.loser = null;
    if (group === 'final') match.runnerUp = null;

    if (scoreA !== null && scoreB !== null && scoreA !== scoreB) {
        if (scoreA > scoreB) {
            match.winner = match.teamA;
            if (group === 'final') match.runnerUp = match.teamB;
            else match.loser = match.teamB;
        } else {
            match.winner = match.teamB;
            if (group === 'final') match.runnerUp = match.teamA;
            else match.loser = match.teamA;
        }
    }
    
    updateFinalsFromSemifinals();
    renderFinals();
    renderFinalResults();
    
    stateChanged = true;
    saveToGitHub();
}

/**
 * Render giao di·ªán V√≤ng Chung k·∫øt
 */
function renderFinals() {
    const containerSF = document.getElementById('semifinalMatches');
    const containerF = document.getElementById('finalMatch');
    
    // C·∫•u h√¨nh S√¢n & Gi·ªù m·ªõi
    const SF1_TIME = '16:40';
    const SF2_TIME = '17:05';
    const FINAL_TIME = '17:30';
    const FINAL_COURT = 'S√¢n 3';

    // Render B√°n k·∫øt
    let sfHtml = renderFinalMatchTable(state.semifinals, 'semifinals');
    containerSF.innerHTML = sfHtml;

    // Render Chung k·∫øt
    let fHtml = renderFinalMatchTable([state.final], 'final');
    containerF.innerHTML = fHtml;
    
    // C·∫≠p nh·∫≠t ti√™u ƒë·ªÅ HTML trong tab finals
    document.querySelector('#finalsContent h6:nth-child(1)').innerHTML = `V√≤ng B√°n k·∫øt (SF1: ${SF1_TIME}, SF2: ${SF2_TIME}, ${FINAL_COURT})`;
    document.querySelector('#finalsContent h6:nth-child(3)').innerHTML = `Tr·∫≠n Chung k·∫øt (${FINAL_TIME}, ${FINAL_COURT})`;
}

/**
 * T·∫°o HTML cho b·∫£ng k·∫øt qu·∫£ tr·∫≠n B√°n k·∫øt/Chung k·∫øt
 */
function renderFinalMatchTable(matches, group) {
    if (matches.length === 0 || (!matches[0].teamA && group === 'final')) {
        return `<div class="alert alert-info">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u. Vui l√≤ng b·∫•m "L√™n l·ªãch V√≤ng Chung k·∫øt" ·ªü tab V√≤ng B·∫£ng.</div>`;
    }

    let finalHtml = `
        <div class="table-responsive">
        <table class="table table-striped table-hover table-sm">
            <thead>
                <tr>
                    <th>Tr·∫≠n</th>
                    <th>Gi·ªù</th>
                    <th>ƒê·ªôi A</th>
                    <th>ƒê·ªôi B</th>
                    <th class="text-center">A</th>
                    <th class="text-center">B</th>
                    <th>Th·∫Øng</th>
                </tr>
            </thead>
            <tbody>
    `;

    matches.forEach((match, index) => {
        const teamA_Class = match.winner === match.teamA ? 'winner' : (match.loser === match.teamA ? 'loser' : '');
        const teamB_Class = match.winner === match.teamB ? 'winner' : (match.loser === match.teamB ? 'loser' : '');
        const matchRowClass = match.winner ? 'table-light' : '';
        
        // Ki·ªÉm tra xem c√≥ ph·∫£i l√† tr·∫≠n ch·ªù k·∫øt qu·∫£ hay kh√¥ng
        const isWaiting = match.teamA === 'Th·∫Øng SF1' || match.teamA === 'Th·∫Øng SF2';

        finalHtml += `
            <tr class="${matchRowClass}">
                <td>${match.id} (${match.court || '-'})</td>
                <td>${match.time || '-'}</td>
                <td class="text-truncate ${teamA_Class}">${match.teamA}</td>
                <td class="text-truncate ${teamB_Class}">${match.teamB}</td>
                <td class="match-score-cell">
                    <input type="number" id="final-score-${group}-${index}-A" 
                        value="${match.scoreA !== null ? match.scoreA : ''}" 
                        min="0" onchange="updateFinalScore('${group}', ${index})" 
                        ${isWaiting ? 'disabled' : ''}>
                </td>
                <td class="match-score-cell">
                    <input type="number" id="final-score-${group}-${index}-B" 
                        value="${match.scoreB !== null ? match.scoreB : ''}" 
                        min="0" onchange="updateFinalScore('${group}', ${index})" 
                        ${isWaiting ? 'disabled' : ''}>
                </td>
                <td class="text-truncate small ${match.winner ? 'winner' : ''}">
                    ${match.winner || (isWaiting ? 'Ch·ªù KQ' : '-')}
                </td>
            </tr>
        `;
    });

    finalHtml += `
            </tbody>
        </table>
        </div>
    `;
    
    return finalHtml;
}

// --- Tab K·∫øt qu·∫£ Chung cu·ªôc (Results) ---

/**
 * Render B·∫£ng x·∫øp h·∫°ng V√≤ng B·∫£ng v√† Danh hi·ªáu Chung cu·ªôc
 */
function renderFinalResults() {
    // 1. Render Ranking Tables
    const rankingContainer = document.getElementById('rankingTables');
    let rankingHtml = `
        <div>
            <h6>B·∫£ng A (Nam - N·ªØ)</h6>
            ${renderFullRankingTable(state.tableA)}
        </div>
        <div>
            <h6>B·∫£ng B (Nam)</h6>
            ${renderFullRankingTable(state.tableB)}
        </div>
    `;
    rankingContainer.innerHTML = rankingHtml;
    
    // 2. Render Final Titles
    const final = state.final;
    const thirdPlaceTeams = getThirdPlaceTeams();

    document.getElementById('champion').innerHTML = `üèÜ V√¥ ƒë·ªãch: <strong>${final.winner || 'ƒêang ch·ªù k·∫øt qu·∫£...'}</strong>`;
    document.getElementById('runnerUp').innerHTML = `ü•à √Å qu√¢n: <strong>${final.runnerUp || 'ƒêang ch·ªù k·∫øt qu·∫£...'}</strong>`;
    
    let thirdPlaceText = thirdPlaceTeams.join(' & ');
    document.getElementById('thirdPlace').innerHTML = `ü•â H·∫°ng Ba ƒê·ªìng H·∫°ng: <strong>${thirdPlaceText || 'ƒêang ch·ªù k·∫øt qu·∫£...'}</strong>`;
}

/**
 * L·∫•y ƒë·ªôi h·∫°ng ba (hai ƒë·ªôi thua B√°n k·∫øt)
 */
function getThirdPlaceTeams() {
    const loserSF1 = state.semifinals[0].loser;
    const loserSF2 = state.semifinals[1].loser;
    
    const thirdPlaceTeams = [];
    if (loserSF1) thirdPlaceTeams.push(loserSF1);
    if (loserSF2 && loserSF2 !== loserSF1) thirdPlaceTeams.push(loserSF2);
    
    return thirdPlaceTeams;
}

/**
 * Render b·∫£ng x·∫øp h·∫°ng ƒë·∫ßy ƒë·ªß
 */
function renderFullRankingTable(table) {
    if (table.length === 0) return `<div class="alert alert-info small">Ch∆∞a ƒë·ªß d·ªØ li·ªáu v√≤ng b·∫£ng ƒë·ªÉ x·∫øp h·∫°ng.</div>`;

    let html = `
        <div class="table-responsive">
        <table class="table table-bordered table-striped table-sm small">
            <thead>
                <tr>
                    <th>H·∫°ng</th>
                    <th>ƒê·ªôi</th>
                    <th>W-L</th>
                    <th>PF-PA</th>
                    <th>Hi·ªáu s·ªë</th>
                </tr>
            </thead>
            <tbody>
    `;

    table.forEach((team, index) => {
        const rankClass = index === 0 ? 'table-warning' : (index === 1 ? 'table-info' : '');
        html += `
            <tr class="${rankClass}">
                <td>${index + 1}</td>
                <td class="text-truncate"><strong>${team.team}</strong></td>
                <td>${team.W}-${team.L}</td>
                <td>${team.PF}-${team.PA}</td>
                <td>${team.PD > 0 ? '+' : ''}${team.PD}</td>
            </tr>
        `;
    });

    html += `
            </tbody>
        </table>
        </div>
    `;
    return html;
}

// --- C√¥ng c·ª• T·∫°o L·ªãch (Scheduling Tools) ---

// Chuy·ªÉn ƒë·ªïi HH:mm th√†nh s·ªë ph√∫t t·ª´ 00:00
function timeToMinutes(timeStr) {
    const [hours, minutes] = timeStr.split(':').map(Number);
    return hours * 60 + minutes;
}

// Chuy·ªÉn ƒë·ªïi s·ªë ph√∫t th√†nh HH:mm
function minutesToTime(minutes) {
    const h = Math.floor(minutes / 60);
    const m = minutes % 60;
    return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
}

/**
 * T·∫£i l·ªãch c·ªë ƒë·ªãnh t·ª´ bi·∫øn FIXED_SCHEDULE_CSV
 */
function taoLichCoDinh() {
    const csvContent = FIXED_SCHEDULE_CSV;
    const matches = parseCSV(csvContent);
    
    if (matches.length > 0) {
        // Ph√¢n lo·∫°i tr·∫≠n ƒë·∫•u
        state.matchesA = matches.filter(m => m.bang === 'A');
        state.matchesB = matches.filter(m => m.bang === 'B');
        
        // G√°n originalIndex cho ch·∫ø ƒë·ªô xem theo s√¢n
        state.matchesA.forEach((m, i) => m.originalIndex = i);
        state.matchesB.forEach((m, i) => m.originalIndex = i);
        
        renderMatchesView();
        tinhVaCapNhatXepHang();
        
        stateChanged = true;
        saveToGitHub();
        showModal('T·∫£i L·ªãch M·∫´u Th√†nh C√¥ng', `ƒê√£ t·∫£i th√†nh c√¥ng ${state.matchesA.length + state.matchesB.length} tr·∫≠n ƒë·∫•u (L·ªãch m·∫´u CalendarTKD30).`);
    } else {
        showModal('L·ªói T·∫£i L·ªãch', 'Kh√¥ng th·ªÉ ƒë·ªçc d·ªØ li·ªáu l·ªãch m·∫´u (CSV tr·ªëng ho·∫∑c l·ªói ƒë·ªãnh d·∫°ng).');
    }
}


/**
 * T·∫°o l·ªãch thi ƒë·∫•u t·ªëi ∆∞u (c√πng gi·ªù) d·ª±a tr√™n c·∫•u h√¨nh s√¢n
 */
function taoLichThiDauCungGio() {
    const allTeams = [...state.mixedTeams, ...state.maleTeams];
    if (allTeams.length === 0) {
        showModal('L·ªói T·∫°o L·ªãch', 'Kh√¥ng c√≥ danh s√°ch ƒë·ªôi. Vui l√≤ng ki·ªÉm tra l·∫°i k·∫øt n·ªëi GitHub ƒë·ªÉ t·∫£i players.json ho·∫∑c nh·∫≠p ƒë·ªôi th·ªß c√¥ng.');
        return;
    }
    
    if (state.courts.length === 0) {
        showModal('L·ªói T·∫°o L·ªãch', 'Ch∆∞a c√≥ c·∫•u h√¨nh s√¢n thi ƒë·∫•u. Vui l√≤ng c·∫•u h√¨nh s√¢n trong tab "C·∫•u h√¨nh".');
        return;
    }

    // L·ªçc ra c√°c ƒë·ªôi ƒë√£ ho√†n th√†nh √≠t nh·∫•t 2 tr·∫≠n (ƒë·ªÉ lo·∫°i ƒë·ªôi d·ª± b·ªã/ch∆∞a ch√≠nh th·ª©c)
    const teamsA = state.mixedTeams.filter(t => t.name).map(t => t.name); // Ch·ªâ l·∫•y t√™n ƒë·ªôi
    const teamsB = state.maleTeams.filter(t => t.name).map(t => t.name);

    if (teamsA.length < 2 && teamsB.length < 2) {
        showModal('L·ªói T·∫°o L·ªãch', 'C·∫ßn √≠t nh·∫•t 2 ƒë·ªôi cho B·∫£ng A ho·∫∑c B·∫£ng B ƒë·ªÉ t·∫°o l·ªãch thi ƒë·∫•u.');
        return;
    }

    const matchesA = generateAllMatches(teamsA, 'A');
    const matchesB = generateAllMatches(teamsB, 'B');

    const totalMatches = [...matchesA, ...matchesB];
    const courts = state.courts;
    const startTimeMinutes = Math.min(...courts.map(c => timeToMinutes(c.startTime)));
    const endTimeMinutes = Math.max(...courts.map(c => timeToMinutes(c.startTime) + c.maxDurationMinutes));
    const totalDurationMinutes = endTimeMinutes - startTimeMinutes;

    if (totalDurationMinutes <= 0) {
        showModal('L·ªói C·∫•u H√¨nh S√¢n', 'Th·ªùi gian k·∫øt th√∫c s√¢n (maxDuration) ph·∫£i l·ªõn h∆°n th·ªùi gian b·∫Øt ƒë·∫ßu.');
        return;
    }

    // S·∫Øp x·∫øp c√°c tr·∫≠n ƒë·∫•u theo ∆∞u ti√™n (A tr∆∞·ªõc B)
    const sortedMatches = [...matchesA, ...matchesB]; 

    // 1. Kh·ªüi t·∫°o l·ªãch s√¢n
    const courtSchedules = courts.map(court => ({
        ...court,
        currentMinutes: timeToMinutes(court.startTime),
        schedule: []
    }));
    
    // 2. Thu·∫≠t to√°n x·∫øp l·ªãch (X·∫øp theo gi·ªù s·ªõm nh·∫•t v√† ∆∞u ti√™n lo·∫°i s√¢n)
    const finalSchedule = [];
    const scheduledMatches = new Set();
    
    // L·∫•y c·∫•u h√¨nh ∆∞u ti√™n s√¢n
    const preferredType = state.config.preferredCourtType || 'mixed';
    
    // H√†m t√¨m s√¢n ph√π h·ª£p v√† s·ªõm nh·∫•t
    const findNextAvailableCourt = (matchIsMixed) => {
        
        let bestCourt = null;
        let minTime = Infinity;
        let preferenceScore = -Infinity; // ƒêi·ªÉm ∆∞u ti√™n: Cao nh·∫•t n·∫øu kh·ªõp v·ªõi preferredType

        courtSchedules.forEach(court => {
            // Ki·ªÉm tra xem s√¢n c√≥ ph√π h·ª£p v·ªõi lo·∫°i tr·∫≠n ƒë·∫•u (Mixed/Male) kh√¥ng
            const courtIsMixed = court.isMixed;
            const courtMatchesType = matchIsMixed === courtIsMixed;
            
            // T√≠nh ƒëi·ªÉm ∆∞u ti√™n
            let currentPreferenceScore = 0;
            if (preferredType === 'mixed' && courtIsMixed) {
                currentPreferenceScore = 1;
            } else if (preferredType === 'male' && !courtIsMixed) {
                currentPreferenceScore = 1;
            }

            // Ki·ªÉm tra xem s√¢n c√≥ c√≤n trong th·ªùi gian ho·∫°t ƒë·ªông kh√¥ng
            const courtEndTime = timeToMinutes(court.startTime) + court.maxDurationMinutes;
            const matchDuration = 15; // Gi·∫£ s·ª≠ m·ªói tr·∫≠n 15 ph√∫t
            const isWithinDuration = court.currentMinutes + matchDuration <= courtEndTime;

            if (courtMatchesType && isWithinDuration) {
                const currentTime = court.currentMinutes;
                
                // Ti√™u ch√≠ 1: S√¢n c√≥ ∆∞u ti√™n cao h∆°n
                if (currentPreferenceScore > preferenceScore) {
                    preferenceScore = currentPreferenceScore;
                    minTime = currentTime;
                    bestCourt = court;
                } 
                // Ti√™u ch√≠ 2: C√πng m·ª©c ∆∞u ti√™n, ch·ªçn s√¢n b·∫Øt ƒë·∫ßu s·ªõm nh·∫•t (c√πng gi·ªù)
                else if (currentPreferenceScore === preferenceScore && currentTime < minTime) {
                    minTime = currentTime;
                    bestCourt = court;
                }
                // Ti√™u ch√≠ 3: C√πng m·ª©c ∆∞u ti√™n v√† c√πng gi·ªù, ch·ªçn s√¢n c√≥ t√™n nh·ªè h∆°n (S√¢n 1 < S√¢n 2)
                else if (currentPreferenceScore === preferenceScore && currentTime === minTime && (!bestCourt || court.name < bestCourt.name)) {
                     minTime = currentTime;
                     bestCourt = court;
                }
            }
        });

        // N·∫øu kh√¥ng t√¨m ƒë∆∞·ª£c s√¢n ∆∞u ti√™n, t√¨m s√¢n h·ª£p l·ªá kh√°c
        if (!bestCourt) {
             courtSchedules.forEach(court => {
                const courtIsMixed = court.isMixed;
                const courtMatchesType = matchIsMixed === courtIsMixed;
                const courtEndTime = timeToMinutes(court.startTime) + court.maxDurationMinutes;
                const matchDuration = 15;
                const isWithinDuration = court.currentMinutes + matchDuration <= courtEndTime;
                
                if (courtMatchesType && isWithinDuration && court.currentMinutes < minTime) {
                    minTime = court.currentMinutes;
                    bestCourt = court;
                }
             });
        }

        return bestCourt;
    };
    
    // V√≤ng l·∫∑p x·∫øp l·ªãch
    while (finalSchedule.length < totalMatches.length) {
        let matchPlaced = false;
        
        // V√≤ng l·∫∑p qua t·∫•t c·∫£ c√°c tr·∫≠n ƒë·∫•u ch∆∞a x·∫øp l·ªãch
        for (let i = 0; i < sortedMatches.length; i++) {
            const match = sortedMatches[i];
            if (scheduledMatches.has(match)) continue;

            const matchIsMixed = match.bang === 'A';
            const bestCourt = findNextAvailableCourt(matchIsMixed);

            if (bestCourt) {
                const matchDuration = 15; // Gi·∫£ s·ª≠ c·ªë ƒë·ªãnh 15 ph√∫t/tr·∫≠n
                
                const scheduledMatch = {
                    ...match,
                    time: minutesToTime(bestCourt.currentMinutes),
                    court: bestCourt.name,
                    originalIndex: i // L∆∞u index g·ªëc ƒë·ªÉ d·ªÖ d√†ng update score
                };

                finalSchedule.push(scheduledMatch);
                scheduledMatches.add(match);
                
                // C·∫≠p nh·∫≠t th·ªùi gian b·∫Øt ƒë·∫ßu c·ªßa s√¢n
                bestCourt.currentMinutes += matchDuration;
                
                matchPlaced = true;
                break; // Sau khi x·∫øp ƒë∆∞·ª£c 1 tr·∫≠n, kh·ªüi t·∫°o l·∫°i v√≤ng l·∫∑p ƒë·ªÉ ƒë·∫£m b·∫£o t√¨m s√¢n s·ªõm nh·∫•t
            }
        }
        
        if (!matchPlaced) {
            // Kh√¥ng c√≤n tr·∫≠n n√†o x·∫øp ƒë∆∞·ª£c v√†o s√¢n c√≤n tr·ªëng/c√≤n th·ªùi gian
            break; 
        }
    }
    
    if (finalSchedule.length < totalMatches.length) {
        console.warn(`Ch·ªâ x·∫øp l·ªãch ƒë∆∞·ª£c ${finalSchedule.length} / ${totalMatches.length} tr·∫≠n. S√¢n c√≥ th·ªÉ ƒë√£ h·∫øt gi·ªù.`);
    }

    // 4. C·∫≠p nh·∫≠t state v√† UI
    state.matchesA = finalSchedule.filter(m => m.bang === 'A');
    state.matchesB = finalSchedule.filter(m => m.bang === 'B');
    
    // C·∫≠p nh·∫≠t originalIndex (d√πng ƒë·ªÉ updateScore)
    state.matchesA.forEach((m, i) => m.originalIndex = i);
    state.matchesB.forEach((m, i) => m.originalIndex = i);

    renderMatchesView();
    tinhVaCapNhatXepHang();
    
    stateChanged = true;
    saveToGitHub();
    showModal('T·∫°o L·ªãch T·ªëi ∆Øu Th√†nh C√¥ng', `ƒê√£ t·∫°o v√† x·∫øp l·ªãch th√†nh c√¥ng ${finalSchedule.length} tr·∫≠n ƒë·∫•u. Vui l√≤ng ki·ªÉm tra tab "V√≤ng B·∫£ng" theo ch·∫ø ƒë·ªô "Theo S√¢n thi ƒë·∫•u".`);
}

/**
 * H√†m t·∫°o t·∫•t c·∫£ c√°c c·∫∑p ƒë·∫•u (All-Play-All)
 */
function generateAllMatches(teams, group) {
    const matches = [];
    for (let i = 0; i < teams.length; i++) {
        for (let j = i + 1; j < teams.length; j++) {
            matches.push({
                teamA: teams[i],
                teamB: teams[j],
                scoreA: null,
                scoreB: null,
                winner: null,
                loser: null,
                time: null, // S·∫Ω ƒë∆∞·ª£c x·∫øp l·ªãch sau
                court: null, // S·∫Ω ƒë∆∞·ª£c x·∫øp l·ªãch sau
                bang: group
            });
        }
    }
    return matches;
}


// --- C√¥ng c·ª• Import/Export CSV ---

/**
 * X·ª≠ l√Ω file CSV ƒë∆∞·ª£c upload
 */
function handleFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const csvContent = e.target.result;
            const matches = parseCSV(csvContent);
            
            if (matches.length > 0) {
                 // X√≥a l·ªãch c≈© tr∆∞·ªõc khi import
                state.matchesA = [];
                state.matchesB = [];
                
                // Ph√¢n lo·∫°i v√† g√°n index
                matches.forEach((m, i) => {
                    m.originalIndex = i;
                    if (m.bang === 'A') {
                        state.matchesA.push(m);
                    } else if (m.bang === 'B') {
                        state.matchesB.push(m);
                    }
                });

                renderMatchesView();
                tinhVaCapNhatXepHang();
                
                stateChanged = true;
                saveToGitHub();
                showModal('Import L·ªãch Th√†nh C√¥ng', `ƒê√£ nh·∫≠p th√†nh c√¥ng ${matches.length} tr·∫≠n ƒë·∫•u t·ª´ file CSV.`);
            } else {
                showModal('L·ªói Import', 'File CSV kh√¥ng ch·ª©a d·ªØ li·ªáu l·ªãch thi ƒë·∫•u h·ª£p l·ªá.');
            }
        } catch (error) {
            showModal('L·ªói Import', `L·ªói x·ª≠ l√Ω file CSV: ${error.message}`);
            console.error("L·ªói x·ª≠ l√Ω CSV:", error);
        }
    };
    reader.readAsText(file);
}

/**
 * Ph√¢n t√≠ch c√∫ ph√°p CSV th√†nh m·∫£ng tr·∫≠n ƒë·∫•u
 */
function parseCSV(csvContent) {
    const lines = csvContent.trim().split('\n');
    if (lines.length < 2) return [];

    const headers = lines[0].split(',').map(h => h.trim());
    const dataLines = lines.slice(1);
    const matches = [];

    dataLines.forEach(line => {
        const values = line.split(',');
        if (values.length !== headers.length) return; // B·ªè qua d√≤ng b·ªã l·ªói

        const match = {};
        headers.forEach((header, index) => {
            const value = values[index].trim();
            switch (header) {
                case 'scoreA':
                case 'scoreB':
                    match[header] = value === '' ? null : parseInt(value);
                    break;
                case 'originalIndex':
                    match[header] = parseInt(value);
                    break;
                case 'winner':
                case 'loser':
                    match[header] = value === '' ? null : value;
                    break;
                case 'time':
                case 'court':
                case 'bang':
                case 'teamA':
                case 'teamB':
                    match[header] = value;
                    break;
                default:
                    // B·ªè qua c√°c header kh√¥ng mong mu·ªën
                    break;
            }
        });

        // N·∫øu c√≥ ƒëi·ªÉm, t√≠nh winner/loser
        if (match.scoreA !== null && match.scoreB !== null && match.scoreA !== match.scoreB) {
            if (match.scoreA > match.scoreB) {
                match.winner = match.teamA;
                match.loser = match.teamB;
            } else {
                match.winner = match.teamB;
                match.loser = match.teamA;
            }
        }

        matches.push(match);
    });

    return matches;
}

/**
 * Export l·ªãch thi ƒë·∫•u ra file CSV
 */
function exportSchedule() {
    const allMatches = [...state.matchesA, ...state.matchesB];
    if (allMatches.length === 0) {
        showModal('Export L·ªãch', 'Kh√¥ng c√≥ tr·∫≠n ƒë·∫•u n√†o ƒë·ªÉ xu·∫•t ra CSV.');
        return;
    }

    const headers = ["teamA", "teamB", "time", "court", "bang", "scoreA", "scoreB", "winner", "loser"];
    let csvContent = headers.join(",") + "\n";

    allMatches.forEach(match => {
        const row = [
            match.teamA || '',
            match.teamB || '',
            match.time || '',
            match.court || '',
            match.bang || '',
            match.scoreA !== null ? match.scoreA : '',
            match.scoreB !== null ? match.scoreB : '',
            match.winner || '',
            match.loser || ''
        ];
        csvContent += row.join(",") + "\n";
    });

    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute("download", "lich_thi_dau_tkd.csv");
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    showModal('Export L·ªãch Th√†nh C√¥ng', 'ƒê√£ t·∫£i xu·ªëng file **lich_thi_dau_tkd.csv**.');
}

/**
 * ƒêi·ªÅn k·∫øt qu·∫£ t·ª± ƒë·ªông (11-X) cho t·∫•t c·∫£ c√°c tr·∫≠n ch∆∞a ƒë·∫•u.
 */
function autoFillScores() {
    let filledCount = 0;
    
    // V√≤ng b·∫£ng
    [state.matchesA, state.matchesB].forEach(matchArray => {
        matchArray.forEach(match => {
            if (!match.winner) {
                // ƒêi·ªÅn 11 - X (X l√† s·ªë ng·∫´u nhi√™n t·ª´ 5 ƒë·∫øn 9)
                const randomLossScore = Math.floor(Math.random() * 5) + 5; // 5, 6, 7, 8, 9
                
                // Ng·∫´u nhi√™n ƒë·ªôi th·∫Øng
                if (Math.random() < 0.5) { // Team A th·∫Øng
                    match.scoreA = 11;
                    match.scoreB = randomLossScore;
                } else { // Team B th·∫Øng
                    match.scoreA = randomLossScore;
                    match.scoreB = 11;
                }
                
                // T√≠nh l·∫°i winner/loser
                if (match.scoreA > match.scoreB) {
                    match.winner = match.teamA;
                    match.loser = match.teamB;
                } else {
                    match.winner = match.teamB;
                    match.loser = match.teamA;
                }
                
                filledCount++;
            }
        });
    });

    // B√°n k·∫øt v√† Chung k·∫øt (N·∫øu ƒë√£ l√™n l·ªãch)
    [...state.semifinals, state.final].forEach(match => {
        if (!match.winner && match.teamA !== 'Th·∫Øng SF1' && match.teamA !== 'Nh·∫•t A') {
            const randomLossScore = Math.floor(Math.random() * 5) + 5; 
            if (Math.random() < 0.5) {
                match.scoreA = 11;
                match.scoreB = randomLossScore;
            } else {
                match.scoreA = randomLossScore;
                match.scoreB = 11;
            }
            
            if (match.scoreA > match.scoreB) {
                match.winner = match.teamA;
                if (match.id === 'F') match.runnerUp = match.teamB;
                else match.loser = match.teamB;
            } else {
                match.winner = match.teamB;
                if (match.id === 'F') match.runnerUp = match.teamA;
                else match.loser = match.teamA;
            }
            filledCount++;
        }
    });

    if (filledCount > 0) {
        // Sau khi ƒëi·ªÅn, c·∫≠p nh·∫≠t l·∫°i m·ªçi th·ª©
        updateFinalsFromSemifinals();
        renderMatchesView(); 
        tinhVaCapNhatXepHang(); 
        renderFinals();
        
        stateChanged = true;
        saveToGitHub();
        showModal('ƒêi·ªÅn K·∫øt Qu·∫£ T·ª± ƒê·ªông Th√†nh C√¥ng', `ƒê√£ t·ª± ƒë·ªông ƒëi·ªÅn k·∫øt qu·∫£ cho ${filledCount} tr·∫≠n ƒë·∫•u ch∆∞a ho√†n th√†nh.`);
    } else {
        showModal('ƒêi·ªÅn K·∫øt Qu·∫£ T·ª± ƒê·ªông', 'Kh√¥ng c√≤n tr·∫≠n ƒë·∫•u n√†o ch∆∞a ho√†n th√†nh ƒë·ªÉ ƒëi·ªÅn k·∫øt qu·∫£ t·ª± ƒë·ªông.');
    }
}

/**
 * X√≥a to√†n b·ªô l·ªãch thi ƒë·∫•u v√† k·∫øt qu·∫£
 */
function clearAllSchedules() {
    if (confirm("B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën X√ìA TO√ÄN B·ªò l·ªãch thi ƒë·∫•u v√† k·∫øt qu·∫£ v√≤ng b·∫£ng/chung k·∫øt? (Danh s√°ch ƒë·ªôi v·∫´n ƒë∆∞·ª£c gi·ªØ l·∫°i)")) {
        state.matchesA = [];
        state.matchesB = [];
        state.tableA = [];
        state.tableB = [];
        
        // ƒê·∫£m b·∫£o c·∫≠p nh·∫≠t th·ªùi gian m·ªõi khi reset
        const SF1_TIME = '16:40';
        const SF2_TIME = '17:05';
        const FINAL_TIME = '17:30';
        const FINAL_COURT = 'S√¢n 3';
        
        state.semifinals = [
            { id: 'SF1', teamA: 'Nh·∫•t A', teamB: 'Nh√¨ A', scoreA: null, scoreB: null, time: SF1_TIME, court: FINAL_COURT, winner: null, loser: null },
            { id: 'SF2', teamA: 'Nh·∫•t B', teamB: 'Nh√¨ B', scoreA: null, scoreB: null, time: SF2_TIME, court: FINAL_COURT, winner: null, loser: null }
        ];
        state.final = { id: 'F', teamA: 'Th·∫Øng SF1', teamB: 'Th·∫Øng SF2', scoreA: null, scoreB: null, time: FINAL_TIME, court: FINAL_COURT, winner: null, runnerUp: null };

        renderMatchesView();
        renderFinals();
        renderFinalResults();
        renderOverview();
        
        stateChanged = true;
        saveToGitHub();
        showModal('Th√†nh C√¥ng', 'ƒê√£ x√≥a to√†n b·ªô l·ªãch thi ƒë·∫•u v√† k·∫øt qu·∫£.');
    }
}
</script>
</body>
</html>
