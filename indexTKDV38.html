<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TKD Championship 2025 — Quản lý giải Pickleball V39 GitHub (Sửa lỗi Nhập điểm & Đồng bộ Ranking)</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body { background:#f7f9fc; font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial; color:#222; padding:18px; }
    .tab-content { margin-top: 18px; }
    .logo { 
      width:64px; 
      height:64px; 
      object-fit:contain; 
      border-radius:8px; 
      border:1px solid #e6eefc; 
      padding:6px; 
      background:#fff; 
    }
    table th { background:#0d6efd; color:#fff; position:sticky; top:0; }
    .status { font-size:0.95rem; color:#555; }
    /* Responsive adjustment for match inputs */
    .match-score-cell input {
      width: 45px;
      text-align: center;
      padding: 0.1rem;
    }
    @media (max-width: 576px) {
      .match-score-cell input {
        width: 35px;
      }
    }
    .winner { font-weight: bold; color: green; }
    .loser { color: red; }
    .ranking-container { display: flex; flex-direction: column; gap: 20px; }
    @media (min-width: 768px) {
        .ranking-container { flex-direction: row; }
        .ranking-container > div { flex: 1; }
    }
  </style>
</head>
<body>
<div class="container">
  <div class="d-flex justify-content-between align-items-center mb-3">
    <div class="d-flex align-items-center gap-2">
      <img class="logo" src="data/logoTKD.png" alt="Logo TKD">
      <div>
        <h3 class="mb-0">TKD Championship 2025</h3>
        <div>Ngày thi đấu: 18/10/2025 (**V39**)</div>
      </div>
    </div>
    <div>
      <div id="autoSaveStatus" class="text-end status">Auto-save (30s): <span id="autoState" class="text-danger">Tắt</span></div>
      <div id="lastSaved" class="text-end status">Chưa lưu</div>
    </div>
  </div>

  <ul class="nav nav-tabs" id="mainTabs">
    <li class="nav-item"><button class="nav-link active" data-bs-toggle="tab" data-bs-target="#overview" onclick="renderOverview()">Tổng quan</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#matches" id="matchesTabButton" onclick="renderMatchesView()">Vòng Bảng</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#finals" onclick="renderFinals()">Vòng Chung Kết</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#results" onclick="tinhVaCapNhatXepHang(); renderFinalResults();">Kết quả Chung cuộc</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#config" id="configTabButton" onclick="renderConfig()">Cấu hình</button></li>
  </ul>

  <div class="tab-content">
    <div class="tab-pane fade show active p-3" id="overview">
        <div id="overviewContent">Đang tải dữ liệu...</div>
    </div>
    
    <div class="tab-pane fade p-3" id="matches">
      <div class="d-flex gap-2 mb-3 flex-wrap">
        <label for="viewMode" class="form-label mb-0 align-self-center text-nowrap">Chế độ xem:</label>
        <select id="viewMode" class="form-select form-select-sm w-auto" onchange="renderMatchesView()">
            <option value="table">Theo Bảng đấu</option>
            <option value="court" selected>Theo Sân thi đấu</option>
        </select>
        
        <button class="btn btn-sm btn-info ms-auto" onclick="document.getElementById('fileInput').click()">Import Lịch (CSV)</button>
        <input type="file" id="fileInput" accept=".csv" style="display: none;" onchange="handleFileSelect(event)">
        
        <button class="btn btn-sm btn-warning" onclick="exportSchedule()">Export Lịch (CSV)</button>
      </div>
      
      <div id="matchesViewContent">
        <h6 id="scheduleAHeader" class="mt-4">Bảng A (Nam - Nữ)</h6><div id="tableMatchesA">Chưa có lịch thi đấu.</div>
        
        <h6 class="mt-4">Bảng B (Nam)</h6><div id="tableMatchesB">Chưa có lịch thi đấu.</div>
      </div>

      <button class="btn btn-warning mt-4" onclick="scheduleFinalsAuto()">Lên lịch Vòng Chung kết (Tự động hóa)</button>
    </div>

    <div class="tab-pane fade p-3" id="finals">
        <div id="finalsContent">
            <h6 class="mt-4">Vòng Bán kết (SF1: 16:40, SF2: 17:05, Sân 3)</h6>
            <div id="semifinalMatches">Chưa có lịch thi đấu bán kết. Kết quả Vòng Bảng sẽ tự động cập nhật lịch.</div>

            <h6 class="mt-4">Trận Chung kết (17:30, Sân 3)</h6>
            <div id="finalMatch">Chưa có lịch thi đấu chung kết.</div>
        </div>
    </div>

    <div class="tab-pane fade p-3" id="results">
        <h5 class="mb-3">Bảng xếp hạng Vòng Bảng (Ưu tiên: W > Đối đầu > Hiệu số > Tổng điểm)</h5>
        <div id="rankingTables" class="ranking-container">
            </div>

        <hr class="my-4">

        <h5 class="mb-3">Danh hiệu Chung cuộc</h5>
        <p id="champion">Vô địch: Đang chờ kết quả...</p>
        <p id="runnerUp">Á quân: Đang chờ kết quả...</p>
        <p id="thirdPlace">Hạng Ba Đồng Hạng: Đang chờ kết quả...</p>
    </div>

    <div class="tab-pane fade p-3" id="config">
      <h5 class="mb-3">Công cụ Lập & Điền Lịch Thi đấu</h5>
      <div class="d-flex gap-2 mb-4 flex-wrap">
        <button class="btn btn-sm btn-primary" onclick="taoLichThiDauCungGio()">Tạo lịch thi đấu Tối ưu (Tự động)</button>
        <button class="btn btn-sm btn-secondary" onclick="taoLichCoDinh()">Tải lịch Mẫu (**CalendarTKD30**)</button>
        <button class="btn btn-sm btn-success" onclick="autoFillScores()">Điền kết quả Tự động (11 - X)</button>
        <button class="btn btn-sm btn-danger" onclick="clearAllSchedules()">Xóa Toàn bộ Lịch</button>
      </div>
      
      <hr>
      
      <h5 class="mt-4">🧹 Công cụ Xóa Kết quả Vòng Bảng</h5>
      <div class="d-flex gap-2 mb-4 flex-wrap">
          <button class="btn btn-sm btn-outline-danger" onclick="clearGroupScores('A')">Xóa Kết quả Bảng A</button>
          <button class="btn btn-sm btn-outline-danger" onclick="clearGroupScores('B')">Xóa Kết quả Bảng B</button>
          <button class="btn btn-sm btn-danger ms-auto" onclick="clearGroupScores('ALL')">Xóa Toàn bộ Vòng Bảng</button>
      </div>
      <div id="clearScoreStatus"></div>
      <hr>
      <h5 class="mt-4">⚙️ Cấu hình Sân thi đấu & Lịch Tối ưu</h5>
      <p class="text-muted small">Quản lý danh sách sân thi đấu. Sân được gán loại bảng đấu (A/B) để phục vụ chức năng tạo lịch Tối ưu.</p>
      <div class="d-flex gap-2 mb-3 flex-wrap">
          <button class="btn btn-sm btn-primary" onclick="openCourtModal()">+ Thêm Sân Mới</button>
          <button class="btn btn-sm btn-outline-info" onclick="loadDefaultCourtConfig()">Tải cấu hình Mặc định</button>
      </div>
      <div id="courtListContainer">
          </div>
      <div id="courtConfigStatus"></div>
      <hr>
      
      <h5 class="mt-4">🛠️ Cấu hình Tối ưu Lịch thi đấu</h5>
      <div class="row g-2 mb-4">
        <div class="col-md-6">
          <label for="preferredCourtType" class="form-label">Ưu tiên Sân nào cho trận đầu tiên (Chức năng Tạo lịch Tối ưu)?</label>
          <select id="preferredCourtType" class="form-select" onchange="updatePreferredCourtType()">
            <option value="mixed">Bảng A (Nam - Nữ) - Mặc định</option>
            <option value="male">Bảng B (Nam)</option>
          </select>
          <div class="form-text">Xác định loại sân sẽ được ưu tiên gán trận đấu đầu tiên trong thuật toán tạo lịch.</div>
        </div>
        <div class="col-md-6">
            <label class="form-label">Công cụ Xuất/Lưu Dữ liệu</label>
            <div class="d-flex gap-2">
                 <button class="btn btn-success" onclick="saveToGitHub(true)">Cập nhật lên GitHub ngay</button>
                 <button class="btn btn-secondary" onclick="exportDataToJson()">Xuất tất cả ra JSON</button>
            </div>
            <div class="form-text">Lưu trạng thái hiện tại (state.json) lên GitHub hoặc tải về máy.</div>
        </div>
      </div>
      <hr>
      <h5 class="mt-4">💾 Cấu hình Kết nối GitHub</h5>
      <p class="text-muted">Nhập thông tin kho lưu trữ GitHub để tự động lưu trữ dữ liệu giải đấu (Auto-save: 30s).</p>
      <div class="row g-2 mb-2">
        <div class="col-md-3"><input id="cfgOwner" class="form-control" placeholder="Owner (Ví dụ: user_name)"></div>
        <div class="col-md-3"><input id="cfgRepo" class="form-control" placeholder="Repo (Ví dụ: my-data-repo)"></div>
        <div class="col-md-3"><input id="cfgFolder" class="form-control" value="data"></div>
        <div class="col-md-3"><input id="cfgFile" class="form-control" value="state.json"></div>
      </div>
      <input id="cfgToken" type="password" class="form-control mb-2" placeholder="Dán GitHub Personal Access Token (PAT) tại đây">
      <div class="d-flex gap-2">
        <button class="btn btn-primary" onclick="saveConfig()">Lưu cấu hình Local</button>
        <button class="btn btn-success" onclick="checkConnection()">Kiểm tra & Tải Dữ liệu</button>
      </div>
      <div class="mt-2" id="configStatus"></div>
      
      <div class="card bg-light mt-4 shadow-sm">
        <div class="card-body">
            <h5 class="card-title text-info">🔑 Hướng dẫn lấy GitHub Token (PAT)</h5>
            <ol class="small mb-0">
                <li>Truy cập <a href="https://github.com/settings/tokens" target="_blank" class="text-info">GitHub Tokens Settings</a> (Bạn cần đăng nhập).</li>
                <li>Chọn **Generate new token** (hoặc **Generate new token (classic)** nếu bạn dùng tài khoản cũ).</li>
                <li>**Tên Token:** Đặt tên dễ nhớ (ví dụ: `TKDManager_AutoSave`).</li>
                <li>**Thời hạn:** Chọn tùy ý (nên chọn 90 ngày hoặc Tùy chỉnh).</li>
                <li>**Phạm vi (Scopes):** **BẮT BUỘC** tích chọn ô **`repo`** (cho phép truy cập vào kho lưu trữ).</li>
                <li>Nhấn **Generate token** và **SAO CHÉP** chuỗi Token vừa được tạo.</li>
                <li>Dán chuỗi Token đó vào ô "Dán GitHub Personal Access Token (PAT) tại đây" bên trên.</li>
            </ol>
            <p class="mt-2 mb-0 text-danger small">⚠️ **Lưu ý:** Token chỉ hiển thị **MỘT LẦN**. Hãy sao chép ngay lập tức và giữ bí mật. Nếu mất, bạn phải tạo lại Token mới.</p>
        </div>
      </div>
      </div>
  </div>
</div>

<div class="modal fade" id="courtModal" tabindex="-1" aria-labelledby="courtModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="courtModalLabel">Thêm/Sửa Cấu hình Sân</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="courtForm">
          <input type="hidden" id="courtIndex" value="">
          <div class="mb-3">
            <label for="courtName" class="form-label">Tên Sân</label>
            <input type="text" class="form-control" id="courtName" required>
          </div>
          <div class="mb-3">
            <label for="courtStartTime" class="form-label">Giờ Bắt Đầu (HH:mm)</label>
            <input type="time" class="form-control" id="courtStartTime" required>
          </div>
          <div class="mb-3">
            <label for="courtMaxDuration" class="form-label">Thời Lượng Tối Đa (Phút)</label>
            <input type="number" class="form-control" id="courtMaxDuration" min="1" required>
          </div>
          <div class="form-check mb-3">
            <input class="form-check-input" type="checkbox" id="courtIsMixed">
            <label class="form-check-label" for="courtIsMixed">
              Dành cho Bảng A (Nam - Nữ)
            </label>
            <div class="form-text">Nếu không chọn, sân sẽ dành cho Bảng B (Nam).</div>
          </div>
          <div id="courtFormStatus" class="mt-2"></div>
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Hủy</button>
        <button type="button" class="btn btn-primary" onclick="saveCourtChanges()">Lưu Thay Đổi</button>
      </div>
    </div>
  </div>
</div>
<div class="modal fade" id="customAlertModal" tabindex="-1" aria-labelledby="customAlertModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="customAlertModalLabel">Thông báo</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="customAlertModalBody">
        Nội dung thông báo
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Đóng</button>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script> 

<script>
// Dữ liệu lịch cố định từ file CalendarTKD30.csv (ĐÃ CẬP NHẬT theo yêu cầu)
const FIXED_SCHEDULE_CSV = `teamA,teamB,time,court,bang,scoreA,scoreB
Triều/Minh,Hiển/P.Hùng,14:00,Sân 1,B,,
Giang/Long,Hường/Đạt,14:00,Sân 2,A,,
Hậu/Dũng,Hạnh/Tiến,14:00,Sân 3,A,,
Huyền/Luân,Linh/M.Hùng,14:00,Sân 7,A,,
Tiệp/Thủy,Phương/Thanh,14:15,Sân 1,B,,
Tín/Khiêm,Ánh/Toàn,14:15,Sân 2,B,,
Hậu/Dũng,Hường/Đạt,14:15,Sân 3,A,,
Giang/Long,Huyền/Luân,14:15,Sân 7,A,,
Triều/Minh,Tín/Khiêm,14:30,Sân 1,B,,
Tiệp/Thủy,Hiển/P.Hùng,14:30,Sân 2,B,,
Hạnh/Tiến,Linh/M.Hùng,14:30,Sân 3,A,,
Phương/Thanh,Ánh/Toàn,14:30,Sân 7,B,,
Huyền/Luân,Hường/Đạt,14:45,Sân 2,A,,
Hạnh/Tiến,Giang/Long,14:45,Sân 3,A,,
Hậu/Dũng,Linh/M.Hùng,14:45,Sân 7,A,,
Tiệp/Thủy,Ánh/Toàn,15:00,Sân 2,B,,
Tín/Khiêm,Hiển/P.Hùng,15:00,Sân 3,B,,
Phương/Thanh,Triều/Minh,15:15,Sân 2,B,,
Giang/Long,Linh/M.Hùng,15:15,Sân 3,A,,
Hạnh/Tiến,Hường/Đạt,15:30,Sân 2,A,,
Hậu/Dũng,Huyền/Luân,15:30,Sân 3,A,,
Tiệp/Thủy,Tín/Khiêm,15:45,Sân 2,B,,
Phương/Thanh,Hiển/P.Hùng,15:45,Sân 3,B,,
Triều/Minh,Ánh/Toàn,16:00,Sân 2,B,,
Hậu/Dũng,Giang/Long,16:00,Sân 3,A,,
Hạnh/Tiến,Huyền/Luân,16:15,Sân 2,A,,
Linh/M.Hùng,Hường/Đạt,16:15,Sân 3,A,,
Tiệp/Thủy,Triều/Minh,16:30,Sân 2,B,,
Ánh/Toàn,Hiển/P.Hùng,16:30,Sân 3,B,,
Phương/Thanh,Tín/Khiêm,16:45,Sân 2,B,`;

// Biến state lưu trữ dữ liệu chính của ứng dụng.
let state = { 
  mixedTeams: [], // Sẽ được tải từ players.json
  maleTeams: [],  // Sẽ được tải từ players.json
  matchesA: [], 
  matchesB: [],
  tableA: [], // Bảng xếp hạng A (Sẽ được lưu và tải)
  tableB: [], // Bảng xếp hạng B (Sẽ được lưu và tải)
  
  // Court Configuration
  courts: [
    { name: 'Sân 1', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, 
    { name: 'Sân 2', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, 
    { name: 'Sân 3', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, 
    { name: 'Sân 4', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, 
    { name: 'Sân 5', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }, 
    { name: 'Sân 6', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }, 
    { name: 'Sân 7', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }, 
    { name: 'Sân 8', startTime: '14:00', maxDurationMinutes: 180, isMixed: false } 
  ],
  
  // LOGIC BÁN KẾT 
  semifinals: [
    { id: 'SF1', teamA: 'Nhất A', teamB: 'Nhì A', scoreA: null, scoreB: null, time: '16:40', court: 'Sân 3', winner: null, loser: null }, 
    { id: 'SF2', teamA: 'Nhất B', teamB: 'Nhì B', scoreA: null, scoreB: null, time: '17:05', court: 'Sân 3', winner: null, loser: null }  
  ],
  final: { id: 'F', teamA: 'Thắng SF1', teamB: 'Thắng SF2', scoreA: null, scoreB: null, time: '17:30', court: 'Sân 3', winner: null, runnerUp: null }, 
  config: { 
    preferredCourtType: 'mixed' 
  }
};

let stateChanged = false; // Biến cờ theo dõi thay đổi dữ liệu
let currentSha = null; // Biến lưu trữ SHA của file trên GitHub
let autoSaveInterval = null; // Biến lưu trữ ID của interval

// --- Custom Modal Function ---
function showModal(title, body) {
    document.getElementById('customAlertModalLabel').textContent = title;
    document.getElementById('customAlertModalBody').innerHTML = body;
    const modal = new bootstrap.Modal(document.getElementById('customAlertModal'));
    modal.show();
}

/**
 * Hàm chuyển đổi tab
 * @param {string} tabId - ID của tab cần chuyển (ví dụ: 'matches', 'overview')
 */
function switchTab(tabId) {
    const tabElement = document.querySelector(`#mainTabs button[data-bs-target="#${tabId}"]`);
    if (tabElement) {
        // Tắt tab đang active
        document.querySelectorAll('#mainTabs .nav-link').forEach(btn => btn.classList.remove('active'));
        document.querySelectorAll('.tab-content .tab-pane').forEach(pane => pane.classList.remove('show', 'active'));

        // Bật tab mới
        tabElement.classList.add('active');
        document.getElementById(tabId).classList.add('show', 'active');
        
        // Cập nhật view cho tab matches nếu chuyển đến
        if (tabId === 'matches') {
            renderMatchesView();
        }
    }
}

// --- Helper Functions cho Base64 ---
function b64EncodeUnicode(str) {
  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g,
    function(match, p1) {
      return String.fromCharCode('0x' + p1);
    }));
}

function b64DecodeUnicode(str) {
  return decodeURIComponent(atob(str).split('').map(function(c) {
    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
  }).join(''));
}

// --- GitHub API Functions ---

/**
 * Lấy SHA mới nhất của file trên GitHub.
 * @param {object} cfg - Cấu hình GitHub (owner, repo, folder, file, token)
 * @param {string} fileName - Tên file cần lấy SHA (mặc định là cfg.file)
 * @returns {Promise<{sha: string|null, content: string|null}>}
 */
async function fetchFileSha(cfg, fileName = cfg.file) {
    const filePath = `${cfg.folder}/${fileName}`;
    const apiUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}/contents/${filePath}`;
    
    try {
        const response = await fetch(apiUrl, {
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });
        
        if (response.ok) {
            const data = await response.json();
            if (fileName === cfg.file) {
                 currentSha = data.sha; // Chỉ lưu SHA của state.json
            }
            return { sha: data.sha, content: data.content };
        } else if (response.status === 404) {
            if (fileName === cfg.file) {
                 currentSha = null; 
            }
            return { sha: null, content: null };
        } else {
            // Lỗi khác (401, 403, 500...)
            throw new Error(`Lỗi HTTP ${response.status}: ${response.statusText}`);
        }
    } catch (error) {
        console.error(`Lỗi Fetch SHA (${fileName}):`, error);
        throw new Error(`Lỗi kết nối hoặc API: ${error.message}`);
    }
}

/**
 * Tải danh sách đội từ players.json
 */
async function loadPlayersFromGitHub(cfg) {
    const fileName = 'players.json';
    
    try {
        updateStatus('configStatus', 'info', 'Đang tải danh sách đội từ GitHub (players.json)...');
        const result = await fetchFileSha(cfg, fileName); 
        
        if (result.content) {
            const jsonString = b64DecodeUnicode(result.content);
            const loadedTeams = JSON.parse(jsonString);

            if (Array.isArray(loadedTeams.mixedTeams) && Array.isArray(loadedTeams.maleTeams)) {
                state.mixedTeams = loadedTeams.mixedTeams;
                state.maleTeams = loadedTeams.maleTeams;
                updateStatus('configStatus', 'success', `Tải danh sách đội thành công (${state.mixedTeams.length + state.maleTeams.length} đội).`);
                return true;
            } else {
                throw new Error("File players.json không đúng định dạng (thiếu mixedTeams/maleTeams).");
            }
        } else {
            updateStatus('configStatus', 'warning', 'Không tìm thấy file players.json. Dùng danh sách đội khởi tạo (trống).');
            return false;
        }
    } catch (error) {
        console.error("Lỗi khi tải players.json:", error);
        updateStatus('configStatus', 'danger', `Lỗi tải danh sách đội: ${error.message}`);
        return false;
    }
}

/**
 * Tải trạng thái giải đấu (state.json) từ GitHub.
 */
async function loadFromGitHub() {
    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) {
         updateStatus('configStatus', 'warning', 'Thiếu thông tin kết nối GitHub. Vui lòng nhập Token/Repo.');
         return;
    }

    // 1. Load Teams (danh sách đội)
    await loadPlayersFromGitHub(cfg); 

    // 2. Load App State (state.json)
    try {
        updateStatus('configStatus', 'info', 'Đang tải trạng thái giải đấu từ GitHub (state.json)...');
        // fetchFileSha sẽ tự động cập nhật currentSha
        const result = await fetchFileSha(cfg, cfg.file); 
        
        if (result.content) {
            const jsonString = b64DecodeUnicode(result.content);
            const loadedState = JSON.parse(jsonString);

            // Ghi đè các giá trị khác ngoài teams (teams đã được load từ players.json)
            state.matchesA = loadedState.matchesA || [];
            state.matchesB = loadedState.matchesB || [];
            
            // NEW: Tải bảng xếp hạng nếu có 
            state.tableA = loadedState.tableA || []; 
            state.tableB = loadedState.tableB || [];
            
            if (loadedState.courts) {
                state.courts = loadedState.courts;
            }
            
            // Cấu trúc mặc định mới cho bán kết/chung kết
            const defaultSF1 = { teamA: 'Nhất A', teamB: 'Nhì A', court: 'Sân 3', time: '16:40' };
            const defaultSF2 = { teamA: 'Nhất B', teamB: 'Nhì B', court: 'Sân 3', time: '17:05' };
            const defaultFinal = { teamA: 'Thắng SF1', teamB: 'Thắng SF2', court: 'Sân 3', time: '17:30' };

            // Logic tải cho semifinals/final (giữ lại kết quả nếu đã có, reset đội nếu đội vòng bảng thay đổi)
            if (loadedState.semifinals && loadedState.semifinals.length === 2) {
                 // Nếu đã có đội thực tế được gán (ví dụ: Team X), giữ nguyên 
                state.semifinals = loadedState.semifinals;
                // Nếu là trạng thái rỗng default (Nhất A vs Nhì A), cập nhật lại thời gian và sân theo V24
                state.semifinals.forEach((sf, index) => {
                     if (sf.teamA === 'Nhất A' || sf.teamA === 'Nhất B') {
                        sf.court = defaultSF1.court;
                        sf.time = index === 0 ? defaultSF1.time : defaultSF2.time;
                    }
                });
            } else {
                 // Dùng default V24
                 state.semifinals = [
                     { id: 'SF1', teamA: 'Nhất A', teamB: 'Nhì A', scoreA: null, scoreB: null, time: defaultSF1.time, court: defaultSF1.court, winner: null, loser: null },
                     { id: 'SF2', teamA: 'Nhất B', teamB: 'Nhì B', scoreA: null, scoreB: null, time: defaultSF2.time, court: defaultSF2.court, winner: null, loser: null }
                 ];
            }
            
            state.final = loadedState.final || state.final;
            if (!state.final.winner) {
                state.final.court = defaultFinal.court;
                state.final.time = defaultFinal.time;
            }
            
            updateStatus('configStatus', 'success', `Tải trạng thái giải đấu thành công từ: ${cfg.owner}/${cfg.repo}/${cfg.folder}/${cfg.file}`);
            document.getElementById('lastSaved').textContent = `Lần tải: ${new Date().toLocaleTimeString('vi-VN')}`;
        } else {
             // File state.json không tồn tại (404)
            updateStatus('configStatus', 'warning', 'File trạng thái (state.json) chưa tồn tại. Vui lòng nhấn Lưu hoặc Tự động lưu để tạo file.');
        }
        
        // Luôn cập nhật giao diện sau khi tải xong teams/state (hoặc dùng mặc định)
        tinhVaCapNhatXepHang(); 
        renderMatchesView(); 
        renderFinals();
        renderFinalResults();
        renderOverview();
        startAutoSave();

    } catch (error) {
        updateStatus('configStatus', 'danger', `Lỗi tải trạng thái giải đấu: ${error.message}. Vui lòng kiểm tra lại Token/Repo.`);
        console.error("Lỗi khi tải trạng thái giải đấu từ GitHub:", error);
    }
}

/**
 * Lưu trạng thái giải đấu (state.json) lên GitHub.
 * @param {boolean} force - Bắt buộc lưu ngay cả khi stateChanged là false.
 */
async function saveToGitHub(force = false) {
    // Bỏ qua nếu không có thay đổi và không ép buộc lưu
    if (!stateChanged && !force) return;
    
    // **CHECKPOINT:** Tính lại bảng xếp hạng trước khi lưu (đảm bảo dữ liệu ranking là mới nhất)
    tinhVaCapNhatXepHang();

    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) {
        console.warn("Không thể tự động lưu: Thiếu cấu hình GitHub.");
        document.getElementById('autoState').className = 'text-warning';
        document.getElementById('autoState').textContent = 'Tạm dừng (Thiếu Config)';
        return;
    }

    document.getElementById('autoState').className = 'text-info';
    document.getElementById('autoState').textContent = 'Đang lưu...';
    if (force) {
         updateStatus('configStatus', 'info', 'Đang cập nhật dữ liệu lên GitHub...');
    }


    const apiUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}/contents/${cfg.folder}/${cfg.file}`;
    
    // Chỉ lưu các trường cần thiết, bao gồm cả bảng xếp hạng (tableA, tableB)
    const stateToSave = {
        mixedTeams: state.mixedTeams,
        maleTeams: state.maleTeams,
        matchesA: state.matchesA,
        matchesB: state.matchesB,
        courts: state.courts,
        semifinals: state.semifinals,
        final: state.final,
        // **BẢNG XẾP HẠNG VÒNG BẢNG ĐÃ TÍNH TOÁN**
        tableA: state.tableA,
        tableB: state.tableB 
    };
    const content = b64EncodeUnicode(JSON.stringify(stateToSave));
    
    try {
        // Luôn fetch SHA mới nhất trước khi cố gắng lưu
        const result = await fetchFileSha(cfg, cfg.file); // Lấy SHA của state.json
        const sha = result.sha; 
        
        const payload = {
            message: `${force ? '[Manual-save]' : '[Auto-save]'} Cập nhật trạng thái giải đấu TKD lúc ${new Date().toLocaleString('vi-VN')}`,
            content: content
        };
        
        // Thêm SHA để cập nhật, nếu không có SHA sẽ tạo mới
        if (sha) {
             payload.sha = sha;
        }

        const response = await fetch(apiUrl, {
            method: 'PUT',
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Content-Type': 'application/json',
                'Accept': 'application/vnd.github.v3+json'
            },
            body: JSON.stringify(payload)
        });

        if (response.ok) {
            const data = await response.json();
            currentSha = data.content.sha;
            stateChanged = false;
            document.getElementById('lastSaved').textContent = `Lần lưu: ${new Date().toLocaleTimeString('vi-VN')}`;
            document.getElementById('autoState').className = 'text-success';
            document.getElementById('autoState').textContent = 'Đã Lưu';
            if (force) {
                 updateStatus('configStatus', 'success', `Cập nhật dữ liệu lên GitHub thành công lúc ${new Date().toLocaleTimeString('vi-VN')}.`);
            }
        } else {
            // Xử lý lỗi 409 Conflict
            if (response.status === 409) {
                console.warn("Lỗi 409 Conflict: Dữ liệu đã thay đổi trên GitHub. Đang cố gắng lấy SHA mới.");
                
                await fetchFileSha(cfg, cfg.file); 
                
                document.getElementById('autoState').className = 'text-warning';
                document.getElementById('autoState').textContent = 'Conflict. Sẽ thử lưu lại sau 30s.';
                if (force) {
                     updateStatus('configStatus', 'warning', `Lỗi Conflict (Dữ liệu đã thay đổi trên GitHub). Vui lòng thử lại sau 30s.`);
                }
            } else {
                throw new Error(`Lỗi HTTP: ${response.status} - ${response.statusText}`);
            }
        }
    } catch (error) {
        console.error("Lỗi khi lưu lên GitHub:", error);
        document.getElementById('autoState').className = 'text-danger';
        document.getElementById('autoState').textContent = 'Lỗi Lưu';
        if (force) {
             updateStatus('configStatus', 'danger', `Lỗi cập nhật lên GitHub: ${error.message}.`);
        }
    }
}

/**
 * Kiểm tra kết nối và Tải dữ liệu
 */
async function checkConnection() {
    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) {
        updateStatus('configStatus', 'warning', 'Vui lòng nhập đầy đủ Owner, Repo và Token.');
        return;
    }

    try {
        updateStatus('configStatus', 'info', 'Đang kiểm tra kết nối tới kho lưu trữ...');
        
        const repoCheckUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}`;
        const repoResponse = await fetch(repoCheckUrl, {
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });

        if (!repoResponse.ok) {
            throw new Error(`Lỗi truy cập kho lưu trữ. Mã: ${repoResponse.status}. (Kiểm tra Token/Repo/Owner)`);
        }

        updateStatus('configStatus', 'success', '✅ Kết nối GitHub thành công! Đang tiến hành tải dữ liệu...');
        await loadFromGitHub();

    } catch (error) {
        updateStatus('configStatus', 'danger', `❌ Kiểm tra kết nối thất bại: ${error.message}.`);
        console.error("Lỗi kiểm tra kết nối:", error);
    }
}

/**
 * Hàm Khởi động chức năng Auto-save
 */
function startAutoSave() {
    if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
    }
    document.getElementById('autoState').className = 'text-success';
    document.getElementById('autoState').textContent = 'Đang chạy';
    // Thiết lập interval 30 giây (30000ms)
    autoSaveInterval = setInterval(saveToGitHub, 30000); 
}

// --- Cấu hình & Khởi tạo ---
/**
 * Lưu cấu hình kết nối GitHub và các cấu hình khác vào LocalStorage.
 */
function saveConfig() {
    state.config.owner = document.getElementById('cfgOwner').value.trim();
    state.config.repo = document.getElementById('cfgRepo').value.trim();
    state.config.folder = document.getElementById('cfgFolder').value.trim();
    state.config.file = document.getElementById('cfgFile').value.trim();
    state.config.token = document.getElementById('cfgToken').value.trim();

    // Lưu tất cả cấu hình vào LocalStorage
    localStorage.setItem('tkdConfig', JSON.stringify(state.config));
    
    // Lưu cấu hình sân
    localStorage.setItem('tkdCourts', JSON.stringify(state.courts));

    updateStatus('configStatus', 'success', 'Đã lưu cấu hình kết nối GitHub vào bộ nhớ cục bộ (Local Storage).');
    
    // Khởi động lại auto-save nếu cấu hình hợp lệ
    if (state.config.owner && state.config.repo && state.config.token) {
        startAutoSave();
    }
}

/**
 * Tải cấu hình từ LocalStorage.
 */
function loadConfig() {
    const savedConfig = localStorage.getItem('tkdConfig');
    if (savedConfig) {
        state.config = JSON.parse(savedConfig);
        document.getElementById('cfgOwner').value = state.config.owner || '';
        document.getElementById('cfgRepo').value = state.config.repo || '';
        document.getElementById('cfgFolder').value = state.config.folder || 'data';
        document.getElementById('cfgFile').value = state.config.file || 'state.json';
        document.getElementById('cfgToken').value = state.config.token || '';
        
        // Cập nhật UI cho preferredCourtType
        const select = document.getElementById('preferredCourtType');
        if (select) {
            select.value = state.config.preferredCourtType || 'mixed';
        }
    }
    
    // Tải cấu hình sân
    const savedCourts = localStorage.getItem('tkdCourts');
    if (savedCourts) {
        state.courts = JSON.parse(savedCourts);
    }
}

/**
 * Cập nhật cấu hình ưu tiên sân cho tính năng Tạo lịch Tối ưu và lưu vào LocalStorage.
 */
function updatePreferredCourtType() {
    const select = document.getElementById('preferredCourtType');
    if (select) {
        state.config.preferredCourtType = select.value;
        saveConfig();
        updateStatus('configStatus', 'success', `Đã cập nhật ưu tiên sân thành: ${select.options[select.selectedIndex].text}.`);
    }
}

/**
 * Cập nhật trạng thái thông báo.
 * @param {string} elementId - ID của div hiển thị trạng thái
 * @param {string} type - loại alert (success, danger, info, warning)
 * @param {string} message - Nội dung thông báo
 */
function updateStatus(elementId, type, message) {
    const statusElement = document.getElementById(elementId);
    if (statusElement) {
        statusElement.className = `alert alert-${type} mt-2`;
        statusElement.textContent = message;
        // Tự động xóa thông báo sau 5 giây (trừ configStatus)
        if (elementId !== 'configStatus') {
            setTimeout(() => {
                statusElement.innerHTML = '';
                statusElement.className = '';
            }, 5000);
        }
    }
}

// --- Logic Điểm số & Xếp hạng Vòng Bảng ---

// === START FIX V39: Hàm updateScore đã được tối ưu hóa ===
/**
 * Cập nhật điểm số trận đấu Vòng Bảng và kích hoạt tính toán lại Bảng xếp hạng.
 * @param {string} group - Tên bảng đấu ('A' hoặc 'B').
 * @param {number} index - Chỉ mục (index) của trận đấu trong mảng.
 */
function updateScore(group, index) {
    // 1. Xác định mảng trận đấu
    const matchArray = group === 'A' ? state.matchesA : state.matchesB;
    const match = matchArray[index];

    // 2. Đọc điểm từ input
    const inputA = document.getElementById(`score-${group}-${index}-A`);
    const inputB = document.getElementById(`score-${group}-${index}-B`);

    // 3. FIX CHUYỂN ĐỔI: Chuyển đổi sang số nguyên (base 10) và xử lý input rỗng
    let scoreA = inputA.value === '' ? null : parseInt(inputA.value, 10);
    let scoreB = inputB.value === '' ? null : parseInt(inputB.value, 10);
    
    // FIX KIỂM TRA HỢP LỆ: Đặt lại là null nếu giá trị nhập vào không phải là số (NaN)
    if (isNaN(scoreA)) scoreA = null;
    if (isNaN(scoreB)) scoreB = null;

    // 4. Cập nhật state
    match.scoreA = scoreA;
    match.scoreB = scoreB;
    match.winner = null; // Reset kết quả trước
    match.loser = null;

    // 5. Xác định người thắng cuộc chỉ khi CÓ ĐỦ VÀ HỢP LỆ cả hai điểm số
    if (scoreA !== null && scoreB !== null) {
        if (scoreA > scoreB) {
            match.winner = match.teamA;
            match.loser = match.teamB;
        } else if (scoreB > scoreA) {
            match.winner = match.teamB;
            match.loser = match.teamA;
        }
        // Nếu hòa: match.winner và match.loser vẫn là null, coi như không có kết quả hợp lệ (đúng theo luật không hòa)
    }

    // 6. Kích hoạt đồng bộ hóa
    stateChanged = true;
    
    // BƯỚC FIX QUAN TRỌNG: Bắt buộc tính toán lại bảng xếp hạng (fix lỗi không update ranking)
    tinhVaCapNhatXepHang(); 

    // 7. Cập nhật giao diện
    renderMatchesView(); // Cập nhật màu thắng/thua trong tab Vòng Bảng
    renderOverview();    // Cập nhật tab Tổng quan (bao gồm cả Bảng xếp hạng)
}

// === END FIX V39 ===


/**
 * Cập nhật điểm số trận đấu Vòng Chung Kết và kích hoạt cập nhật Chung kết.
 * @param {string} matchType - 'semifinal' hoặc 'final'
 * @param {number} index - Chỉ mục (index) của trận đấu trong mảng (0 hoặc 1 cho bán kết)
 */
function updateFinalScore(matchType, index) {
    let match;
    let winnerKey = 'winner';
    let loserKey = 'loser';

    if (matchType === 'semifinal') {
        match = state.semifinals[index];
    } else if (matchType === 'final') {
        match = state.final;
        loserKey = 'runnerUp'; // Á quân thay vì Loser
    } else {
        return;
    }

    // Đọc điểm từ input và chuyển đổi sang số nguyên.
    const inputA = document.getElementById(`score-${match.id}-A`);
    const inputB = document.getElementById(`score-${match.id}-B`);
    
    let scoreA = inputA.value === '' ? null : parseInt(inputA.value, 10);
    let scoreB = inputB.value === '' ? null : parseInt(inputB.value, 10);
    
    // Kiểm tra NaN
    if (isNaN(scoreA)) scoreA = null;
    if (isNaN(scoreB)) scoreB = null;


    match.scoreA = scoreA;
    match.scoreB = scoreB;
    match[winnerKey] = null; 
    match[loserKey] = null;

    // Xác định người thắng cuộc
    if (scoreA !== null && scoreB !== null) {
        if (scoreA > scoreB) {
            match[winnerKey] = match.teamA;
            match[loserKey] = match.teamB;
        } else if (scoreB > scoreA) {
            match[winnerKey] = match.teamB;
            match[loserKey] = match.teamA;
        }
    }

    // Luôn đặt cờ thay đổi
    stateChanged = true;
    
    // Cập nhật đội vào vòng Chung kết/Kết thúc giải đấu
    capNhatDoiVaoVongChungKet(state.tableA, state.tableB);
    
    // Cập nhật giao diện
    renderFinals(); 
    renderOverview();
    renderFinalResults(); 
}

/**
 * Tính toán lại toàn bộ bảng xếp hạng của cả hai bảng đấu (A và B).
 * Đây là hàm trung tâm được gọi sau mỗi lần nhập điểm vòng bảng.
 */
function tinhVaCapNhatXepHang() {
    // 1. Tính toán điểm số và hiệu số cho từng đội
    function calculateTeamStats(teams, matches) {
        const stats = teams.map(teamName => ({
            name: teamName,
            W: 0, // Thắng
            L: 0, // Thua
            PTS: 0, // Tổng điểm
            GF: 0, // Điểm thắng (Goals For)
            GA: 0, // Điểm thua (Goals Against)
            GD: 0, // Hiệu số (Goals Difference)
        }));

        matches.forEach(match => {
            if (match.scoreA !== null && match.scoreB !== null) {
                const teamAStat = stats.find(s => s.name === match.teamA);
                const teamBStat = stats.find(s => s.name === match.teamB);

                if (teamAStat && teamBStat) {
                    teamAStat.GF += match.scoreA;
                    teamAStat.GA += match.scoreB;
                    teamBStat.GF += match.scoreB;
                    teamBStat.GA += match.scoreA;

                    if (match.winner === match.teamA) {
                        teamAStat.W += 1;
                        teamAStat.PTS += 3; // 3 điểm cho trận thắng
                        teamBStat.L += 1;
                    } else if (match.winner === match.teamB) {
                        teamBStat.W += 1;
                        teamBStat.PTS += 3;
                        teamAStat.L += 1;
                    }
                    // Trường hợp hòa (không có winner/loser) không cộng điểm
                }
            }
        });
        
        // Tính toán Hiệu số
        stats.forEach(s => {
            s.GD = s.GF - s.GA;
        });

        return stats;
    }

    // 2. Cập nhật và sắp xếp bảng A
    let statsA = calculateTeamStats(state.mixedTeams, state.matchesA);
    statsA.sort((a, b) => {
        // 1. Ưu tiên: Số trận thắng (W)
        if (b.W !== a.W) return b.W - a.W;
        
        // 2. Ưu tiên: Đối đầu trực tiếp (Head-to-head) - Chỉ áp dụng nếu có 2 đội bằng W
        const rankingA = checkHeadToHead(statsA, state.matchesA);
        const rankA = rankingA.findIndex(team => team.name === a.name);
        const rankB = rankingA.findIndex(team => team.name === b.name);
        
        if (rankingA.length > 0 && rankA !== rankB) {
            // Nếu Đối đầu đã xác định được thứ hạng (rankA, rankB khác nhau)
            // Lấy kết quả từ hàm checkHeadToHead để sắp xếp
            // Nếu a xếp trước b trong rankingA thì a - b < 0 (a lên trước)
            return rankA - rankB; 
        }

        // 3. Ưu tiên: Hiệu số (GD)
        if (b.GD !== a.GD) return b.GD - a.GD;

        // 4. Ưu tiên: Tổng điểm thắng (GF)
        if (b.GF !== a.GF) return b.GF - a.GF;

        // 5. Ưu tiên: Tổng điểm (PTS) (Thực tế không cần thiết nếu đã có W)
        if (b.PTS !== a.PTS) return b.PTS - a.PTS;
        
        // 6. Ngẫu nhiên (Nếu tất cả chỉ số bằng nhau)
        return 0;
    });
    state.tableA = statsA;

    // 3. Cập nhật và sắp xếp bảng B
    let statsB = calculateTeamStats(state.maleTeams, state.matchesB);
    statsB.sort((a, b) => {
        // 1. Ưu tiên: Số trận thắng (W)
        if (b.W !== a.W) return b.W - a.W;
        
        // 2. Ưu tiên: Đối đầu trực tiếp (Head-to-head)
        const rankingB = checkHeadToHead(statsB, state.matchesB);
        const rankA = rankingB.findIndex(team => team.name === a.name);
        const rankB = rankingB.findIndex(team => team.name === b.name);
        
        if (rankingB.length > 0 && rankA !== rankB) {
            return rankA - rankB; 
        }

        // 3. Ưu tiên: Hiệu số (GD)
        if (b.GD !== a.GD) return b.GD - a.GD;

        // 4. Ưu tiên: Tổng điểm thắng (GF)
        if (b.GF !== a.GF) return b.GF - a.GF;

        // 5. Ưu tiên: Tổng điểm (PTS)
        if (b.PTS !== a.PTS) return b.PTS - a.PTS;
        
        // 6. Ngẫu nhiên
        return 0;
    });
    state.tableB = statsB;
    
    // BƯỚC ĐỒNG BỘ QUAN TRỌNG
    // Tự động điền đội vào Vòng Chung kết (Nếu Vòng Bảng đủ điều kiện)
    capNhatDoiVaoVongChungKet(state.tableA, state.tableB); 
    
    // Cập nhật tab Kết quả Chung cuộc
    renderRankingTables(); 
}

/**
 * Logic kiểm tra đối đầu trực tiếp giữa các đội có cùng chỉ số phụ (W).
 * Chỉ trả về thứ tự xếp hạng của nhóm đội bằng điểm (W) đó.
 * @param {Array<object>} stats - Mảng thống kê của đội trong bảng đấu.
 * @param {Array<object>} matches - Mảng trận đấu của bảng đấu đó.
 * @returns {Array<object>} Mảng xếp hạng đã tính toán bằng luật Đối đầu.
 */
function checkHeadToHead(stats, matches) {
    // 1. Tìm nhóm đội bằng chỉ số quan trọng nhất (W)
    const teamsByW = {};
    stats.forEach(s => {
        if (!teamsByW[s.W]) {
            teamsByW[s.W] = [];
        }
        teamsByW[s.W].push(s);
    });

    let finalRanking = [];
    
    // Duyệt qua từng nhóm đội bằng W (từ cao đến thấp)
    Object.keys(teamsByW).sort((a, b) => b - a).forEach(w => {
        const group = teamsByW[w];
        
        if (group.length <= 1) {
            finalRanking.push(...group);
            return;
        }

        // 2. Nếu có 2 đội trở lên bằng W, tính Đối đầu
        const teamNames = group.map(s => s.name);
        let headToHeadStats = group.map(s => ({ 
            name: s.name, 
            W: 0, 
            GD: 0, 
            GF: 0,
            originalW: s.W // Giữ lại W gốc để xếp sau cùng nếu đối đầu không giải quyết được
        }));

        // Tính kết quả Đối đầu giữa các đội trong nhóm này
        matches.forEach(match => {
            const teamAInGroup = teamNames.includes(match.teamA);
            const teamBInGroup = teamNames.includes(match.teamB);

            // Nếu trận đấu diễn ra giữa hai đội trong nhóm đang xét
            if (teamAInGroup && teamBInGroup && match.scoreA !== null && match.scoreB !== null) {
                const statA = headToHeadStats.find(s => s.name === match.teamA);
                const statB = headToHeadStats.find(s => s.name === match.teamB);
                
                if (statA && statB) {
                    statA.GF += match.scoreA;
                    statA.GD += match.scoreA - match.scoreB;
                    statB.GF += match.scoreB;
                    statB.GD += match.scoreB - match.scoreA;

                    if (match.winner === match.teamA) {
                        statA.W += 1;
                    } else if (match.winner === match.teamB) {
                        statB.W += 1;
                    }
                }
            }
        });
        
        // Sắp xếp lại nhóm này theo luật Đối đầu: W > GD > GF
        group.sort((a, b) => {
            const h2hA = headToHeadStats.find(s => s.name === a.name);
            const h2hB = headToHeadStats.find(s => s.name === b.name);

            if (!h2hA || !h2hB) return 0;

            // 1. Đối đầu: Số trận thắng (W)
            if (b.W !== a.W) return b.W - a.W;
            
            // 2. Đối đầu: Hiệu số (GD)
            if (h2hB.GD !== h2hA.GD) return h2hB.GD - h2hA.GD;

            // 3. Đối đầu: Tổng điểm thắng (GF)
            if (h2hB.GF !== h2hA.GF) return h2hB.GF - h2hA.GF;
            
            // Nếu đối đầu vẫn hòa, quay lại dùng chỉ số phụ của toàn giải (GD toàn giải)
            if (b.GD !== a.GD) return b.GD - a.GD;
            
            // Sau đó là GF toàn giải
            if (b.GF !== a.GF) return b.GF - a.GF;

            return 0;
        });

        finalRanking.push(...group);
    });

    return finalRanking;
}

/**
 * Tự động cập nhật tên đội vào Vòng Bán kết (SF1, SF2) và Chung kết (F)
 */
function capNhatDoiVaoVongChungKet(tableA, tableB) {
    
    // 1. Kiểm tra điều kiện Vòng Bảng
    const totalMatchesA = state.mixedTeams.length * (state.mixedTeams.length - 1) / 2;
    const completedA = state.matchesA.filter(m => m.scoreA !== null && m.scoreB !== null).length;
    const isGroupACompleted = totalMatchesA > 0 && completedA === totalMatchesA;

    const totalMatchesB = state.maleTeams.length * (state.maleTeams.length - 1) / 2;
    const completedB = state.matchesB.filter(m => m.scoreA !== null && m.scoreB !== null).length;
    const isGroupBCompleted = totalMatchesB > 0 && completedB === totalMatchesB;
    
    const isKnockoutStarted = state.semifinals.some(sf => sf.scoreA !== null || sf.scoreB !== null);
    
    // 2. Cập nhật Vòng Bán kết (Chỉ khi Vòng Bảng hoàn thành và Bán kết chưa bắt đầu)
    if (isGroupACompleted && isGroupBCompleted && !isKnockoutStarted) {
        const team1A = tableA[0] ? tableA[0].name : 'Nhất A';
        const team2A = tableA[1] ? tableA[1].name : 'Nhì A';
        const team1B = tableB[0] ? tableB[0].name : 'Nhất B';
        const team2B = tableB[1] ? tableB[1].name : 'Nhì B';

        // SF1: Nhất A vs Nhì B (Index 0)
        state.semifinals[0].teamA = team1A;
        state.semifinals[0].teamB = team2B;
        
        // SF2: Nhất B vs Nhì A (Index 1)
        state.semifinals[1].teamA = team1B;
        state.semifinals[1].teamB = team2A;
    } else if (!isKnockoutStarted) {
        // Reset về giá trị mặc định nếu chưa hoàn thành Vòng Bảng và chưa đấu Bán kết
        state.semifinals[0].teamA = 'Nhất A';
        state.semifinals[0].teamB = 'Nhì B';
        state.semifinals[1].teamA = 'Nhất B';
        state.semifinals[1].teamB = 'Nhì A';
    }


    // 3. Cập nhật Trận Chung kết (Dựa trên kết quả Bán kết)
    const SF1Winner = state.semifinals[0].winner;
    const SF2Winner = state.semifinals[1].winner;
    
    // Cập nhật đội vào Chung kết
    if (SF1Winner) {
        state.final.teamA = SF1Winner;
    } else {
        state.final.teamA = 'Thắng SF1';
    }
    
    if (SF2Winner) {
        state.final.teamB = SF2Winner;
    } else {
        state.final.teamB = 'Thắng SF2';
    }
    
    // Cập nhật Hạng Ba (2 đội thua Bán kết)
    if (state.semifinals.every(sf => sf.loser)) {
        state.thirdPlaceTeams = [state.semifinals[0].loser, state.semifinals[1].loser];
    } else {
        state.thirdPlaceTeams = [];
    }
}

// --- Logic Tạo Lịch và Mô phỏng ---

/**
 * Tải lịch cố định từ biến FIXED_SCHEDULE_CSV (CalendarTKD30)
 */
function taoLichCoDinh() {
    if (!confirm("Bạn có chắc chắn muốn Tải lịch Mẫu (CalendarTKD30)? Lịch thi đấu hiện tại sẽ bị ghi đè.")) return;
    
    state.matchesA = [];
    state.matchesB = [];
    
    // Parse CSV
    const lines = FIXED_SCHEDULE_CSV.trim().split('\n');
    const headers = lines[0].split(',');
    
    for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',');
        const match = {};
        headers.forEach((header, index) => {
            match[header.trim()] = values[index] ? values[index].trim() : null;
        });

        const newMatch = {
            id: `M${i}`,
            time: match.time,
            court: match.court,
            teamA: match.teamA,
            teamB: match.teamB,
            scoreA: match.scoreA !== null ? parseInt(match.scoreA, 10) : null,
            scoreB: match.scoreB !== null ? parseInt(match.scoreB, 10) : null,
            winner: null,
            loser: null
        };
        
        if (match.bang === 'A') {
            state.matchesA.push(newMatch);
        } else if (match.bang === 'B') {
            state.matchesB.push(newMatch);
        }
    }
    
    // Khởi tạo lại kết quả winner/loser dựa trên điểm số (nếu có)
    [...state.matchesA, ...state.matchesB].forEach(match => {
         if (match.scoreA !== null && match.scoreB !== null) {
             if (match.scoreA > match.scoreB) {
                 match.winner = match.teamA;
                 match.loser = match.teamB;
             } else if (match.scoreB > match.scoreA) {
                 match.winner = match.teamB;
                 match.loser = match.teamA;
             }
         }
    });

    stateChanged = true;
    tinhVaCapNhatXepHang();
    renderMatchesView();
    renderOverview();
    showModal('Tải lịch Mẫu', 'Đã tải lịch thi đấu mẫu CalendarTKD30 thành công.');
}

/**
 * Xóa toàn bộ lịch thi đấu (Vòng Bảng, Bán kết, Chung kết)
 */
function clearAllSchedules() {
    if (!confirm("Bạn có chắc chắn muốn XÓA TOÀN BỘ lịch thi đấu và kết quả? Hành động này không thể hoàn tác.")) return;

    // Reset lịch vòng bảng
    state.matchesA = [];
    state.matchesB = [];

    // Reset lịch và kết quả chung kết
    state.semifinals.forEach(sf => {
        sf.teamA = 'Nhất A'; sf.teamB = 'Nhì B'; sf.scoreA = null; sf.scoreB = null; sf.winner = null; sf.loser = null;
        if (sf.id === 'SF2') { sf.teamA = 'Nhất B'; sf.teamB = 'Nhì A'; }
    });
    state.final.teamA = 'Thắng SF1';
    state.final.teamB = 'Thắng SF2';
    state.final.scoreA = null;
    state.final.scoreB = null;
    state.final.winner = null;
    state.final.runnerUp = null;
    state.thirdPlaceTeams = [];

    stateChanged = true;
    tinhVaCapNhatXepHang(); // TÍNH lại bảng xếp hạng (trống)
    renderMatchesView();
    renderFinals();
    renderOverview();
    showModal('Xóa Lịch Thành công', 'Toàn bộ lịch thi đấu và kết quả đã được xóa.');
    saveToGitHub();
}

/**
 * Điền kết quả Vòng Bảng và Vòng Chung Kết ngẫu nhiên (chỉ điền các trận chưa đấu)
 */
function autoFillScores() {
    if (!confirm("Bạn có chắc chắn muốn điền kết quả TỰ ĐỘNG cho TẤT CẢ các trận chưa đấu (Vòng Bảng & Chung kết)?")) return;
    
    let filledCount = 0;
    
    // 1. Điền Vòng Bảng
    [...state.matchesA, ...state.matchesB].forEach(match => {
        if (match.scoreA === null || match.scoreB === null) {
            // Điểm ngẫu nhiên (ví dụ: 11-x, x < 11)
            const winnerScore = 11;
            const loserScore = Math.floor(Math.random() * 9) + 2; // Điểm thua từ 2-10
            
            if (Math.random() > 0.5) { // 50% A thắng
                match.scoreA = winnerScore;
                match.scoreB = loserScore;
                match.winner = match.teamA;
                match.loser = match.teamB;
            } else { // 50% B thắng
                match.scoreA = loserScore;
                match.scoreB = winnerScore;
                match.winner = match.teamB;
                match.loser = match.teamA;
            }
            filledCount++;
        }
    });

    // 2. Điền Vòng Chung Kết (Sau khi Vòng Bảng đã có kết quả để điền tên đội)
    tinhVaCapNhatXepHang(); // Đảm bảo tên đội đã được điền vào bán kết

    const fillMatch = (match) => {
        if (!match.winner && match.teamA && match.teamB && match.teamA !== 'Thắng SF1' && match.teamB !== 'Thắng SF2') {
             // Điểm ngẫu nhiên cho Vòng CK
            const winnerScore = 11;
            const loserScore = Math.floor(Math.random() * 9) + 2;
            
            if (Math.random() > 0.5) { 
                match.scoreA = winnerScore;
                match.scoreB = loserScore;
                match.winner = match.teamA;
                if (match.id === 'F') {
                    match.runnerUp = match.teamB;
                } else {
                    match.loser = match.teamB;
                }
            } else { 
                match.scoreA = loserScore;
                match.scoreB = winnerScore;
                match.winner = match.teamB;
                 if (match.id === 'F') {
                    match.runnerUp = match.teamA;
                } else {
                    match.loser = match.teamA;
                }
            }
            return true;
        }
        return false;
    };
    
    // Điền bán kết
    state.semifinals.forEach(sf => {
        if (fillMatch(sf)) filledCount++;
    });
    
    // Cập nhật lại tên đội vào Chung kết
    capNhatDoiVaoVongChungKet(state.tableA, state.tableB);
    
    // Điền chung kết
    if (fillMatch(state.final)) filledCount++;
    
    if (filledCount > 0) {
        stateChanged = true;
        // BẮT BUỘC: Tính toán lại bảng xếp hạng (để cập nhật thống kê)
        tinhVaCapNhatXepHang(); 
        
        // Cập nhật giao diện
        renderMatchesView();
        renderFinals();
        renderOverview();
        
        // Lưu ngay lập tức
        saveToGitHub(true);
        showModal('Điền Kết quả Tự động', `Đã điền ngẫu nhiên ${filledCount} trận đấu Vòng Bảng và Vòng Chung Kết.`);
    } else {
        showModal('Điền Kết quả Tự động', 'Không có trận đấu nào cần điền. Toàn bộ lịch đã hoàn thành.');
    }
}

/**
 * Xóa kết quả Vòng Bảng theo Group (A hoặc B)
 * @param {string} group - 'A', 'B', hoặc 'ALL'
 */
function clearGroupScores(group) {
    // Không cho phép xóa nếu Vòng Chung Kết đã có kết quả
    const finalsCompleted = state.semifinals.some(sf => sf.winner) || state.final.winner;
    if (finalsCompleted) {
        showModal('Lỗi Xóa Kết Quả', 'Không thể xóa kết quả Vòng Bảng. Vui lòng **Xóa kết quả Vòng Bán kết và Chung kết** (ví dụ, bằng cách xóa toàn bộ lịch ở tab Cấu hình) trước.');
        return;
    }
    
    const message = group === 'ALL' 
        ? "Bạn có chắc chắn muốn XÓA TOÀN BỘ kết quả Vòng Bảng (Bảng A & B)? Hành động này không thể hoàn tác."
        : `Bạn có chắc chắn muốn XÓA TOÀN BỘ kết quả của Bảng ${group}? Hành động này không thể hoàn tác.`;
    
    if (!confirm(message)) return;

    let clearedCount = 0;
    
    const matchesToClear = [];
    if (group === 'A' || group === 'ALL') matchesToClear.push(...state.matchesA);
    if (group === 'B' || group === 'ALL') matchesToClear.push(...state.matchesB);
    
    matchesToClear.forEach(match => {
        if (match.scoreA !== null || match.scoreB !== null) {
            match.scoreA = null;
            match.scoreB = null;
            match.winner = null;
            match.loser = null;
            clearedCount++;
        }
    });

    if (clearedCount > 0) {
        tinhVaCapNhatXepHang();
        renderMatchesView();
        renderOverview();
        
        stateChanged = true;
        saveToGitHub();
        updateStatus('clearScoreStatus', 'success', `Đã xóa ${clearedCount} kết quả trận đấu Vòng Bảng.`);
    } else {
        updateStatus('clearScoreStatus', 'warning', 'Không có kết quả nào để xóa trong bảng này.');
    }
}


// --- Logic Sân thi đấu ---

/**
 * Mở modal thêm/sửa sân và điền dữ liệu nếu là chế độ sửa.
 * @param {number | null} index - Chỉ số của sân cần sửa, hoặc null nếu thêm mới.
 */
function openCourtModal(index = null) {
    const modal = new bootstrap.Modal(document.getElementById('courtModal'));
    document.getElementById('courtFormStatus').innerHTML = '';
    document.getElementById('courtIndex').value = index !== null ? index : '';
    document.getElementById('courtModalLabel').textContent = index !== null ? 'Sửa Cấu hình Sân' : 'Thêm Sân Mới';

    if (index !== null) {
        const court = state.courts[index];
        document.getElementById('courtName').value = court.name;
        document.getElementById('courtStartTime').value = court.startTime;
        document.getElementById('courtMaxDuration').value = court.maxDurationMinutes;
        document.getElementById('courtIsMixed').checked = court.isMixed;
    } else {
        document.getElementById('courtForm').reset();
        document.getElementById('courtStartTime').value = '14:00'; // Set default
    }
    modal.show();
}

/**
 * Lưu thay đổi cấu hình Sân.
 */
function saveCourtChanges() {
    const index = document.getElementById('courtIndex').value;
    const name = document.getElementById('courtName').value.trim();
    const startTime = document.getElementById('courtStartTime').value;
    const maxDuration = parseInt(document.getElementById('courtMaxDuration').value, 10);
    const isMixed = document.getElementById('courtIsMixed').checked;
    
    if (!name || !startTime || isNaN(maxDuration) || maxDuration <= 0) {
        updateStatus('courtFormStatus', 'danger', 'Vui lòng điền đầy đủ và chính xác các thông tin.');
        return;
    }

    if (index !== '') {
        // Sửa
        state.courts[parseInt(index, 10)] = { name, startTime, maxDurationMinutes: maxDuration, isMixed };
        updateStatus('configStatus', 'success', `Đã cập nhật cấu hình Sân ${name}.`);
    } else {
        // Thêm mới
        state.courts.push({ name, startTime, maxDurationMinutes: maxDuration, isMixed });
        updateStatus('configStatus', 'success', `Đã thêm Sân ${name} mới.`);
    }

    // Lưu và Render lại
    saveConfig(); 
    renderCourtList();
    
    // Đóng modal
    const modalElement = document.getElementById('courtModal');
    const modal = bootstrap.Modal.getInstance(modalElement) || new bootstrap.Modal(modalElement);
    modal.hide();
}

/**
 * Xóa cấu hình sân theo index.
 * @param {number} index - Chỉ số của sân cần xóa.
 */
function deleteCourt(index) {
    const courtName = state.courts[index].name;
    if (confirm(`Bạn có chắc chắn muốn xóa Sân ${courtName}?`)) {
        state.courts.splice(index, 1);
        saveConfig();
        renderCourtList();
        updateStatus('configStatus', 'success', `Đã xóa Sân ${courtName}.`);
    }
}

/**
 * Tải cấu hình Sân mặc định.
 */
function loadDefaultCourtConfig() {
     if (!confirm("Bạn có chắc chắn muốn tải lại cấu hình Sân mặc định (8 sân)? Cấu hình hiện tại sẽ bị ghi đè.")) return;
     state.courts = [
        { name: 'Sân 1', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, 
        { name: 'Sân 2', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, 
        { name: 'Sân 3', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, 
        { name: 'Sân 4', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, 
        { name: 'Sân 5', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }, 
        { name: 'Sân 6', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }, 
        { name: 'Sân 7', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }, 
        { name: 'Sân 8', startTime: '14:00', maxDurationMinutes: 180, isMixed: false } 
    ];
    saveConfig();
    renderCourtList();
    updateStatus('configStatus', 'success', 'Đã tải cấu hình Sân mặc định (8 sân) thành công.');
}

/**
 * Hiển thị danh sách sân dưới dạng bảng với nút Sửa/Xóa.
 */
function renderCourtList() {
    const container = document.getElementById('courtListContainer');
    if (!container) return;

    if (state.courts.length === 0) {
        container.innerHTML = `<div class="alert alert-warning">Chưa có sân nào được cấu hình.</div>`;
        return;
    }

    let html = `<div class='table-responsive'><table class='table table-striped table-sm'> 
        <thead> 
            <tr> 
                <th>Tên Sân</th> 
                <th>Giờ Bắt Đầu</th> 
                <th>Thời Lượng Max (Phút)</th> 
                <th>Phân Loại</th> 
                <th class="text-center">Hành động</th> 
            </tr> 
        </thead> 
        <tbody>`;

    state.courts.forEach((court, index) => {
        const type = court.isMixed ? 'Bảng A (Nam - Nữ)' : 'Bảng B (Nam)';
        const typeClass = court.isMixed ? 'badge bg-primary' : 'badge bg-info';
        html += `<tr> 
            <td>${court.name}</td> 
            <td>${court.startTime}</td> 
            <td>${court.maxDurationMinutes}</td> 
            <td><span class="${typeClass}">${type}</span></td> 
            <td class="text-center"> 
                <button class="btn btn-sm btn-outline-secondary me-1" onclick="openCourtModal(${index})">Sửa</button> 
                <button class="btn btn-sm btn-outline-danger" onclick="deleteCourt(${index})">Xóa</button> 
            </td> 
        </tr>`;
    });

    html += `</tbody></table></div>`;
    container.innerHTML = html;
}

function renderConfig() {
    // Chỉ cần hiển thị cấu hình sân hiện tại
    renderCourtList();
    document.getElementById('courtConfigStatus').innerHTML = '';
    document.getElementById('clearScoreStatus').innerHTML = ''; // Clear new status div

    // Cập nhật UI cho preferredCourtType khi vào tab config
    const select = document.getElementById('preferredCourtType');
    if (select) {
        select.value = state.config.preferredCourtType || 'mixed';
    }
}

// --- Logic Rendering ---

/**
 * Render lịch thi đấu Vòng Bảng theo chế độ đã chọn (Table/Court)
 */
function renderMatchesView() {
    const viewMode = document.getElementById('viewMode').value;
    const container = document.getElementById('matchesViewContent');

    if (viewMode === 'table') {
        renderMatchesByTable(container);
    } else {
        renderMatchesByCourt(container);
    }
}

/**
 * Render lịch thi đấu Vòng Bảng theo Bảng đấu (Group)
 */
function renderMatchesByTable(container) {
    let finalHtml = '';
    
    // Duyệt qua từng bảng đấu
    [['A', state.matchesA], ['B', state.matchesB]].forEach(([group, matches]) => {
        const teams = group === 'A' ? state.mixedTeams : state.maleTeams;
        if (matches.length === 0 || teams.length < 2) {
            finalHtml += `<h6 class="mt-4">Bảng ${group} (${group === 'A' ? 'Nam - Nữ' : 'Nam'})</h6>
                          <div class="alert alert-info">Chưa có lịch thi đấu hoặc thiếu đội.</div>`;
            return;
        }

        finalHtml += `<h6 class="mt-4">Bảng ${group} (${group === 'A' ? 'Nam - Nữ' : 'Nam'})</h6>
            <div class='table-responsive'><table class='table table-striped table-hover table-bordered table-sm'>
                <thead>
                    <tr>
                        <th>ID</th>
                        <th>Thời gian/Sân</th>
                        <th>Đội A</th>
                        <th class="text-center">Tỉ số A</th>
                        <th class="text-center">Tỉ số B</th>
                        <th>Đội B</th>
                    </tr>
                </thead>
                <tbody>
        `;
        
        matches.forEach((match, index) => {
            const teamA_Class = match.winner === match.teamA ? 'winner' : (match.loser === match.teamA ? 'loser' : '');
            const teamB_Class = match.winner === match.teamB ? 'winner' : (match.loser === match.teamB ? 'loser' : '');
            const matchRowClass = match.winner ? 'table-light' : '';
            
            finalHtml += `
                <tr class="${matchRowClass}">
                    <td>${match.id}</td>
                    <td>${match.time || '-'} - ${match.court || '-'}</td>
                    <td class="text-truncate ${teamA_Class}">${match.teamA}</td>
                    <td class="match-score-cell text-center">
                        <input type="number" id="score-${group}-${index}-A" 
                            value="${match.scoreA !== null ? match.scoreA : ''}" 
                            min="0" onchange="updateScore('${group}', ${index})">
                    </td>
                    <td class="match-score-cell text-center">
                        <input type="number" id="score-${group}-${index}-B" 
                            value="${match.scoreB !== null ? match.scoreB : ''}" 
                            min="0" onchange="updateScore('${group}', ${index})">
                    </td>
                    <td class="text-truncate ${teamB_Class}">${match.teamB}</td>
                </tr>
            `;
        });
        
        finalHtml += `
                </tbody>
            </table>
            </div>
        `;
    });

    container.innerHTML = finalHtml;
}

/**
 * Render lịch thi đấu Vòng Bảng theo Sân (Court)
 */
function renderMatchesByCourt(container) {
    const allMatches = [...state.matchesA.map(m => ({ ...m, group: 'A' })), 
                        ...state.matchesB.map(m => ({ ...m, group: 'B' }))];
                        
    // Sắp xếp theo thời gian và sau đó theo sân
    allMatches.sort((a, b) => {
        if (a.time < b.time) return -1;
        if (a.time > b.time) return 1;
        if (a.court < b.court) return -1;
        if (a.court > b.court) return 1;
        return 0;
    });

    // Gom nhóm theo Giờ Bắt đầu
    const matchesByTime = allMatches.reduce((acc, match) => {
        const key = match.time || 'Chưa xếp lịch';
        if (!acc[key]) {
            acc[key] = [];
        }
        acc[key].push(match);
        return acc;
    }, {});
    
    let finalHtml = '';
    
    // Duyệt qua từng nhóm giờ
    Object.keys(matchesByTime).sort().forEach(time => {
        const matchesAtTime = matchesByTime[time];
        
        finalHtml += `<h6 class="mt-4">Thời gian: ${time}</h6>
            <div class='table-responsive'><table class='table table-striped table-hover table-bordered table-sm'>
                <thead>
                    <tr>
                        <th>Sân</th>
                        <th>Bảng</th>
                        <th>Đội A</th>
                        <th class="text-center">Tỉ số A</th>
                        <th class="text-center">Tỉ số B</th>
                        <th>Đội B</th>
                    </tr>
                </thead>
                <tbody>
        `;
        
        // Sắp xếp theo Sân
        matchesAtTime.sort((a, b) => {
            if (a.court < b.court) return -1;
            if (a.court > b.court) return 1;
            return 0;
        });

        matchesAtTime.forEach(match => {
            // Cần tìm index gốc để gọi updateScore
            const groupMatches = match.group === 'A' ? state.matchesA : state.matchesB;
            const index = groupMatches.findIndex(m => m.id === match.id);
            
            const teamA_Class = match.winner === match.teamA ? 'winner' : (match.loser === match.teamA ? 'loser' : '');
            const teamB_Class = match.winner === match.teamB ? 'winner' : (match.loser === match.teamB ? 'loser' : '');
            const matchRowClass = match.winner ? 'table-light' : '';
            
            finalHtml += `
                <tr class="${matchRowClass}">
                    <td>${match.court || '-'}</td>
                    <td>${match.group}</td>
                    <td class="text-truncate ${teamA_Class}">${match.teamA}</td>
                    <td class="match-score-cell text-center">
                        <input type="number" id="score-${match.group}-${index}-A" 
                            value="${match.scoreA !== null ? match.scoreA : ''}" 
                            min="0" onchange="updateScore('${match.group}', ${index})">
                    </td>
                    <td class="match-score-cell text-center">
                        <input type="number" id="score-${match.group}-${index}-B" 
                            value="${match.scoreB !== null ? match.scoreB : ''}" 
                            min="0" onchange="updateScore('${match.group}', ${index})">
                    </td>
                    <td class="text-truncate ${teamB_Class}">${match.teamB}</td>
                </tr>
            `;
        });
        
        finalHtml += `
                </tbody>
            </table>
            </div>
        `;
    });

    container.innerHTML = finalHtml;
}

/**
 * Render bảng xếp hạng Vòng Bảng
 */
function renderRankingTables() {
    const container = document.getElementById('rankingTables');
    if (!container) return;
    
    function createRankingTable(title, tableData) {
        if (tableData.length === 0) {
            return `<div class="p-3 border rounded bg-light"><h6>${title}</h6><p class="text-muted small mb-0">Chưa có dữ liệu đội hoặc chưa có kết quả.</p></div>`;
        }

        let html = `
            <div class="table-responsive">
            <h6>${title}</h6>
            <table class="table table-sm table-striped table-hover table-bordered">
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Đội</th>
                        <th title="Số trận Thắng/Thua">T/B</th>
                        <th title="Hiệu số điểm">HS</th>
                        <th title="Tổng điểm thắng">ĐT</th>
                        <th title="Tổng điểm">Đ</th>
                    </tr>
                </thead>
                <tbody>
        `;
        
        tableData.forEach((team, index) => {
            const rank = index + 1;
            // Highlight đội đi tiếp (Hạng 1 & 2)
            const rowClass = rank <= 2 ? 'table-success' : ''; 
            
            html += `
                <tr class="${rowClass}">
                    <td>${rank}</td>
                    <td class="text-truncate">${team.name}</td>
                    <td>${team.W}/${team.L}</td>
                    <td>${team.GD > 0 ? '+' : ''}${team.GD}</td>
                    <td>${team.GF}</td>
                    <td>${team.PTS}</td>
                </tr>
            `;
        });
        
        html += `
                </tbody>
            </table>
            </div>
        `;
        return html;
    }
    
    const tableA = createRankingTable('Bảng A (Nam - Nữ)', state.tableA);
    const tableB = createRankingTable('Bảng B (Nam)', state.tableB);
    
    container.innerHTML = tableA + tableB;
}

/**
 * Render các trận đấu Vòng Chung Kết (Bán kết và Chung kết)
 */
function renderFinals() {
    const semiContainer = document.getElementById('semifinalMatches');
    const finalContainer = document.getElementById('finalMatch');
    
    if (!semiContainer || !finalContainer) return;

    function renderMatch(match, isFinal = false) {
        let matchHtml = ``;
        let group = match.id;
        let winnerClassA = '';
        let winnerClassB = '';
        
        if (match.winner) {
            winnerClassA = match.winner === match.teamA ? 'winner' : 'loser';
            winnerClassB = match.winner === match.teamB ? 'winner' : 'loser';
        }

        // Tìm index trong mảng semifinals (0 hoặc 1) nếu không phải chung kết
        const matchIndex = isFinal ? 0 : state.semifinals.findIndex(sf => sf.id === match.id);
        const onchangeCall = isFinal ? `updateFinalScore('final', 0)` : `updateFinalScore('semifinal', ${matchIndex})`;
        const teamAName = match.teamA || 'Đang chờ';
        const teamBName = match.teamB || 'Đang chờ';
        const isSeeded = teamAName.includes('Nhất') || teamAName.includes('Thắng');
        
        matchHtml = `
            <div class='card mb-3 ${match.winner ? 'shadow-sm border-success' : 'border-light'}'>
                <div class='card-body p-3'>
                    <div class="row align-items-center g-2">
                        <div class="col-12 col-md-3 text-muted small">${match.time} | ${match.court}</div>
                        
                        <div class="col-12 col-md-4">
                            <span class="${winnerClassA} text-truncate ${isSeeded ? 'text-muted' : ''}">${teamAName}</span> 
                        </div>
                        <div class="col-12 col-md-1 d-flex justify-content-center">
                            <input type="number" class="form-control form-control-sm text-center" 
                                id="score-${group}-A" value="${match.scoreA !== null ? match.scoreA : ''}" min="0" 
                                onchange="${onchangeCall}" style="width: 50px;">
                        </div>
                        
                        <div class="col-12 col-md-1 text-center small">VS</div>
                        
                        <div class="col-12 col-md-1 d-flex justify-content-center">
                            <input type="number" class="form-control form-control-sm text-center" 
                                id="score-${group}-B" value="${match.scoreB !== null ? match.scoreB : ''}" min="0" 
                                onchange="${onchangeCall}" style="width: 50px;">
                        </div>
                        <div class="col-12 col-md-3">
                            <span class="${winnerClassB} text-truncate ${isSeeded ? 'text-muted' : ''}">${teamBName}</span>
                        </div>
                        
                    </div>
                </div>
            </div>
        `;
        return matchHtml;
    }
    
    // Render Bán kết
    semiContainer.innerHTML = state.semifinals.map(sf => renderMatch(sf, false)).join('');

    // Render Chung kết
    finalContainer.innerHTML = renderMatch(state.final, true);
}

/**
 * Render thông tin Tổng quan và Bảng xếp hạng Vòng Bảng rút gọn
 */
function renderOverview() {
    const container = document.getElementById('overviewContent');
    if (!container) return;

    // 1. Tổng quan tình trạng
    const totalMatchesA = state.mixedTeams.length * (state.mixedTeams.length - 1) / 2;
    const completedA = state.matchesA.filter(m => m.scoreA !== null && m.scoreB !== null).length;
    const isGroupACompleted = totalMatchesA > 0 && completedA === totalMatchesA;
    const percentA = totalMatchesA > 0 ? (completedA / totalMatchesA * 100).toFixed(0) : 0;
    
    const totalMatchesB = state.maleTeams.length * (state.maleTeams.length - 1) / 2;
    const completedB = state.matchesB.filter(m => m.scoreA !== null && m.scoreB !== null).length;
    const isGroupBCompleted = totalMatchesB > 0 ? completedB === totalMatchesB : false;
    const percentB = totalMatchesB > 0 ? (completedB / totalMatchesB * 100).toFixed(0) : 0;
    
    // Vòng Chung kết
    const sf1Winner = state.semifinals[0].winner;
    const sf2Winner = state.semifinals[1].winner;
    let finalStatus = '';
    if (state.final.winner) {
        finalStatus = `<span class="badge bg-success">ĐÃ KẾT THÚC (Vô địch: ${state.final.winner})</span>`;
    } else if (sf1Winner && sf2Winner) {
        finalStatus = `<span class="badge bg-warning text-dark">Chờ Chung kết</span>`;
    } else if (isGroupACompleted && isGroupBCompleted) {
         finalStatus = `<span class="badge bg-info text-dark">Chờ Bán kết</span>`;
    } else {
        finalStatus = `<span class="badge bg-secondary">Chờ Vòng Bảng</span>`;
    }
    
    let infoHtml = `
        <div class="row mb-4">
            <div class="col-md-6 mb-3">
                <div class="card p-3 h-100">
                    <h5 class="card-title">Tiến trình Vòng Bảng</h5>
                    <p class="mb-1 small">Bảng A (Nam - Nữ): ${completedA}/${totalMatchesA} trận hoàn thành 
                        <span class="badge bg-${isGroupACompleted ? 'success' : 'primary'}">${percentA}%</span></p>
                    <p class="mb-1 small">Bảng B (Nam): ${completedB}/${totalMatchesB} trận hoàn thành 
                        <span class="badge bg-${isGroupBCompleted ? 'success' : 'primary'}">${percentB}%</span></p>
                </div>
            </div>
            <div class="col-md-6 mb-3">
                 <div class="card p-3 h-100">
                    <h5 class="card-title">Trạng thái Vòng Chung kết</h5>
                    <p class="mb-1">Trạng thái: ${finalStatus}</p>
                    <p class="mb-0 small">Bán kết 1: ${state.semifinals[0].teamA} vs ${state.semifinals[0].teamB} (${sf1Winner ? 'Thắng: ' + sf1Winner : 'Chưa đấu'})</p>
                    <p class="mb-0 small">Bán kết 2: ${state.semifinals[1].teamA} vs ${state.semifinals[1].teamB} (${sf2Winner ? 'Thắng: ' + sf2Winner : 'Chưa đấu'})</p>
                </div>
            </div>
        </div>
        
        <h5 class="mb-3">Bảng Xếp Hạng Hiện Tại (Top 2)</h5>
        <div id="overviewRanking" class="ranking-container">
            ${renderSimpleRanking(state.tableA, 'Bảng A')}
            ${renderSimpleRanking(state.tableB, 'Bảng B')}
        </div>
    `;
    
    container.innerHTML = infoHtml;
}

/**
 * Tạo bảng xếp hạng rút gọn (Top 2) cho tab Tổng quan
 */
function renderSimpleRanking(tableData, title) {
    if (tableData.length === 0) {
        return `<div class="p-3 border rounded bg-light"><h6>${title}</h6><p class="text-muted small mb-0">Chưa có dữ liệu đội.</p></div>`;
    }

    let html = `
        <div class="table-responsive">
        <h6>${title}</h6>
        <table class="table table-sm table-striped table-hover table-bordered">
            <thead>
                <tr>
                    <th>#</th>
                    <th>Đội</th>
                    <th title="Số trận Thắng">T</th>
                    <th title="Hiệu số điểm">HS</th>
                </tr>
            </thead>
            <tbody>
    `;
    
    // Chỉ lấy Top 2
    tableData.slice(0, 2).forEach((team, index) => {
        const rank = index + 1;
        html += `
            <tr class="table-success">
                <td>${rank}</td>
                <td class="text-truncate">${team.name}</td>
                <td>${team.W}</td>
                <td>${team.GD > 0 ? '+' : ''}${team.GD}</td>
            </tr>
        `;
    });
    
    // Thêm các đội còn lại nếu có
    tableData.slice(2).forEach((team, index) => {
         const rank = index + 3;
         html += `
            <tr>
                <td>${rank}</td>
                <td class="text-truncate">${team.name}</td>
                <td>${team.W}</td>
                <td>${team.GD > 0 ? '+' : ''}${team.GD}</td>
            </tr>
        `;
    });

    html += `
            </tbody>
        </table>
        </div>
    `;
    return html;
}

/**
 * Render kết quả Chung cuộc (Vô địch, Á quân, Hạng Ba)
 */
function renderFinalResults() {
    const championEl = document.getElementById('champion');
    const runnerUpEl = document.getElementById('runnerUp');
    const thirdPlaceEl = document.getElementById('thirdPlace');
    
    let championText = 'Đang chờ kết quả...';
    let runnerUpText = 'Đang chờ kết quả...';
    let thirdPlaceText = 'Đang chờ kết quả...';
    
    if (state.final.winner) {
        championText = `Vô địch: 🥇 **${state.final.winner}**`;
    }
    
    if (state.final.runnerUp) {
        runnerUpText = `Á quân: 🥈 **${state.final.runnerUp}**`;
    }
    
    if (state.thirdPlaceTeams && state.thirdPlaceTeams.length === 2) {
        thirdPlaceText = `Hạng Ba Đồng Hạng: 🥉 **${state.thirdPlaceTeams[0]}** và **${state.thirdPlaceTeams[1]}**`;
    } else if (state.semifinals.some(sf => sf.loser)) {
         thirdPlaceText = `Hạng Ba Đồng Hạng: Đang chờ hoàn tất Vòng Bán kết...`;
    }
    
    championEl.innerHTML = championText;
    runnerUpEl.innerHTML = runnerUpText;
    thirdPlaceEl.innerHTML = thirdPlaceText;
}


// --- Logic Tạo Lịch Tối ưu (Complex) ---

/**
 * Chuyển đổi HH:mm thành số phút từ 00:00
 */
function timeToMinutes(time) {
    const [h, m] = time.split(':').map(Number);
    return h * 60 + m;
}

/**
 * Chuyển đổi số phút thành HH:mm
 */
function minutesToTime(minutes) {
    const h = Math.floor(minutes / 60).toString().padStart(2, '0');
    const m = (minutes % 60).toString().padStart(2, '0');
    return `${h}:${m}`;
}

/**
 * Thuật toán tạo lịch thi đấu tối ưu (ít thời gian trống, sử dụng tối đa sân)
 */
function taoLichThiDauCungGio() {
    if (!confirm("Bạn có chắc chắn muốn Tự động tạo lịch thi đấu Tối ưu? Lịch thi đấu hiện tại sẽ bị ghi đè.")) return;
    
    // 1. Kiểm tra điều kiện
    if (state.mixedTeams.length < 2 && state.maleTeams.length < 2) {
        showModal('Lỗi Tạo Lịch', 'Không thể tạo lịch. Cần ít nhất 2 đội cho mỗi bảng đấu (hoặc nhập đội vào players.json).');
        return;
    }
    if (state.courts.length === 0) {
        showModal('Lỗi Tạo Lịch', 'Không thể tạo lịch. Vui lòng cấu hình Sân thi đấu tại tab Cấu hình.');
        return;
    }
    
    // 2. Khởi tạo
    state.matchesA = [];
    state.matchesB = [];
    stateChanged = true;

    const allTeams = [...state.mixedTeams, ...state.maleTeams];
    const totalMatchesA = state.mixedTeams.length * (state.mixedTeams.length - 1) / 2;
    const totalMatchesB = state.maleTeams.length * (state.maleTeams.length - 1) / 2;

    const matchesToSchedule = [];

    // Tạo danh sách các cặp đấu cần thiết
    function generateMatchPairs(teams, group) {
        const matches = [];
        for (let i = 0; i < teams.length; i++) {
            for (let j = i + 1; j < teams.length; j++) {
                matches.push({ teamA: teams[i], teamB: teams[j], group: group });
            }
        }
        return matches;
    }

    // 3. Tạo tất cả cặp đấu cần xếp
    const matchesA = generateMatchPairs(state.mixedTeams, 'A');
    const matchesB = generateMatchPairs(state.maleTeams, 'B');
    let allPairs = [...matchesA, ...matchesB];
    
    // 4. Khởi tạo trạng thái Sân
    const courtStates = state.courts.map(court => ({
        ...court,
        // Thời gian sân kết thúc trận đấu hiện tại
        currentMinutes: timeToMinutes(court.startTime),
        // Lịch đã xếp trên sân này
        schedule: []
    }));
    
    // 5. Thuật toán Xếp lịch (Ưu tiên Sân sớm nhất)
    const matchDuration = 15; // Giả sử mỗi trận kéo dài 15 phút
    let matchIdCounter = 1;
    let scheduledMatchesCount = 0;

    // Lặp cho đến khi hết trận đấu cần xếp
    while (allPairs.length > 0 && scheduledMatchesCount < totalMatchesA + totalMatchesB + 100) { // Giới hạn vòng lặp an toàn
        // Sắp xếp các sân theo thời gian rảnh sớm nhất
        courtStates.sort((a, b) => a.currentMinutes - b.currentMinutes);
        
        // Lấy sân rảnh sớm nhất
        const earliestCourt = courtStates[0];

        // Kiểm tra sân có thể tiếp tục xếp lịch không
        if (earliestCourt.currentMinutes >= timeToMinutes(earliestCourt.startTime) + earliestCourt.maxDurationMinutes) {
             // Nếu sân đã hết thời gian làm việc, chuyển sân này xuống cuối để tìm sân khác
             const exhaustedCourt = courtStates.shift();
             courtStates.push(exhaustedCourt);
             
             // Nếu tất cả sân đều hết thời gian, thoát
             if (courtStates.every(c => c.currentMinutes >= timeToMinutes(c.startTime) + c.maxDurationMinutes)) {
                 break; 
             }
             continue;
        }
        
        // 6. Tìm trận đấu phù hợp cho sân này
        let foundMatchIndex = -1;
        
        // Ưu tiên xếp loại trận đấu mà sân này được ưu tiên (mixed/male)
        let preferredGroup = earliestCourt.isMixed ? 'A' : 'B';

        // Lựa chọn 1: Tìm trận cùng loại với sân ưu tiên
        foundMatchIndex = allPairs.findIndex(p => p.group === preferredGroup);
        
        // Lựa chọn 2: Nếu không tìm thấy, tìm trận khác loại (Nếu sân là Mixed và còn trận Male, hoặc ngược lại)
        if (foundMatchIndex === -1 && allPairs.length > 0) {
            const otherGroup = preferredGroup === 'A' ? 'B' : 'A';
            foundMatchIndex = allPairs.findIndex(p => p.group === otherGroup);
        }

        // 7. Xếp lịch cho trận đấu được chọn
        if (foundMatchIndex !== -1) {
            const match = allPairs.splice(foundMatchIndex, 1)[0];
            
            const matchTime = minutesToTime(earliestCourt.currentMinutes);
            
            const newMatch = {
                id: `M${matchIdCounter++}`,
                time: matchTime,
                court: earliestCourt.name,
                teamA: match.teamA,
                teamB: match.teamB,
                scoreA: null,
                scoreB: null,
                winner: null,
                loser: null
            };
            
            // Thêm vào lịch của sân
            earliestCourt.schedule.push(newMatch);
            
            // Cập nhật thời gian rảnh mới của sân
            earliestCourt.currentMinutes += matchDuration; 
            
            // Thêm vào state chính
            if (match.group === 'A') {
                state.matchesA.push(newMatch);
            } else {
                state.matchesB.push(newMatch);
            }
            scheduledMatchesCount++;
        } else {
            // Không tìm thấy trận đấu nào phù hợp với tất cả các sân còn lại. Thoát.
            break;
        }
    }
    
    // 8. Kết quả
    if (state.matchesA.length + state.matchesB.length > 0) {
        // Cần phải sắp xếp lại state.matchesA/B theo ID để index khớp với giao diện
        state.matchesA.sort((a, b) => a.id.localeCompare(b.id));
        state.matchesB.sort((a, b) => a.id.localeCompare(b.id));

        tinhVaCapNhatXepHang();
        renderMatchesView();
        renderOverview();
        showModal('Tạo Lịch Thành công', `Đã tạo ${state.matchesA.length + state.matchesB.length} trận đấu Vòng Bảng tối ưu.`);
        saveToGitHub();
    } else {
        showModal('Lỗi Tạo Lịch', 'Không thể tạo lịch thi đấu. Kiểm tra lại cấu hình đội và sân.');
    }
}

/**
 * Lên lịch Vòng Chung kết (tự động điền sân, thời gian)
 */
function scheduleFinalsAuto() {
    if (!confirm("Bạn có chắc chắn muốn Tự động lên lịch Vòng Chung kết? (Bán kết: 16:40, Chung kết: 17:30, Sân 3)")) return;
    
    // Đặt lại thời gian và sân mặc định
    const defaultSF1 = { time: '16:40', court: 'Sân 3' };
    const defaultSF2 = { time: '17:05', court: 'Sân 3' };
    const defaultFinal = { time: '17:30', court: 'Sân 3' };
    
    // Bán kết 1
    state.semifinals[0].time = defaultSF1.time;
    state.semifinals[0].court = defaultSF1.court;
    
    // Bán kết 2
    state.semifinals[1].time = defaultSF2.time;
    state.semifinals[1].court = defaultSF2.court;
    
    // Chung kết
    state.final.time = defaultFinal.time;
    state.final.court = defaultFinal.court;
    
    stateChanged = true;
    renderFinals();
    showModal('Lên lịch Chung kết', 'Đã tự động lên lịch Vòng Chung kết thành công (16:40, Sân 3).');
    saveToGitHub();
}

/**
 * Xử lý Import Lịch từ file CSV
 */
function handleFileSelect(event) {
    const file = event.target.files[0];
    if (!file) {
        return;
    }

    const reader = new FileReader();
    reader.onload = function(e) {
        const contents = e.target.result;
        try {
            if (!confirm("Bạn có chắc chắn muốn Import lịch thi đấu từ file CSV? Lịch thi đấu hiện tại sẽ bị ghi đè.")) return;
            
            const lines = contents.trim().split('\n');
            if (lines.length < 2) {
                showModal('Lỗi Import', 'File CSV không có dữ liệu trận đấu.');
                return;
            }
            
            // Xóa lịch cũ
            state.matchesA = [];
            state.matchesB = [];
            
            const headers = lines[0].split(',').map(h => h.trim());
            
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',').map(v => v.trim());
                if (values.length !== headers.length) continue; 
                
                const match = {};
                headers.forEach((header, index) => {
                    match[header] = values[index];
                });

                const newMatch = {
                    id: `M${i}`,
                    time: match.time || null,
                    court: match.court || null,
                    teamA: match.teamA,
                    teamB: match.teamB,
                    scoreA: match.scoreA ? parseInt(match.scoreA, 10) : null,
                    scoreB: match.scoreB ? parseInt(match.scoreB, 10) : null,
                    winner: null,
                    loser: null
                };
                
                // Xác định Winner/Loser nếu có điểm
                if (newMatch.scoreA !== null && newMatch.scoreB !== null) {
                     if (newMatch.scoreA > newMatch.scoreB) {
                         newMatch.winner = newMatch.teamA;
                         newMatch.loser = newMatch.teamB;
                     } else if (newMatch.scoreB > newMatch.scoreA) {
                         newMatch.winner = newMatch.teamB;
                         newMatch.loser = newMatch.teamA;
                     }
                }
                
                if (match.bang === 'A') {
                    state.matchesA.push(newMatch);
                } else if (match.bang === 'B') {
                    state.matchesB.push(newMatch);
                }
            }

            stateChanged = true;
            tinhVaCapNhatXepHang();
            renderMatchesView();
            renderOverview();
            showModal('Import Lịch', `Đã import thành công ${state.matchesA.length + state.matchesB.length} trận đấu từ CSV.`);
            saveToGitHub();

        } catch (error) {
            showModal('Lỗi Import', `Lỗi xử lý file CSV: ${error.message}. Vui lòng kiểm tra định dạng.`);
            console.error(error);
        }
    };
    reader.readAsText(file, 'UTF-8');
}

/**
 * Xuất Lịch ra file CSV
 */
function exportSchedule() {
    const allMatches = [...state.matchesA.map(m => ({ ...m, bang: 'A' })), 
                        ...state.matchesB.map(m => ({ ...m, bang: 'B' }))];
                        
    if (allMatches.length === 0) {
        showModal('Export Lịch', 'Không có lịch thi đấu để xuất.');
        return;
    }
    
    let csv = "teamA,teamB,time,court,bang,scoreA,scoreB\n";
    allMatches.forEach(match => {
        csv += `"${match.teamA}","${match.teamB}",${match.time || ''},${match.court || ''},${match.bang || ''},${match.scoreA !== null ? match.scoreA : ''},${match.scoreB !== null ? match.scoreB : ''}\n`;
    });

    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `schedule_tkd_export_${new Date().toISOString().slice(0, 10)}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    showModal('Export Lịch', 'Đã xuất lịch thi đấu Vòng Bảng ra file CSV.');
}


// --- Khởi tạo ---

/**
 * Hàm khởi tạo chính
 */
function init() {
    loadConfig();
    
    // Tải dữ liệu từ GitHub nếu có cấu hình
    if (state.config.owner && state.config.repo && state.config.token) {
        // Tải trạng thái và teams (nếu có)
        loadFromGitHub(); 
    } else {
        // Khởi tạo giao diện với dữ liệu mặc định (trống)
        tinhVaCapNhatXepHang(); 
        renderMatchesView(); 
        renderFinals();
        renderFinalResults();
        renderOverview();
        
        document.getElementById('autoState').className = 'text-danger';
        document.getElementById('autoState').textContent = 'Tắt (Thiếu Config)';
        updateStatus('configStatus', 'warning', 'Chưa cấu hình GitHub. Vui lòng nhập thông tin kết nối và nhấn "Lưu cấu hình Local".');
    }
}

// Bắt đầu ứng dụng khi DOM đã tải
document.addEventListener('DOMContentLoaded', init);

</script>
</body>
</html>
