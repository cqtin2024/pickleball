<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TKD Championship 2025 ‚Äî Qu·∫£n l√Ω gi·∫£i Pickleball V15 Ho√†n Ch·ªânh</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body { background:#f7f9fc; font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial; color:#222; padding:18px; }
    .tab-content { margin-top: 18px; }
    .logo { 
      width:64px; 
      height:64px; 
      object-fit:contain; 
      border-radius:8px; 
      border:1px solid #e6eefc; 
      padding:6px; 
      background:#fff; 
    }
    table th { background:#0d6efd; color:#fff; position:sticky; top:0; }
    .status { font-size:0.95rem; color:#555; }
    /* Responsive adjustment for match inputs */
    .match-score-cell input {
      width: 45px;
      text-align: center;
      padding: 0.1rem;
    }
    @media (max-width: 576px) {
      .match-score-cell input {
        width: 35px;
      }
    }
    .winner { font-weight: bold; color: green; }
    .loser { color: red; }
    .ranking-container { display: flex; flex-direction: column; gap: 20px; }
    @media (min-width: 768px) {
        .ranking-container { flex-direction: row; }
        .ranking-container > div { flex: 1; }
    }
    /* Th√™m style cho b·∫£ng x·∫øp h·∫°ng */
    .ranking-table th { background: #4a4a4a; color: white; }
    .ranking-table .rank-1 { background-color: #ffeb3b; font-weight: bold; }
    .ranking-table .rank-2 { background-color: #c0c0c0; font-weight: bold; }
  </style>
</head>
<body>
<div class="container">
  <div class="d-flex justify-content-between align-items-center mb-3">
    <div class="d-flex align-items-center gap-2">
      <img class="logo" src="data/logoTKD.png" alt="Logo TKD">
      <div>
        <h3 class="mb-0">TKD Championship 2025</h3>
        <div>Ng√†y thi ƒë·∫•u: 18/10/2025</div>
      </div>
    </div>
    <div>
      <div id="autoSaveStatus" class="text-end status">Auto-save: <span id="autoState" class="text-danger">T·∫Øt</span></div>
      <div id="lastSaved" class="text-end status">Ch∆∞a l∆∞u</div>
    </div>
  </div>

  <ul class="nav nav-tabs" id="mainTabs">
    <li class="nav-item"><button class="nav-link active" data-bs-toggle="tab" data-bs-target="#overview" onclick="renderOverview()">T·ªïng quan</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#matches" id="matchesTabButton" onclick="renderMatchesView()">V√≤ng B·∫£ng</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#finals">V√≤ng Chung K·∫øt</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#results">K·∫øt qu·∫£ Chung cu·ªôc</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#config" id="configTabButton" onclick="renderConfig()">C·∫•u h√¨nh</button></li>
  </ul>

  <div class="tab-content">
    <div class="tab-pane fade show active p-3" id="overview">
        <div id="overviewContent">ƒêang t·∫£i d·ªØ li·ªáu...</div>
    </div>
    
    <div class="tab-pane fade p-3" id="matches">
      <div class="d-flex gap-2 mb-3 flex-wrap">
        <label for="viewMode" class="form-label mb-0 align-self-center text-nowrap">Ch·∫ø ƒë·ªô xem:</label>
        <select id="viewMode" class="form-select form-select-sm w-auto" onchange="renderMatchesView()">
            <option value="table">Theo B·∫£ng ƒë·∫•u</option>
            <option value="court" selected>Theo S√¢n thi ƒë·∫•u</option>
        </select>
        
        <button class="btn btn-sm btn-info ms-auto" onclick="document.getElementById('fileInput').click()">Import L·ªãch (CSV)</button>
        <input type="file" id="fileInput" accept=".csv" style="display: none;" onchange="handleFileSelect(event)">
        
        <button class="btn btn-sm btn-warning" onclick="exportSchedule()">Export L·ªãch (CSV)</button>
      </div>
      
      <div id="matchesViewContent">
        <h6 id="scheduleAHeader" class="mt-4">B·∫£ng A (Nam - N·ªØ)</h6><div id="tableMatchesA">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u.</div>
        
        <h6 class="mt-4">B·∫£ng B (Nam)</h6><div id="tableMatchesB">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u.</div>
      </div>

      <button class="btn btn-warning mt-4" onclick="scheduleFinalsAuto()">L√™n l·ªãch V√≤ng Chung k·∫øt (T·ª± ƒë·ªông h√≥a)</button>
    </div>

    <div class="tab-pane fade p-3" id="finals">
        <div id="finalsContent">
            <h6 class="mt-4">V√≤ng B√°n k·∫øt (16:30, S√¢n 1-2)</h6>
            <div id="semifinalMatches">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u b√°n k·∫øt. K·∫øt qu·∫£ V√≤ng B·∫£ng s·∫Ω t·ª± ƒë·ªông c·∫≠p nh·∫≠t l·ªãch.</div>

            <h6 class="mt-4">Tr·∫≠n Chung k·∫øt (17:00, S√¢n 1)</h6>
            <div id="finalMatch">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u chung k·∫øt.</div>
        </div>
    </div>

    <div class="tab-pane fade p-3" id="results">
        <h5 class="mb-3">B·∫£ng x·∫øp h·∫°ng V√≤ng B·∫£ng (C·∫≠p nh·∫≠t li√™n t·ª•c)</h5>
        <div id="rankingTables" class="ranking-container">
            </div>

        <hr class="my-4">

        <h5 class="mb-3">Danh hi·ªáu Chung cu·ªôc</h5>
        <p id="champion">V√¥ ƒë·ªãch: ƒêang ch·ªù k·∫øt qu·∫£...</p>
        <p id="runnerUp">√Å qu√¢n: ƒêang ch·ªù k·∫øt qu·∫£...</p>
        <p id="thirdPlace">H·∫°ng Ba ƒê·ªìng H·∫°ng: ƒêang ch·ªù k·∫øt qu·∫£...</p>
    </div>

    <div class="tab-pane fade p-3" id="config">
      <h5 class="mb-3">C√¥ng c·ª• L·∫≠p & ƒêi·ªÅn L·ªãch Thi ƒë·∫•u</h5>
      <div class="d-flex gap-2 mb-4 flex-wrap">
        <button class="btn btn-sm btn-primary" onclick="taoLichThiDauCungGio()">T·∫°o l·ªãch thi ƒë·∫•u T·ªëi ∆∞u (T·ª± ƒë·ªông)</button>
        <button class="btn btn-sm btn-secondary" onclick="taoLichCoDinh()">T·∫°o l·ªãch C·ªë ƒë·ªãnh</button>
        <button class="btn btn-sm btn-success" onclick="autoFillScores()">ƒêi·ªÅn k·∫øt qu·∫£ T·ª± ƒë·ªông (11 - X)</button>
        <button class="btn btn-sm btn-danger" onclick="clearAllSchedules()">X√≥a To√†n b·ªô L·ªãch</button>
      </div>
      
      <hr>

      <h5 class="mt-4">‚öôÔ∏è C·∫•u h√¨nh S√¢n thi ƒë·∫•u & L·ªãch T·ªëi ∆∞u</h5>
      <p class="text-muted small">Qu·∫£n l√Ω danh s√°ch s√¢n thi ƒë·∫•u. S√¢n ƒë∆∞·ª£c g√°n lo·∫°i b·∫£ng ƒë·∫•u (A/B) ƒë·ªÉ ph·ª•c v·ª• ch·ª©c nƒÉng t·∫°o l·ªãch T·ªëi ∆∞u.</p>
      <div class="d-flex gap-2 mb-3 flex-wrap">
          <button class="btn btn-sm btn-primary" onclick="openCourtModal()">+ Th√™m S√¢n M·ªõi</button>
          <button class="btn btn-sm btn-outline-info" onclick="loadDefaultCourtConfig()">T·∫£i c·∫•u h√¨nh M·∫∑c ƒë·ªãnh</button>
      </div>
      <div id="courtListContainer">
          </div>
      <div id="courtConfigStatus"></div>
      <hr>

      <h5 class="mt-4">üíæ C·∫•u h√¨nh K·∫øt n·ªëi GitHub</h5>
      <p class="text-muted">Nh·∫≠p th√¥ng tin kho l∆∞u tr·ªØ GitHub ƒë·ªÉ t·ª± ƒë·ªông l∆∞u tr·ªØ d·ªØ li·ªáu gi·∫£i ƒë·∫•u.</p>
      <div class="row g-2 mb-2">
        <div class="col-md-3"><input id="cfgOwner" class="form-control" placeholder="Owner (V√≠ d·ª•: user_name)"></div>
        <div class="col-md-3"><input id="cfgRepo" class="form-control" placeholder="Repo (V√≠ d·ª•: my-data-repo)"></div>
        <div class="col-md-3"><input id="cfgFolder" class="form-control" value="data"></div>
        <div class="col-md-3"><input id="cfgFile" class="form-control" value="state.json"></div>
      </div>
      <input id="cfgToken" type="password" class="form-control mb-2" placeholder="D√°n GitHub Personal Access Token (PAT) t·∫°i ƒë√¢y">
      <div class="d-flex gap-2">
        <button class="btn btn-primary" onclick="saveConfig()">L∆∞u c·∫•u h√¨nh Local</button>
        <button class="btn btn-success" onclick="checkConnection()">Ki·ªÉm tra & T·∫£i D·ªØ li·ªáu</button>
      </div>
      <div class="mt-2" id="configStatus"></div>
      
      <div class="card bg-light mt-4 shadow-sm">
        <div class="card-body">
            <h5 class="card-title text-info">üîë H∆∞·ªõng d·∫´n l·∫•y GitHub Token (PAT)</h5>
            <ol class="small mb-0">
                <li>Truy c·∫≠p <a href="https://github.com/settings/tokens" target="_blank" class="text-info">GitHub Tokens Settings</a> (B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p).</li>
                <li>Ch·ªçn **Generate new token** (ho·∫∑c **Generate new token (classic)** n·∫øu b·∫°n d√πng t√†i kho·∫£n c≈©).</li>
                <li>**T√™n Token:** ƒê·∫∑t t√™n d·ªÖ nh·ªõ (v√≠ d·ª•: `TKDManager_AutoSave`).</li>
                <li>**Th·ªùi h·∫°n:** Ch·ªçn t√πy √Ω (n√™n ch·ªçn 90 ng√†y ho·∫∑c T√πy ch·ªânh).</li>
                <li>**Ph·∫°m vi (Scopes):** **B·∫ÆT BU·ªòC** t√≠ch ch·ªçn √¥ **`repo`** (cho ph√©p truy c·∫≠p v√†o kho l∆∞u tr·ªØ).</li>
                <li>Nh·∫•n **Generate token** v√† **SAO CH√âP** chu·ªói Token v·ª´a ƒë∆∞·ª£c t·∫°o.</li>
                <li>D√°n chu·ªói Token ƒë√≥ v√†o √¥ "D√°n GitHub Personal Access Token (PAT) t·∫°i ƒë√¢y" b√™n tr√™n.</li>
            </ol>
            <p class="mt-2 mb-0 text-danger small">‚ö†Ô∏è **L∆∞u √Ω:** Token ch·ªâ hi·ªÉn th·ªã **M·ªòT L·∫¶N**. H√£y sao ch√©p ngay l·∫≠p t·ª©c v√† gi·ªØ b√≠ m·∫≠t. N·∫øu m·∫•t, b·∫°n ph·∫£i t·∫°o l·∫°i Token m·ªõi.</p>
        </div>
      </div>
      </div>
  </div>
</div>

<div class="modal fade" id="courtModal" tabindex="-1" aria-labelledby="courtModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="courtModalLabel">Th√™m/S·ª≠a C·∫•u h√¨nh S√¢n</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="courtForm">
          <input type="hidden" id="courtIndex" value="">
          <div class="mb-3">
            <label for="courtName" class="form-label">T√™n S√¢n</label>
            <input type="text" class="form-control" id="courtName" required>
          </div>
          <div class="mb-3">
            <label for="courtStartTime" class="form-label">Gi·ªù B·∫Øt ƒê·∫ßu (HH:mm)</label>
            <input type="time" class="form-control" id="courtStartTime" required>
          </div>
          <div class="mb-3">
            <label for="courtMaxDuration" class="form-label">Th·ªùi L∆∞·ª£ng T·ªëi ƒêa (Ph√∫t)</label>
            <input type="number" class="form-control" id="courtMaxDuration" min="1" required>
          </div>
          <div class="form-check mb-3">
            <input class="form-check-input" type="checkbox" id="courtIsMixed">
            <label class="form-check-label" for="courtIsMixed">
              D√†nh cho B·∫£ng A (Nam - N·ªØ)
            </label>
            <div class="form-text">N·∫øu kh√¥ng ch·ªçn, s√¢n s·∫Ω d√†nh cho B·∫£ng B (Nam).</div>
          </div>
          <div id="courtFormStatus" class="mt-2"></div>
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">H·ªßy</button>
        <button type="button" class="btn btn-primary" onclick="saveCourtChanges()">L∆∞u Thay ƒê·ªïi</button>
      </div>
    </div>
  </div>
</div>
<div class="modal fade" id="customAlertModal" tabindex="-1" aria-labelledby="customAlertModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="customAlertModalLabel">Th√¥ng b√°o</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="customAlertModalBody">
        N·ªôi dung th√¥ng b√°o
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-primary" data-bs-dismiss="modal">ƒê√≥ng</button>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
<script>
// --- C·∫§U TR√öC CSV TH·ªêNG NH·∫§T ---
// D·ªØ li·ªáu l·ªãch c·ªë ƒë·ªãnh (FIXED_SCHEDULE_CSV) theo c·∫•u tr√∫c teamA,teamB,time,court,bang,scoreA,scoreB
const FIXED_SCHEDULE_CSV = `teamA,teamB,time,court,bang,scoreA,scoreB
Tri·ªÅu/Minh,Hi·ªÉn/P.H√πng,14:00,S√¢n 1,B,,
Giang/Long,H∆∞·ªùng/ƒê·∫°t,14:00,S√¢n 2,A,,
H·∫≠u/D≈©ng,H·∫°nh/Ti·∫øn,14:00,S√¢n 3,A,,
Huy·ªÅn/Lu√¢n,Linh/M.H√πng,14:00,S√¢n7,A,,
Ti·ªáp/Th·ªßy,Ph∆∞∆°ng/Thanh,14:15,S√¢n 1,B,,
T√≠n/Khi√™m,√Ånh/To√†n,14:15,S√¢n 2,B,,
H·∫≠u/D≈©ng,H∆∞·ªùng/ƒê·∫°t,14:15,S√¢n 3,A,,
Giang/Long,Huy·ªÅn/Lu√¢n,14:15,S√¢n7,A,,
Tri·ªÅu/Minh,T√≠n/Khi√™m,14:30,S√¢n 1,B,,
Ti·ªáp/Th·ªßy,Hi·ªÉn/P.H√πng,14:30,S√¢n 2,B,,
H·∫°nh/Ti·∫øn,Linh/M.H√πng,14:30,S√¢n 3,A,,
Ph∆∞∆°ng/Thanh,√Ånh/To√†n,14:30,S√¢n7,B,,
Huy·ªÅn/Lu√¢n,H∆∞·ªùng/ƒê·∫°t,14:45,S√¢n 2,A,,
H·∫°nh/Ti·∫øn,Giang/Long,14:45,S√¢n 3,A,,
H·∫≠u/D≈©ng,Linh/M.H√πng,14:45,S√¢n7,A,,
Ti·ªáp/Th·ªßy,√Ånh/To√†n,15:00,S√¢n 2,B,,
T√≠n/Khi√™m,Hi·ªÉn/P.H√πng,15:00,S√¢n 3,B,,
Ph∆∞∆°ng/Thanh,Tri·ªÅu/Minh,15:15,S√¢n 2,B,,
Giang/Long,Linh/M.H√πng,15:15,S√¢n 3,A,,
H·∫°nh/Ti·∫øn,H∆∞·ªùng/ƒê·∫°t,15:30,S√¢n 2,A,,
H·∫≠u/D≈©ng,Huy·ªÅn/Lu√¢n,15:30,S√¢n 3,A,,
Ti·ªáp/Th·ªßy,T√≠n/Khi√™m,15:45,S√¢n 2,B,,
Ph∆∞∆°ng/Thanh,Hi·ªÉn/P.H√πng,15:45,S√¢n 3,B,,
Tri·ªÅu/Minh,√Ånh/To√†n,16:00,S√¢n 2,B,,
H·∫≠u/D≈©ng,Giang/Long,16:00,S√¢n 3,A,,
H·∫°nh/Ti·∫øn,Huy·ªÅn/Lu√¢n,16:15,S√¢n 2,A,,
Linh/M.H√πng,H∆∞·ªùng/ƒê·∫°t,16:15,S√¢n 3,A,,
Ti·ªáp/Th·ªßy,Tri·ªÅu/Minh,16:30,S√¢n 2,B,,
√Ånh/To√†n,Hi·ªÉn/P.H√πng,16:30,S√¢n 3,B,,
Ph∆∞∆°ng/Thanh,T√≠n/Khi√™m,16:45,S√¢n 2,B,,
`;

let state = { 
  mixedTeams: ['Giang/Long', 'H∆∞·ªùng/ƒê·∫°t', 'H·∫≠u/D≈©ng', 'H·∫°nh/Ti·∫øn', 'Huy·ªÅn/Lu√¢n', 'Linh/M.H√πng'],
  maleTeams: ['Tri·ªÅu/Minh', 'Hi·ªÉn/P.H√πng', 'Ti·ªáp/Th·ªßy', 'Ph∆∞∆°ng/Thanh', 'T√≠n/Khi√™m', '√Ånh/To√†n'],  
  matchesA: [], 
  matchesB: [],
  tableA: [], 
  tableB: [], 
  
  courts: [
    { name: 'S√¢n 1', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, 
    { name: 'S√¢n 2', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, 
    { name: 'S√¢n 3', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }, 
    { name: 'S√¢n 7', startTime: '14:00', maxDurationMinutes: 180, isMixed: false } 
  ],
  
  semifinals: [
    { id: 'SF1', teamA: 'Nh·∫•t A', teamB: 'Nh·∫•t B', scoreA: null, scoreB: null, time: '16:30', court: 'S√¢n 1', winner: null, loser: null, bang: 'Finals' },
    { id: 'SF2', teamA: 'Nh√¨ B', teamB: 'Nh√¨ A', scoreA: null, scoreB: null, time: '16:30', court: 'S√¢n 2', winner: null, loser: null, bang: 'Finals' }
  ],
  final: { id: 'F', teamA: 'Th·∫Øng SF1', teamB: 'Th·∫Øng SF2', scoreA: null, scoreB: null, time: '17:00', court: 'S√¢n 1', winner: null, runnerUp: null, bang: 'Finals' },
  config: {}
};

let stateChanged = false;
let currentSha = null;
let autoSaveInterval = null;

// --- Helper Functions ---

function showModal(title, body) {
    document.getElementById('customAlertModalLabel').textContent = title;
    document.getElementById('customAlertModalBody').innerHTML = body;
    const modal = new bootstrap.Modal(document.getElementById('customAlertModal'));
    modal.show();
}

function parseTime(timeStr) {
    if (!timeStr) return 0;
    const [hours, minutes] = timeStr.split(':').map(Number);
    return hours * 60 + minutes;
}

function formatTime(minutes) {
    const h = Math.floor(minutes / 60);
    const m = minutes % 60;
    return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
}

// --- Base64 Helpers for GitHub ---
function b64EncodeUnicode(str) {
  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g,
    function(match, p1) {
      return String.fromCharCode('0x' + p1);
    }));
}

function b64DecodeUnicode(str) {
  return decodeURIComponent(atob(str).split('').map(function(c) {
    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
  }).join(''));
}

// --- GitHub API Functions (HO√ÄN CH·ªàNH) ---

/**
 * L·∫•y SHA m·ªõi nh·∫•t c·ªßa file tr√™n GitHub v√† n·ªôi dung (n·∫øu c√≥).
 * @param {object} cfg - C·∫•u h√¨nh GitHub.
 * @param {string} fileName - T√™n file (state.json ho·∫∑c players.json)
 * @returns {Promise<{sha: string|null, content: string|null}>}
 */
async function fetchFileSha(cfg, fileName) {
    const filePath = `${cfg.folder}/${fileName}`;
    const apiUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}/contents/${filePath}`;
    
    try {
        const response = await fetch(apiUrl, {
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });
        
        if (response.ok) {
            const data = await response.json();
            if (fileName === cfg.file) {
                 currentSha = data.sha; // Ch·ªâ l∆∞u SHA c·ªßa state.json
            }
            return { sha: data.sha, content: data.content };
        } else if (response.status === 404) {
            if (fileName === cfg.file) {
                 currentSha = null; 
            }
            return { sha: null, content: null };
        } else {
            throw new Error(`L·ªói khi l·∫•y SHA: ${response.statusText}`);
        }
    } catch (error) {
        console.error(`L·ªói Fetch SHA (${fileName}):`, error);
        throw new Error(`L·ªói k·∫øt n·ªëi ho·∫∑c API: ${error.message}`);
    }
}

/**
 * T·∫£i danh s√°ch ƒë·ªôi t·ª´ players.json
 */
async function loadPlayersFromGitHub(cfg) {
    const fileName = 'players.json';
    try {
        updateStatus('configStatus', 'info', 'ƒêang t·∫£i danh s√°ch ƒë·ªôi t·ª´ GitHub (players.json)...');
        const result = await fetchFileSha(cfg, fileName); 
        
        if (result.content) {
            const jsonString = b64DecodeUnicode(result.content);
            const loadedTeams = JSON.parse(jsonString);

            if (Array.isArray(loadedTeams.mixedTeams) && Array.isArray(loadedTeams.maleTeams)) {
                state.mixedTeams = loadedTeams.mixedTeams;
                state.maleTeams = loadedTeams.maleTeams;
                updateStatus('configStatus', 'success', `T·∫£i danh s√°ch ƒë·ªôi th√†nh c√¥ng (${state.mixedTeams.length + state.maleTeams.length} ƒë·ªôi).`);
                return true;
            } else {
                throw new Error("File players.json kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng.");
            }
        } else {
            updateStatus('configStatus', 'warning', 'Kh√¥ng t√¨m th·∫•y file players.json. D√πng danh s√°ch ƒë·ªôi kh·ªüi t·∫°o.');
            return false;
        }
    } catch (error) {
        console.error("L·ªói khi t·∫£i players.json:", error);
        updateStatus('configStatus', 'danger', `L·ªói t·∫£i danh s√°ch ƒë·ªôi: ${error.message}`);
        return false;
    }
}

/**
 * T·∫£i tr·∫°ng th√°i gi·∫£i ƒë·∫•u (state.json) t·ª´ GitHub.
 */
async function loadFromGitHub() {
    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) return;

    // 1. Load Teams (danh s√°ch ƒë·ªôi) - ∆Øu ti√™n load tr∆∞·ªõc
    await loadPlayersFromGitHub(cfg); 

    // 2. Load App State (state.json)
    try {
        updateStatus('configStatus', 'info', 'ƒêang t·∫£i tr·∫°ng th√°i gi·∫£i ƒë·∫•u t·ª´ GitHub (state.json)...');
        const result = await fetchFileSha(cfg, cfg.file); 
        
        if (result.content) {
            const jsonString = b64DecodeUnicode(result.content);
            const loadedState = JSON.parse(jsonString);

            // Ghi ƒë√® c√°c gi√° tr·ªã
            state.matchesA = loadedState.matchesA || [];
            state.matchesB = loadedState.matchesB || [];
            if (loadedState.courts) state.courts = loadedState.courts;
            if (loadedState.semifinals) state.semifinals = loadedState.semifinals;
            if (loadedState.final) state.final = loadedState.final;
            
            // C·∫≠p nh·∫≠t giao di·ªán
            tinhVaCapNhatXepHang(); // T·ª± ƒë·ªông g·ªçi renderRankingTable
            renderMatchesView(); 
            renderFinals();
            renderFinalResults();
            renderOverview();
            
            updateStatus('configStatus', 'success', `T·∫£i tr·∫°ng th√°i gi·∫£i ƒë·∫•u th√†nh c√¥ng.`);
            document.getElementById('lastSaved').textContent = `L·∫ßn t·∫£i: ${new Date().toLocaleTimeString('vi-VN')}`;
        } else {
            updateStatus('configStatus', 'warning', 'File tr·∫°ng th√°i (state.json) ch∆∞a t·ªìn t·∫°i. ƒêang d√πng l·ªãch c·ªë ƒë·ªãnh.');
            taoLichCoDinh(true); // T·∫£i l·ªãch c·ªë ƒë·ªãnh m√† kh√¥ng hi·ªán modal
        }

        startAutoSave();

    } catch (error) {
        updateStatus('configStatus', 'danger', `L·ªói t·∫£i tr·∫°ng th√°i gi·∫£i ƒë·∫•u: ${error.message}. Vui l√≤ng ki·ªÉm tra l·∫°i Token/Repo.`);
        console.error("L·ªói khi t·∫£i tr·∫°ng th√°i gi·∫£i ƒë·∫•u t·ª´ GitHub:", error);
    }
}

async function saveToGitHub() {
    if (!stateChanged) return;

    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) return;

    document.getElementById('autoState').className = 'text-info';
    document.getElementById('autoState').textContent = 'ƒêang l∆∞u...';

    const apiUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}/contents/${cfg.folder}/${cfg.file}`;
    
    const stateToSave = {
        mixedTeams: state.mixedTeams, // Teams ƒë∆∞·ª£c l∆∞u c√πng state ƒë·ªÉ ƒë·ªìng b·ªô
        maleTeams: state.maleTeams,
        matchesA: state.matchesA,
        matchesB: state.matchesB,
        courts: state.courts,
        semifinals: state.semifinals,
        final: state.final
    };
    const content = b64EncodeUnicode(JSON.stringify(stateToSave));
    
    try {
        const payload = {
            message: `[Auto-save] C·∫≠p nh·∫≠t tr·∫°ng th√°i gi·∫£i ƒë·∫•u TKD l√∫c ${new Date().toLocaleString('vi-VN')}`,
            content: content
        };
        
        // S·ª≠ d·ª•ng SHA hi·ªán t·∫°i (ƒë∆∞·ª£c c·∫≠p nh·∫≠t b·ªüi fetchFileSha trong l·∫ßn tr∆∞·ªõc ƒë√≥)
        if (currentSha) {
             payload.sha = currentSha;
        }

        const response = await fetch(apiUrl, {
            method: 'PUT',
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Content-Type': 'application/json',
                'Accept': 'application/vnd.github.v3+json'
            },
            body: JSON.stringify(payload)
        });

        if (response.ok) {
            const data = await response.json();
            currentSha = data.content.sha;
            stateChanged = false;
            document.getElementById('lastSaved').textContent = `L·∫ßn l∆∞u: ${new Date().toLocaleTimeString('vi-VN')}`;
            document.getElementById('autoState').className = 'text-success';
            document.getElementById('autoState').textContent = 'ƒê√£ L∆∞u';
        } else {
            if (response.status === 409) {
                // Conflict, c·ªë g·∫Øng l·∫•y SHA m·ªõi nh·∫•t ƒë·ªÉ th·ª≠ l·∫°i l·∫ßn sau
                await fetchFileSha(cfg, cfg.file); 
                document.getElementById('autoState').className = 'text-warning';
                document.getElementById('autoState').textContent = 'Conflict. S·∫Ω th·ª≠ l∆∞u l·∫°i sau 1 ph√∫t.';
            } else {
                throw new Error(`L·ªói HTTP: ${response.status} - ${response.statusText}`);
            }
        }
    } catch (error) {
        console.error("L·ªói khi l∆∞u l√™n GitHub:", error);
        document.getElementById('autoState').className = 'text-danger';
        document.getElementById('autoState').textContent = 'L·ªói L∆∞u';
    }
}

async function checkConnection() {
    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) {
        updateStatus('configStatus', 'warning', 'Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß Owner, Repo v√† Token.');
        return;
    }

    try {
        updateStatus('configStatus', 'info', 'ƒêang ki·ªÉm tra k·∫øt n·ªëi...');
        
        const repoCheckUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}`;
        const repoResponse = await fetch(repoCheckUrl, {
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });

        if (!repoResponse.ok) {
            throw new Error(`L·ªói truy c·∫≠p kho l∆∞u tr·ªØ. M√£: ${repoResponse.status}. (Ki·ªÉm tra Token/Repo/Owner)`);
        }
        
        updateStatus('configStatus', 'success', 'K·∫øt n·ªëi GitHub th√†nh c√¥ng! ƒêang t·∫£i d·ªØ li·ªáu...');
        await loadFromGitHub();

    } catch (error) {
        updateStatus('configStatus', 'danger', `Ki·ªÉm tra k·∫øt n·ªëi th·∫•t b·∫°i: ${error.message}.`);
        console.error("L·ªói ki·ªÉm tra k·∫øt n·ªëi:", error);
    }
}

// --- Config & Utility Functions ---

function loadConfig() {
    const savedConfig = localStorage.getItem('pkb_config');
    if (savedConfig) {
        state.config = JSON.parse(savedConfig);
        document.getElementById('cfgOwner').value = state.config.owner || '';
        document.getElementById('cfgRepo').value = state.config.repo || '';
        document.getElementById('cfgFolder').value = state.config.folder || 'data';
        document.getElementById('cfgFile').value = state.config.file || 'state.json';
        document.getElementById('cfgToken').value = state.config.token || '';
    }
}

function saveConfig(){
    const cfg = {
        owner: document.getElementById('cfgOwner').value,
        repo: document.getElementById('cfgRepo').value,
        folder: document.getElementById('cfgFolder').value,
        file: document.getElementById('cfgFile').value,
        token: document.getElementById('cfgToken').value
    };
    state.config = cfg;
    localStorage.setItem('pkb_config', JSON.stringify(cfg));
    updateStatus('configStatus', 'success', 'ƒê√£ l∆∞u c·∫•u h√¨nh GitHub v√†o tr√¨nh duy·ªát. Vui l√≤ng Ki·ªÉm tra & T·∫£i D·ªØ li·ªáu.');
}

function updateStatus(id, type, message) {
    const statusDiv = document.getElementById(id);
    statusDiv.innerHTML = `<div class="alert alert-${type} p-2 mt-2">${message}</div>`;
}

function startAutoSave() {
    if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
    }
    if (state.config.token && state.config.owner && state.config.repo) {
        autoSaveInterval = setInterval(saveToGitHub, 60000);
        document.getElementById('autoState').className = 'text-warning';
        document.getElementById('autoState').textContent = 'Ho·∫°t ƒë·ªông...';
    } else {
        document.getElementById('autoState').className = 'text-danger';
        document.getElementById('autoState').textContent = 'T·∫Øt';
    }
}

// --- Court Configuration Functions (HO√ÄN CH·ªàNH) ---

function renderConfig() {
    renderCourtList();
    document.getElementById('courtConfigStatus').innerHTML = '';
}

function renderCourtList() {
    const container = document.getElementById('courtListContainer');
    if (!container) return;
    
    if (state.courts.length === 0) {
        container.innerHTML = `<div class="alert alert-warning">Ch∆∞a c√≥ s√¢n n√†o ƒë∆∞·ª£c c·∫•u h√¨nh.</div>`;
        return;
    }
    
    let html = `<div class='table-responsive'><table class='table table-striped table-sm'>
        <thead>
            <tr>
                <th>T√™n S√¢n</th>
                <th>Gi·ªù B·∫Øt ƒê·∫ßu</th>
                <th>Th·ªùi L∆∞·ª£ng Max (Ph√∫t)</th>
                <th>Ph√¢n Lo·∫°i</th>
                <th class="text-center">H√†nh ƒë·ªông</th>
            </tr>
        </thead>
        <tbody>`;
        
    state.courts.forEach((court, index) => {
        const type = court.isMixed ? 'B·∫£ng A (Nam-N·ªØ)' : 'B·∫£ng B (Nam)';
        const typeClass = court.isMixed ? 'badge bg-primary' : 'badge bg-info';
        
        html += `<tr>
            <td>${court.name}</td>
            <td>${court.startTime}</td>
            <td>${court.maxDurationMinutes}</td>
            <td><span class="${typeClass}">${type}</span></td>
            <td class="text-center">
                <button class="btn btn-sm btn-outline-secondary me-1" onclick="openCourtModal(${index})">S·ª≠a</button>
                <button class="btn btn-sm btn-outline-danger" onclick="deleteCourt(${index})">X√≥a</button>
            </td>
        </tr>`;
    });
    
    html += `</tbody></table></div>`;
    container.innerHTML = html;
}

function openCourtModal(index = null) {
    const modal = new bootstrap.Modal(document.getElementById('courtModal'));
    document.getElementById('courtFormStatus').innerHTML = '';

    document.getElementById('courtIndex').value = index !== null ? index : '';
    document.getElementById('courtModalLabel').textContent = index !== null ? 'S·ª≠a C·∫•u h√¨nh S√¢n' : 'Th√™m S√¢n M·ªõi';

    if (index !== null) {
        const court = state.courts[index];
        document.getElementById('courtName').value = court.name || '';
        document.getElementById('courtStartTime').value = court.startTime || '14:00';
        document.getElementById('courtMaxDuration').value = court.maxDurationMinutes || 180;
        document.getElementById('courtIsMixed').checked = court.isMixed || false;
    } else {
        document.getElementById('courtName').value = '';
        document.getElementById('courtStartTime').value = '14:00';
        document.getElementById('courtMaxDuration').value = '180';
        document.getElementById('courtIsMixed').checked = true;
    }

    modal.show();
}

function saveCourtChanges() {
    const indexStr = document.getElementById('courtIndex').value;
    const index = indexStr === '' ? null : parseInt(indexStr);
    
    const name = document.getElementById('courtName').value.trim();
    const startTime = document.getElementById('courtStartTime').value;
    const maxDurationMinutes = parseInt(document.getElementById('courtMaxDuration').value);
    const isMixed = document.getElementById('courtIsMixed').checked;

    const statusDiv = document.getElementById('courtFormStatus');

    if (!name || !startTime || isNaN(maxDurationMinutes) || maxDurationMinutes <= 0) {
        statusDiv.innerHTML = `<div class="alert alert-danger p-2">Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß v√† h·ª£p l·ªá c√°c tr∆∞·ªùng.</div>`;
        return;
    }
    
    const isDuplicate = state.courts.some((c, i) => 
        i !== index && c.name.toLowerCase() === name.toLowerCase()
    );

    if (isDuplicate) {
         statusDiv.innerHTML = `<div class="alert alert-danger p-2">T√™n s√¢n "${name}" ƒë√£ t·ªìn t·∫°i.</div>`;
        return;
    }

    const newCourt = { 
        name, 
        startTime, 
        maxDurationMinutes, 
        isMixed 
    };

    if (index !== null) {
        state.courts[index] = newCourt;
    } else {
        state.courts.push(newCourt);
    }
    
    bootstrap.Modal.getInstance(document.getElementById('courtModal')).hide();

    renderCourtList();
    stateChanged = true;
    updateStatus('courtConfigStatus', 'success', `ƒê√£ ${index !== null ? 'c·∫≠p nh·∫≠t' : 'th√™m'} s√¢n "${name}".`);
    saveToGitHub();
}

function deleteCourt(index) {
    if (confirm(`B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a s√¢n "${state.courts[index].name}"?`)) {
        const deletedCourtName = state.courts[index].name;
        state.courts.splice(index, 1);
        
        renderCourtList();
        stateChanged = true;
        updateStatus('courtConfigStatus', 'success', `ƒê√£ x√≥a s√¢n "${deletedCourtName}".`);
        saveToGitHub();
    }
}

function loadDefaultCourtConfig() {
    state.courts = [
        { name: 'S√¢n 1', startTime: '14:00', maxDurationMinutes: 180, isMixed: true },
        { name: 'S√¢n 2', startTime: '14:00', maxDurationMinutes: 180, isMixed: true },
        { name: 'S√¢n 3', startTime: '14:00', maxDurationMinutes: 180, isMixed: false },
        { name: 'S√¢n 4', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }
    ];
    
    renderCourtList();
    stateChanged = true;
    updateStatus('courtConfigStatus', 'success', 'ƒê√£ t·∫£i c·∫•u h√¨nh s√¢n M·∫∑c ƒë·ªãnh.');
    saveToGitHub();
}


// --- L·ªãch Thi ƒê·∫•u & X·∫øp H·∫°ng ---

/**
 * Ph√¢n t√≠ch n·ªôi dung CSV theo ƒë·ªãnh d·∫°ng th·ªëng nh·∫•t: teamA,teamB,time,court,bang,scoreA,scoreB
 */
function parseUnifiedSchedule(csvContent) {
    const newMatchesA = [];
    const newMatchesB = [];
    const rows = csvContent.trim().split('\n');
    
    const expectedHeader = 'teamA,teamB,time,court,bang,scoreA,scoreB';
    if (rows.length === 0) throw new Error("File CSV r·ªóng.");

    const headers = rows[0].trim().split(',');
    if (headers.join(',').toLowerCase() !== expectedHeader.toLowerCase()) {
        throw new Error(`Header CSV kh√¥ng kh·ªõp ƒë·ªãnh d·∫°ng chu·∫©n: ${expectedHeader}. T√¨m th·∫•y: ${rows[0].trim()}`);
    }
    
    let idA = 1;
    let idB = 1;

    for (let i = 1; i < rows.length; i++) {
        const row = rows[i].trim();
        if (!row) continue;
        
        const cols = row.split(',');
        if (cols.length !== 7) continue;

        const match = {
            id: null,
            teamA: cols[0].trim(),
            teamB: cols[1].trim(),
            time: cols[2].trim(),
            court: cols[3].trim(),
            bang: cols[4].trim().toUpperCase(),
            scoreA: cols[5].trim() === '' ? null : parseInt(cols[5].trim(), 10),
            scoreB: cols[6].trim() === '' ? null : parseInt(cols[6].trim(), 10),
            winner: null
        };
        
        if (!match.teamA || !match.teamB || !['A', 'B'].includes(match.bang)) continue;

        if (match.bang === 'A') {
            match.id = 'A' + (idA++);
            newMatchesA.push(match);
        } else if (match.bang === 'B') {
            match.id = 'B' + (idB++);
            newMatchesB.push(match);
        }
    }
    
    state.matchesA = newMatchesA;
    state.matchesB = newMatchesB;
    stateChanged = true;
    return newMatchesA.length + newMatchesB.length;
}

/**
 * T·∫£i l·ªãch c·ªë ƒë·ªãnh (c√≥ th·ªÉ b·ªè qua modal th√¥ng b√°o n·∫øu g·ªçi t·ª´ loadFromGitHub)
 */
function taoLichCoDinh(skipAlert = false) {
    try {
        const count = parseUnifiedSchedule(FIXED_SCHEDULE_CSV); 
        
        if (count > 0) {
            if (!skipAlert) showModal('T·∫°o L·ªãch C·ªë ƒê·ªãnh Th√†nh C√¥ng', `ƒê√£ t·∫°o ${count} tr·∫≠n ƒë·∫•u t·ª´ l·ªãch c·ªë ƒë·ªãnh.`);
            tinhVaCapNhatXepHang();
            renderMatchesView(); 
            renderOverview();
            saveToGitHub();
        } else {
            if (!skipAlert) showModal('C·∫£nh B√°o', 'Kh√¥ng c√≥ tr·∫≠n ƒë·∫•u n√†o ƒë∆∞·ª£c t·∫°o. Vui l√≤ng ki·ªÉm tra l·∫°i FIXED_SCHEDULE_CSV.');
        }
    } catch (e) {
        if (!skipAlert) showModal('L·ªói T·∫°o L·ªãch C·ªë ƒê·ªãnh', `L·ªói khi x·ª≠ l√Ω FIXED_SCHEDULE_CSV: ${e.message}`);
    }
}

function handleFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const csvContent = e.target.result;
            const count = parseUnifiedSchedule(csvContent); 
            
            showModal('Import Th√†nh C√¥ng', `ƒê√£ nh·∫≠p th√†nh c√¥ng ${count} tr·∫≠n ƒë·∫•u t·ª´ file CSV.`);
            tinhVaCapNhatXepHang();
            renderMatchesView(); 
            renderOverview();
            saveToGitHub();
        } catch (error) {
            showModal('L·ªói Import CSV', `Kh√¥ng th·ªÉ x·ª≠ l√Ω file CSV: ${error.message}`);
        }
    };
    reader.readAsText(file, 'UTF-8');
    event.target.value = ''; 
}

function updateScore(matchId, scoreA, scoreB, isFinals = false) {
    let match;
    
    if (isFinals) {
        if (state.final.id === matchId) {
            match = state.final;
        } else {
            match = state.semifinals.find(m => m.id === matchId);
        }
    } else {
        match = [...state.matchesA, ...state.matchesB].find(m => m.id === matchId);
    }

    if (!match) return;

    const sA = parseInt(scoreA, 10);
    const sB = parseInt(scoreB, 10);
    
    if (isNaN(sA) || isNaN(sB) || sA < 0 || sB < 0) return;

    match.scoreA = sA;
    match.scoreB = sB;

    if (sA !== null && sB !== null) {
        if (sA > sB) {
            match.winner = match.teamA;
            if (isFinals) match.loser = match.teamB;
        } else if (sB > sA) {
            match.winner = match.teamB;
            if (isFinals) match.loser = match.teamA;
        } else {
            match.winner = null;
            match.loser = null;
        }
    } else {
        match.winner = null;
        match.loser = null;
    }

    stateChanged = true;
    
    if (!isFinals) {
        tinhVaCapNhatXepHang();
        renderMatchesView();
    } else {
        scheduleFinalsAuto(true); // C·∫≠p nh·∫≠t chung k·∫øt n·∫øu b√°n k·∫øt c√≥ k·∫øt qu·∫£
        renderFinals();
        renderFinalResults();
    }
    saveToGitHub();
}

function tinhVaCapNhatXepHang() {
    const teamsA = Array.from(new Set(state.matchesA.flatMap(m => [m.teamA, m.teamB])));
    const teamsB = Array.from(new Set(state.matchesB.flatMap(m => [m.teamA, m.teamB])));

    state.tableA = calculateRanking(teamsA, state.matchesA);
    state.tableB = calculateRanking(teamsB, state.matchesB);

    scheduleFinalsAuto(true); // C·∫≠p nh·∫≠t B√°n k·∫øt/Chung k·∫øt
    renderRankingTable();
}

function calculateRanking(teams, matches) {
    const stats = {};
    teams.forEach(team => {
        stats[team] = { team, W: 0, L: 0, PS: 0, PA: 0, PD: 0, matchesPlayed: 0 };
    });

    matches.forEach(match => {
        if (match.scoreA !== null && match.scoreB !== null) {
            const statA = stats[match.teamA];
            const statB = stats[match.teamB];

            if (statA && statB) {
                statA.matchesPlayed++;
                statB.matchesPlayed++;

                statA.PS += match.scoreA;
                statA.PA += match.scoreB;
                statB.PS += match.scoreB;
                statB.PA += match.scoreA;

                if (match.scoreA > match.scoreB) {
                    statA.W++;
                    statB.L++;
                } else if (match.scoreB > match.scoreA) {
                    statB.W++;
                    statA.L++;
                }
            }
        }
    });

    Object.values(stats).forEach(stat => {
        stat.PD = stat.PS - stat.PA;
    });

    const ranking = Object.values(stats).sort((a, b) => {
        if (b.W !== a.W) return b.W - a.W;
        if (b.PD !== a.PD) return b.PD - a.PD;
        return b.PS - a.PS;
    });

    return ranking;
}

function renderRankingTable() {
    const tableA = state.tableA;
    const tableB = state.tableB;
    const container = document.getElementById('rankingTables');

    function createTableHTML(ranking, bangName) {
        if (ranking.length === 0) return `<div class="p-3"><h6>B·∫£ng ${bangName}</h6><p>Ch∆∞a c√≥ d·ªØ li·ªáu x·∫øp h·∫°ng.</p></div>`;

        let html = `<div class="table-responsive"><h6>B·∫£ng ${bangName}</h6>
            <table class="table table-striped table-sm ranking-table">
                <thead><tr>
                    <th>#</th><th>ƒê·ªôi</th><th>Th·∫Øng</th><th>Thua</th><th>HS</th><th>ƒêi·ªÉm Ghi</th>
                </tr></thead><tbody>`;

        ranking.forEach((stat, index) => {
            const rowClass = (index === 0) ? 'rank-1' : (index === 1) ? 'rank-2' : '';
            html += `<tr class="${rowClass}">
                <td>${index + 1}</td>
                <td>${stat.team}</td>
                <td>${stat.W}</td>
                <td>${stat.L}</td>
                <td>${stat.PD}</td>
                <td>${stat.PS}</td>
            </tr>`;
        });
        html += `</tbody></table></div>`;
        return html;
    }

    container.innerHTML = createTableHTML(tableA, 'A (Nam - N·ªØ)') + createTableHTML(tableB, 'B (Nam)');
}

// --- V√≤ng Chung K·∫øt Logic ---

function scheduleFinalsAuto(skipAlert = false) {
    if (state.tableA.length < 2 || state.tableB.length < 2) {
        if (!skipAlert) showModal('C·∫£nh B√°o', 'Ch∆∞a c√≥ ƒë·ªß k·∫øt qu·∫£ v√≤ng b·∫£ng ƒë·ªÉ x·∫øp h·∫°ng.');
        return;
    }

    const NhatA = state.tableA[0].team;
    const NhiA = state.tableA[1].team;
    const NhatB = state.tableB[0].team;
    const NhiB = state.tableB[1].team;

    // C·∫≠p nh·∫≠t ƒë·ªôi v√†o B√°n k·∫øt (Kh√¥ng ghi ƒë√® ƒëi·ªÉm s·ªë n·∫øu ƒë√£ c√≥)
    state.semifinals[0].teamA = NhatA;
    state.semifinals[0].teamB = NhatB;

    state.semifinals[1].teamA = NhiB;
    state.semifinals[1].teamB = NhiA;
    
    // C·∫≠p nh·∫≠t Chung k·∫øt
    const winnerSF1 = state.semifinals[0].winner;
    const winnerSF2 = state.semifinals[1].winner;
    
    state.final.teamA = winnerSF1 || 'Th·∫Øng SF1';
    state.final.teamB = winnerSF2 || 'Th·∫Øng SF2';

    stateChanged = true;
    renderFinals();

    if (!skipAlert) saveToGitHub();
}

function renderFinals() {
    const sfMatches = state.semifinals;
    const finalMatch = state.final;

    const renderFinalMatchTable = (matchArray) => {
        if (matchArray.length === 0) return `<div class="alert alert-secondary">Ch∆∞a c√≥ tr·∫≠n ƒë·∫•u n√†o ƒë∆∞·ª£c l√™n l·ªãch.</div>`;
        
        let html = `<div class='table-responsive'><table class='table table-striped table-sm table-bordered'>
            <thead><tr>
                <th>ID</th><th>Gi·ªù</th><th>S√¢n</th><th colspan="3" class="text-center">Tr·∫≠n ƒê·∫•u & T·ª∑ S·ªë</th>
            </tr></thead><tbody>`;

        matchArray.forEach(match => {
            const winnerA = match.scoreA !== null && match.scoreA > match.scoreB;
            const winnerB = match.scoreB !== null && match.scoreB > match.scoreA;
            const finalScoreA = match.scoreA !== null ? match.scoreA : '';
            const finalScoreB = match.scoreB !== null ? match.scoreB : '';

            html += `<tr>
                <td>${match.id}</td>
                <td>${match.time}</td>
                <td>${match.court}</td>
                
                <td class="${winnerA ? 'winner' : (match.scoreA !== null && !winnerA ? 'loser' : '')}">${match.teamA}</td>
                
                <td class="match-score-cell text-center" style="width: 100px;">
                    <input type="number" min="0" value="${finalScoreA}" 
                        onchange="updateScore('${match.id}', this.value, this.parentNode.nextElementSibling.querySelector('input').value, true)" />
                     - 
                    <input type="number" min="0" value="${finalScoreB}" 
                        onchange="updateScore('${match.id}', this.parentNode.previousElementSibling.querySelector('input').value, this.value, true)" />
                </td>

                <td class="${winnerB ? 'winner' : (match.scoreB !== null && !winnerB ? 'loser' : '')}">${match.teamB}</td>
            </tr>`;
        });
        html += `</tbody></table></div>`;
        return html;
    };
    
    document.getElementById('semifinalMatches').innerHTML = renderFinalMatchTable(sfMatches);
    document.getElementById('finalMatch').innerHTML = renderFinalMatchTable([finalMatch]);
}

function renderFinalResults() {
    const finalMatch = state.final;
    const sfMatches = state.semifinals;
    
    let championText = 'ƒêang ch·ªù k·∫øt qu·∫£...';
    let runnerUpText = 'ƒêang ch·ªù k·∫øt qu·∫£...';
    let thirdPlaceText = 'ƒêang ch·ªù k·∫øt qu·∫£...';

    if (finalMatch.winner) {
        championText = `<span class="badge bg-success">${finalMatch.winner}</span>`;
        runnerUpText = `<span class="badge bg-warning text-dark">${finalMatch.loser}</span>`;
    }

    const losers = sfMatches.map(m => m.loser).filter(l => l && !l.includes('Nh·∫•t') && !l.includes('Nh√¨'));
    if (losers.length > 0) {
        thirdPlaceText = `<span class="badge bg-secondary">${losers.join(' & ')}</span>`;
    } else if (sfMatches.every(m => m.winner)) {
        thirdPlaceText = 'ƒêang x√°c ƒë·ªãnh ƒë·ªôi thua B√°n k·∫øt...';
    }


    document.getElementById('champion').innerHTML = `V√¥ ƒë·ªãch: ${championText}`;
    document.getElementById('runnerUp').innerHTML = `√Å qu√¢n: ${runnerUpText}`;
    document.getElementById('thirdPlace').innerHTML = `H·∫°ng Ba ƒê·ªìng H·∫°ng: ${thirdPlaceText}`;
}

// --- V√≤ng B·∫£ng: Ch·ª©c nƒÉng Hi·ªÉn Th·ªã ---

function renderMatchesView() {
    const viewMode = document.getElementById('viewMode').value;
    
    if (viewMode === 'table') {
        renderMatchesByTable();
    } else {
        renderCourtSchedule();
    }
}

function renderMatchesByTable() {
    document.getElementById('matchesViewContent').innerHTML = `
        <h6 class="mt-4">B·∫£ng A (Nam - N·ªØ)</h6><div id="tableMatchesA"></div>
        <h6 class="mt-4">B·∫£ng B (Nam)</h6><div id="tableMatchesB"></div>
    `;
    renderMatchTable(state.matchesA, 'tableMatchesA');
    renderMatchTable(state.matchesB, 'tableMatchesB');
}

function renderCourtSchedule() {
    const allMatches = [...state.matchesA, ...state.matchesB];
    if (allMatches.length === 0) {
        document.getElementById('matchesViewContent').innerHTML = `<div class="alert alert-info mt-3">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u v√≤ng b·∫£ng.</div>`;
        return;
    }

    const matchesByCourt = allMatches.reduce((acc, match) => {
        acc[match.court] = acc[match.court] || [];
        acc[match.court].push(match);
        return acc;
    }, {});
    
    let html = '';
    const sortedCourts = Object.keys(matchesByCourt).sort();

    sortedCourts.forEach(courtName => {
        const matches = matchesByCourt[courtName].sort((a, b) => parseTime(a.time) - parseTime(b.time));
        html += `<h6 class="mt-4">${courtName}</h6>`;
        html += renderMatchTable(matches, null, true);
    });

    document.getElementById('matchesViewContent').innerHTML = html;
}

function renderMatchTable(matches, containerId, isCourtView = false) {
    if (matches.length === 0) {
        const content = `<div class="alert alert-secondary">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u.</div>`;
        if (containerId) document.getElementById(containerId).innerHTML = content;
        return content;
    }

    let html = `<div class='table-responsive'><table class='table table-striped table-sm table-hover'>
        <thead><tr>
            <th>ID</th>
            ${isCourtView ? '<th>B·∫£ng</th>' : ''}
            <th>Gi·ªù</th>
            ${!isCourtView ? '<th>S√¢n</th>' : ''}
            <th colspan="3" class="text-center">Tr·∫≠n ƒê·∫•u & T·ª∑ S·ªë</th>
        </tr></thead><tbody>`;

    matches.forEach(match => {
        const winnerA = match.scoreA !== null && match.scoreA > match.scoreB;
        const winnerB = match.scoreB !== null && match.scoreB > match.scoreA;
        const finalScoreA = match.scoreA !== null ? match.scoreA : '';
        const finalScoreB = match.scoreB !== null ? match.scoreB : '';

        html += `<tr>
            <td>${match.id}</td>
            ${isCourtView ? `<td>${match.bang}</td>` : ''}
            <td>${match.time}</td>
            ${!isCourtView ? `<td>${match.court}</td>` : ''}
            
            <td class="${winnerA ? 'winner' : (match.scoreA !== null && !winnerA ? 'loser' : '')}">${match.teamA}</td>
            
            <td class="match-score-cell text-center" style="width: 100px;">
                <input type="number" min="0" value="${finalScoreA}" 
                    onchange="updateScore('${match.id}', this.value, this.parentNode.nextElementSibling.querySelector('input').value, false)" />
                 - 
                <input type="number" min="0" value="${finalScoreB}" 
                    onchange="updateScore('${match.id}', this.parentNode.previousElementSibling.querySelector('input').value, this.value, false)" />
            </td>

            <td class="${winnerB ? 'winner' : (match.scoreB !== null && !winnerB ? 'loser' : '')}">${match.teamB}</td>
        </tr>`;
    });

    html += `</tbody></table></div>`;
    if (containerId) document.getElementById(containerId).innerHTML = html;
    return html;
}

// --- C√¥ng c·ª• (Tools) ---

function exportSchedule() {
    let csvContent = "teamA,teamB,time,court,bang,scoreA,scoreB\n";
    
    const allMatches = [...state.matchesA, ...state.matchesB].sort((a, b) => {
        const timeA = parseTime(a.time);
        const timeB = parseTime(b.time);
        if (timeA !== timeB) return timeA - timeB;
        if (a.court < b.court) return -1;
        if (a.court > b.court) return 1;
        return 0;
    });

    allMatches.forEach(match => {
        const scoreA = match.scoreA !== null ? match.scoreA : '';
        const scoreB = match.scoreB !== null ? match.scoreB : '';
        
        csvContent += `${match.teamA},${match.teamB},${match.time},${match.court},${match.bang},${scoreA},${scoreB}\n`;
    });

    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.setAttribute('href', url);
    link.setAttribute('download', 'schedule_export_' + new Date().toISOString().slice(0, 10) + '.csv');
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

function taoLichThiDauCungGio() {
    // Thu·∫≠t to√°n Round-Robin c∆° b·∫£n (Ch∆∞a ph·∫£i l√† t·ªëi ∆∞u h√≥a ph·ª©c t·∫°p)
    showModal('C·∫£nh B√°o', 'Ch·ª©c nƒÉng n√†y hi·ªán ƒëang s·ª≠ d·ª•ng thu·∫≠t to√°n Round-Robin c∆° b·∫£n. N√≥ kh√¥ng t·ªëi ∆∞u h√≥a th·ªùi gian ngh·ªâ cho ƒë·ªôi.');
    
    const courtsA = state.courts.filter(c => c.isMixed).map(c => c.name);
    const courtsB = state.courts.filter(c => !c.isMixed).map(c => c.name);

    if (courtsA.length === 0 || courtsB.length === 0) {
        showModal('L·ªói', 'Vui l√≤ng c·∫•u h√¨nh √≠t nh·∫•t 1 s√¢n cho B·∫£ng A v√† 1 s√¢n cho B·∫£ng B.');
        return;
    }

    // T·∫°m d√πng s√¢n ƒë·∫ßu ti√™n cho m·ªói b·∫£ng ƒë·ªÉ t·∫°o l·ªãch RR
    const baseCourtA = courtsA[0];
    const baseCourtB = courtsB[0];
    
    const matchesA = generateRoundRobin(state.mixedTeams, 'A', baseCourtA, '14:00', 15);
    const matchesB = generateRoundRobin(state.maleTeams, 'B', baseCourtB, '14:00', 15);
    
    state.matchesA = assignIds(matchesA, 'A');
    state.matchesB = assignIds(matchesB, 'B');
    stateChanged = true;

    tinhVaCapNhatXepHang();
    renderMatchesView();
    renderOverview();
    saveToGitHub();
}

function generateRoundRobin(teams, bang, baseCourt, startTime, timeIncrement) {
    if (teams.length < 2) return [];
    
    let matches = [];
    let currentTime = parseTime(startTime);

    for (let i = 0; i < teams.length; i++) {
        for (let j = i + 1; j < teams.length; j++) {
            matches.push({
                teamA: teams[i],
                teamB: teams[j],
                time: formatTime(currentTime),
                court: baseCourt, // G√°n t·∫°m v√†o s√¢n c∆° s·ªü ƒë·ªÉ ƒë∆°n gi·∫£n h√≥a RR
                bang: bang,
                scoreA: null,
                scoreB: null,
                winner: null
            });
            
            currentTime += timeIncrement;
        }
    }
    
    return matches.sort((a, b) => parseTime(a.time) - parseTime(b.time));
}

function assignIds(matches, baseId) {
    return matches.map((m, index) => ({...m, id: baseId + (index + 1)}));
}

function autoFillScores() {
    if (state.matchesA.length === 0 && state.matchesB.length === 0) {
        showModal('C·∫£nh B√°o', 'Vui l√≤ng t·∫°o l·ªãch thi ƒë·∫•u tr∆∞·ªõc khi ƒëi·ªÅn ƒëi·ªÉm t·ª± ƒë·ªông.');
        return;
    }
    
    const fillMatch = (match) => {
        if (match.scoreA === null) {
            match.scoreA = 21;
            match.scoreB = Math.floor(Math.random() * 15) + 5; 
            if (match.scoreA < match.scoreB) [match.scoreA, match.scoreB] = [match.scoreB, match.scoreA];
            match.winner = match.teamA;
        }
    };

    [...state.matchesA, ...state.matchesB].forEach(fillMatch);

    stateChanged = true;
    tinhVaCapNhatXepHang();
    renderMatchesView();
    showModal('Th√†nh C√¥ng', 'ƒê√£ ƒëi·ªÅn ƒëi·ªÉm ng·∫´u nhi√™n (Team A th·∫Øng) cho t·∫•t c·∫£ c√°c tr·∫≠n ch∆∞a c√≥ k·∫øt qu·∫£.');
    saveToGitHub();
}

function clearAllSchedules() {
    if (confirm("C·∫¢NH B√ÅO: Thao t√°c n√†y s·∫Ω X√ìA TO√ÄN B·ªò l·ªãch thi ƒë·∫•u V√≤ng B·∫£ng, B√°n k·∫øt v√† Chung k·∫øt. B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën ti·∫øp t·ª•c?")) {
        state.matchesA = [];
        state.matchesB = [];
        state.semifinals = [
            { id: 'SF1', teamA: 'Nh·∫•t A', teamB: 'Nh·∫•t B', scoreA: null, scoreB: null, time: '16:30', court: 'S√¢n 1', winner: null, loser: null, bang: 'Finals' },
            { id: 'SF2', teamA: 'Nh√¨ B', teamB: 'Nh√¨ A', scoreA: null, scoreB: null, time: '16:30', court: 'S√¢n 2', winner: null, loser: null, bang: 'Finals' }
        ];
        state.final = { id: 'F', teamA: 'Th·∫Øng SF1', teamB: 'Th·∫Øng SF2', scoreA: null, scoreB: null, time: '17:00', court: 'S√¢n 1', winner: null, runnerUp: null, bang: 'Finals' };
        state.tableA = [];
        state.tableB = [];

        stateChanged = true;
        renderMatchesView();
        renderFinals();
        renderFinalResults();
        renderOverview();
        showModal('Th√†nh C√¥ng', 'ƒê√£ x√≥a to√†n b·ªô l·ªãch thi ƒë·∫•u v√† k·∫øt qu·∫£.');
        saveToGitHub();
    }
}

// --- Tab T·ªïng quan ---
function renderOverview() {
    const allPlayers = [...state.mixedTeams, ...state.maleTeams]
        .flatMap(team => team.split('/')).map(p => p.trim());
    const uniquePlayers = Array.from(new Set(allPlayers)).sort();
    const totalTeams = state.mixedTeams.length + state.maleTeams.length;
    const totalMatchesA = state.matchesA.length;
    const totalMatchesB = state.matchesB.length;
    const completedMatches = [...state.matchesA, ...state.matchesB].filter(m => m.scoreA !== null && m.scoreB !== null).length;
    const totalMatches = totalMatchesA + totalMatchesB;

    let html = `
        <div class="row">
            <div class="col-md-6 mb-4">
                <div class="card shadow-sm border-primary">
                    <div class="card-body">
                        <h5 class="card-title text-primary">üìä Th√¥ng tin Gi·∫£i ƒë·∫•u</h5>
                        <p><strong>T·ªïng s·ªë V·∫≠n ƒë·ªông vi√™n:</strong> <span class="badge bg-primary">${uniquePlayers.length}</span> ng∆∞·ªùi</p>
                        <p><strong>T·ªïng s·ªë ƒê·ªôi tham gia:</strong> <span class="badge bg-primary">${totalTeams}</span> ƒë·ªôi</p>
                        <p><strong>T·ªïng s·ªë Tr·∫≠n ƒë·∫•u (V√≤ng B·∫£ng):</strong> <span class="badge bg-primary">${totalMatches}</span> tr·∫≠n (ƒê√£ ho√†n th√†nh: ${completedMatches}/${totalMatches})</p>
                    </div>
                </div>
            </div>
            <div class="col-md-6 mb-4">
                <div class="card shadow-sm border-success">
                    <div class="card-body">
                        <h5 class="card-title text-success">üìã Ph√¢n lo·∫°i B·∫£ng ƒë·∫•u</h5>
                        <p><strong>B·∫£ng A (Nam - N·ªØ):</strong> ${state.mixedTeams.length} ƒë·ªôi (T·ªïng ${totalMatchesA} tr·∫≠n)</p>
                        <p><strong>B·∫£ng B (Nam):</strong> ${state.maleTeams.length} ƒë·ªôi (T·ªïng ${totalMatchesB} tr·∫≠n)</p>
                    </div>
                </div>
            </div>
        </div>
        <div class="card mt-2 shadow-sm">
            <div class="card-body">
                <h5 class="card-title text-secondary">üë• Danh s√°ch ƒê·ªôi & V·∫≠n ƒë·ªông vi√™n</h5>
                <div class="row">
                    <div class="col-lg-6">
                        <h6>B·∫£ng A (Nam-N·ªØ):</h6>
                        <ul class="list-group list-group-flush small">
                            ${state.mixedTeams.map(team => `<li class="list-group-item">${team}</li>`).join('')}
                        </ul>
                    </div>
                    <div class="col-lg-6">
                        <h6>B·∫£ng B (Nam):</h6>
                        <ul class="list-group list-group-flush small">
                            ${state.maleTeams.map(team => `<li class="list-group-item">${team}</li>`).join('')}
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    `;
    document.getElementById('overviewContent').innerHTML = html;
}

// --- Kh·ªüi t·∫°o ·ª®ng d·ª•ng ---
window.onload = function() {
    loadConfig();
    document.getElementById('viewMode').value = 'court';

    if (state.config.token) {
        loadFromGitHub(); 
    } else {
        renderConfig(); 
        taoLichCoDinh(true); 
        renderFinals(); 
        renderFinalResults(); 
        renderOverview();
        startAutoSave();
    }
};
</script>
</body>
</html>
