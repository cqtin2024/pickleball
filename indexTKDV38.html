<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TKD Championship 2025 ‚Äî Qu·∫£n l√Ω gi·∫£i Pickleball V14 GitHub (Court Config)</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body { background:#f7f9fc; font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial; color:#222; padding:18px; }
    .tab-content { margin-top: 18px; }
    .logo { 
      width:64px; 
      height:64px; 
      object-fit:contain; 
      border-radius:8px; 
      border:1px solid #e6eefc; 
      padding:6px; 
      background:#fff; 
    }
    table th { background:#0d6efd; color:#fff; position:sticky; top:0; }
    .status { font-size:0.95rem; color:#555; }
    /* Responsive adjustment for match inputs */
    .match-score-cell input {
      width: 45px;
      text-align: center;
      padding: 0.1rem;
    }
    @media (max-width: 576px) {
      .match-score-cell input {
        width: 35px;
      }
    }
    .winner { font-weight: bold; color: green; }
    .loser { color: red; }
    .ranking-container { display: flex; flex-direction: column; gap: 20px; }
    @media (min-width: 768px) {
        .ranking-container { flex-direction: row; }
        .ranking-container > div { flex: 1; }
    }
  </style>
</head>
<body>
<div class="container">
  <div class="d-flex justify-content-between align-items-center mb-3">
    <div class="d-flex align-items-center gap-2">
      <img class="logo" src="data/logoTKD.png" alt="Logo TKD">
      <div>
        <h3 class="mb-0">TKD Championship 2025</h3>
        <div>Ng√†y thi ƒë·∫•u: 18/10/2025</div>
      </div>
    </div>
    <div>
      <div id="autoSaveStatus" class="text-end status">Auto-save: <span id="autoState" class="text-danger">T·∫Øt</span></div>
      <div id="lastSaved" class="text-end status">Ch∆∞a l∆∞u</div>
    </div>
  </div>

  <ul class="nav nav-tabs" id="mainTabs">
    <li class="nav-item"><button class="nav-link active" data-bs-toggle="tab" data-bs-target="#overview" onclick="renderOverview()">T·ªïng quan</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#matches" id="matchesTabButton" onclick="renderMatchesView()">V√≤ng B·∫£ng</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#finals" onclick="renderFinals()">V√≤ng Chung K·∫øt</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#results" onclick="tinhVaCapNhatXepHang(); renderFinalResults();">K·∫øt qu·∫£ Chung cu·ªôc</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#config" id="configTabButton" onclick="renderConfig()">C·∫•u h√¨nh</button></li>
  </ul>

  <div class="tab-content">
    <div class="tab-pane fade show active p-3" id="overview">
        <div id="overviewContent">ƒêang t·∫£i d·ªØ li·ªáu...</div>
    </div>
    
    <div class="tab-pane fade p-3" id="matches">
      <div class="d-flex gap-2 mb-3 flex-wrap">
        <label for="viewMode" class="form-label mb-0 align-self-center text-nowrap">Ch·∫ø ƒë·ªô xem:</label>
        <select id="viewMode" class="form-select form-select-sm w-auto" onchange="renderMatchesView()">
            <option value="table">Theo B·∫£ng ƒë·∫•u</option>
            <option value="court" selected>Theo S√¢n thi ƒë·∫•u</option>
        </select>
        
        <button class="btn btn-sm btn-info ms-auto" onclick="document.getElementById('fileInput').click()">Import L·ªãch (CSV)</button>
        <input type="file" id="fileInput" accept=".csv" style="display: none;" onchange="handleFileSelect(event)">
        
        <button class="btn btn-sm btn-warning" onclick="exportSchedule()">Export L·ªãch (CSV)</button>
      </div>
      
      <div id="matchesViewContent">
        <h6 id="scheduleAHeader" class="mt-4">B·∫£ng A (Nam - N·ªØ)</h6><div id="tableMatchesA">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u.</div>
        
        <h6 class="mt-4">B·∫£ng B (Nam)</h6><div id="tableMatchesB">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u.</div>
      </div>

      <button class="btn btn-warning mt-4" onclick="scheduleFinalsAuto()">L√™n l·ªãch V√≤ng Chung k·∫øt (T·ª± ƒë·ªông h√≥a)</button>
    </div>

    <div class="tab-pane fade p-3" id="finals">
        <div id="finalsContent">
            <h6 class="mt-4">V√≤ng B√°n k·∫øt (16:30, S√¢n 1-2)</h6>
            <div id="semifinalMatches">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u b√°n k·∫øt. K·∫øt qu·∫£ V√≤ng B·∫£ng s·∫Ω t·ª± ƒë·ªông c·∫≠p nh·∫≠t l·ªãch.</div>

            <h6 class="mt-4">Tr·∫≠n Chung k·∫øt (17:00, S√¢n 1)</h6>
            <div id="finalMatch">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u chung k·∫øt.</div>
        </div>
    </div>

    <div class="tab-pane fade p-3" id="results">
        <h5 class="mb-3">B·∫£ng x·∫øp h·∫°ng V√≤ng B·∫£ng (C·∫≠p nh·∫≠t li√™n t·ª•c)</h5>
        <div id="rankingTables" class="ranking-container">
            </div>

        <hr class="my-4">

        <h5 class="mb-3">Danh hi·ªáu Chung cu·ªôc</h5>
        <p id="champion">V√¥ ƒë·ªãch: ƒêang ch·ªù k·∫øt qu·∫£...</p>
        <p id="runnerUp">√Å qu√¢n: ƒêang ch·ªù k·∫øt qu·∫£...</p>
        <p id="thirdPlace">H·∫°ng Ba ƒê·ªìng H·∫°ng: ƒêang ch·ªù k·∫øt qu·∫£...</p>
    </div>

    <div class="tab-pane fade p-3" id="config">
      <h5 class="mb-3">C√¥ng c·ª• L·∫≠p & ƒêi·ªÅn L·ªãch Thi ƒë·∫•u</h5>
      <div class="d-flex gap-2 mb-4 flex-wrap">
        <button class="btn btn-sm btn-primary" onclick="taoLichThiDauCungGio()">T·∫°o l·ªãch thi ƒë·∫•u T·ªëi ∆∞u (T·ª± ƒë·ªông)</button>
        <button class="btn btn-sm btn-secondary" onclick="taoLichCoDinh()">T·∫°o l·ªãch C·ªë ƒë·ªãnh</button>
        <button class="btn btn-sm btn-success" onclick="autoFillScores()">ƒêi·ªÅn k·∫øt qu·∫£ T·ª± ƒë·ªông (11 - X)</button>
        <button class="btn btn-sm btn-danger" onclick="clearAllSchedules()">X√≥a To√†n b·ªô L·ªãch</button>
      </div>
      
      <hr>

      <h5 class="mt-4">‚öôÔ∏è C·∫•u h√¨nh S√¢n thi ƒë·∫•u & L·ªãch T·ªëi ∆∞u</h5>
      <p class="text-muted small">Qu·∫£n l√Ω danh s√°ch s√¢n thi ƒë·∫•u. S√¢n ƒë∆∞·ª£c g√°n lo·∫°i b·∫£ng ƒë·∫•u (A/B) ƒë·ªÉ ph·ª•c v·ª• ch·ª©c nƒÉng t·∫°o l·ªãch T·ªëi ∆∞u.</p>
      <div class="d-flex gap-2 mb-3 flex-wrap">
          <button class="btn btn-sm btn-primary" onclick="openCourtModal()">+ Th√™m S√¢n M·ªõi</button>
          <button class="btn btn-sm btn-outline-info" onclick="loadDefaultCourtConfig()">T·∫£i c·∫•u h√¨nh M·∫∑c ƒë·ªãnh</button>
      </div>
      <div id="courtListContainer">
          </div>
      <div id="courtConfigStatus"></div>
      <hr>

      <h5 class="mt-4">üíæ C·∫•u h√¨nh K·∫øt n·ªëi GitHub</h5>
      <p class="text-muted">Nh·∫≠p th√¥ng tin kho l∆∞u tr·ªØ GitHub ƒë·ªÉ t·ª± ƒë·ªông l∆∞u tr·ªØ d·ªØ li·ªáu gi·∫£i ƒë·∫•u.</p>
      <div class="row g-2 mb-2">
        <div class="col-md-3"><input id="cfgOwner" class="form-control" placeholder="Owner (V√≠ d·ª•: user_name)"></div>
        <div class="col-md-3"><input id="cfgRepo" class="form-control" placeholder="Repo (V√≠ d·ª•: my-data-repo)"></div>
        <div class="col-md-3"><input id="cfgFolder" class="form-control" value="data"></div>
        <div class="col-md-3"><input id="cfgFile" class="form-control" value="state.json"></div>
      </div>
      <input id="cfgToken" type="password" class="form-control mb-2" placeholder="D√°n GitHub Personal Access Token (PAT) t·∫°i ƒë√¢y">
      <div class="d-flex gap-2">
        <button class="btn btn-primary" onclick="saveConfig()">L∆∞u c·∫•u h√¨nh Local</button>
        <button class="btn btn-success" onclick="checkConnection()">Ki·ªÉm tra & T·∫£i D·ªØ li·ªáu</button>
      </div>
      <div class="mt-2" id="configStatus"></div>
      
      <div class="card bg-light mt-4 shadow-sm">
        <div class="card-body">
            <h5 class="card-title text-info">üîë H∆∞·ªõng d·∫´n l·∫•y GitHub Token (PAT)</h5>
            <ol class="small mb-0">
                <li>Truy c·∫≠p <a href="https://github.com/settings/tokens" target="_blank" class="text-info">GitHub Tokens Settings</a> (B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p).</li>
                <li>Ch·ªçn **Generate new token** (ho·∫∑c **Generate new token (classic)** n·∫øu b·∫°n d√πng t√†i kho·∫£n c≈©).</li>
                <li>**T√™n Token:** ƒê·∫∑t t√™n d·ªÖ nh·ªõ (v√≠ d·ª•: `TKDManager_AutoSave`).</li>
                <li>**Th·ªùi h·∫°n:** Ch·ªçn t√πy √Ω (n√™n ch·ªçn 90 ng√†y ho·∫∑c T√πy ch·ªânh).</li>
                <li>**Ph·∫°m vi (Scopes):** **B·∫ÆT BU·ªòC** t√≠ch ch·ªçn √¥ **`repo`** (cho ph√©p truy c·∫≠p v√†o kho l∆∞u tr·ªØ).</li>
                <li>Nh·∫•n **Generate token** v√† **SAO CH√âP** chu·ªói Token v·ª´a ƒë∆∞·ª£c t·∫°o.</li>
                <li>D√°n chu·ªói Token ƒë√≥ v√†o √¥ "D√°n GitHub Personal Access Token (PAT) t·∫°i ƒë√¢y" b√™n tr√™n.</li>
            </ol>
            <p class="mt-2 mb-0 text-danger small">‚ö†Ô∏è **L∆∞u √Ω:** Token ch·ªâ hi·ªÉn th·ªã **M·ªòT L·∫¶N**. H√£y sao ch√©p ngay l·∫≠p t·ª©c v√† gi·ªØ b√≠ m·∫≠t. N·∫øu m·∫•t, b·∫°n ph·∫£i t·∫°o l·∫°i Token m·ªõi.</p>
        </div>
      </div>
      </div>
  </div>
</div>

<div class="modal fade" id="courtModal" tabindex="-1" aria-labelledby="courtModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="courtModalLabel">Th√™m/S·ª≠a C·∫•u h√¨nh S√¢n</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="courtForm">
          <input type="hidden" id="courtIndex" value="">
          <div class="mb-3">
            <label for="courtName" class="form-label">T√™n S√¢n</label>
            <input type="text" class="form-control" id="courtName" required>
          </div>
          <div class="mb-3">
            <label for="courtStartTime" class="form-label">Gi·ªù B·∫Øt ƒê·∫ßu (HH:mm)</label>
            <input type="time" class="form-control" id="courtStartTime" required>
          </div>
          <div class="mb-3">
            <label for="courtMaxDuration" class="form-label">Th·ªùi L∆∞·ª£ng T·ªëi ƒêa (Ph√∫t)</label>
            <input type="number" class="form-control" id="courtMaxDuration" min="1" required>
          </div>
          <div class="form-check mb-3">
            <input class="form-check-input" type="checkbox" id="courtIsMixed">
            <label class="form-check-label" for="courtIsMixed">
              D√†nh cho B·∫£ng A (Nam - N·ªØ)
            </label>
            <div class="form-text">N·∫øu kh√¥ng ch·ªçn, s√¢n s·∫Ω d√†nh cho B·∫£ng B (Nam).</div>
          </div>
          <div id="courtFormStatus" class="mt-2"></div>
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">H·ªßy</button>
        <button type="button" class="btn btn-primary" onclick="saveCourtChanges()">L∆∞u Thay ƒê·ªïi</button>
      </div>
    </div>
  </div>
</div>
<div class="modal fade" id="customAlertModal" tabindex="-1" aria-labelledby="customAlertModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="customAlertModalLabel">Th√¥ng b√°o</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="customAlertModalBody">
        N·ªôi dung th√¥ng b√°o
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-primary" data-bs-dismiss="modal">ƒê√≥ng</button>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script> 

<script>
// D·ªØ li·ªáu l·ªãch c·ªë ƒë·ªãnh t·ª´ file TKDPlayers - Sheet2 (1).csv (ƒê√É C·∫¨P NH·∫¨T)
const FIXED_SCHEDULE_CSV = `Gi·ªù b·∫Øt ƒë·∫ßu,Gi·ªù k·∫øt th√∫c,L∆∞·ª£t tr·∫≠n,S√¢n 1,S√¢n 2,S√¢n 3,S√¢n 7,Th·ªùi l∆∞·ª£ng d·ª± ki·∫øn
2:00,2:15,1,Ti·ªáp/Th·ªßy - Ph∆∞∆°ng/Thanh,Giang/Long - H∆∞·ªùng/ƒê·∫°t,H·∫≠u/D≈©ng - H·∫°nh/Ti·∫øn,Huy·ªÅn/Lu√¢n - Linh/M.H√πng,0:15
2:15,2:30,2,Tri·ªÅu/Minh - Hi·ªÉn/P.H√πng,T√≠n/Khi√™m - √Ånh/To√†n,H·∫≠u/D≈©ng - H∆∞·ªùng/ƒê·∫°t,Giang/Long - Huy·ªÅn/Lu√¢n,0:15
2:30,2:45,3,Ph∆∞∆°ng/Thanh - √Ånh/To√†n,Tri·ªÅu/Minh - T√≠n/Khi√™m,H·∫°nh/Ti·∫øn - Linh/M.H√πng,Tri·ªÅu/Minh - Hi·ªÉn/P.H√πng,0:15
2:45,3:00,4,,H·∫°nh/Ti·∫øn - Giang/Long,Huy·ªÅn/Lu√¢n - H∆∞·ªùng/ƒê·∫°t,H·∫≠u/D≈©ng - Linh/M.H√πng,0:15
3:00,3:15,5,,Ti·ªáp/Th·ªßy - √Ånh/To√†n,T√≠n/Khi√™m - Hi·ªÉn/M.H√πng,,0:15
3:15,3:30,6,,Ph∆∞∆°ng/Thanh - Tri·ªÅu/Minh,Giang/Long - Linh/M.H√πng,,0:15
3:30,3:45,7,,H·∫°nh/Ti·∫øn - H∆∞·ªùng/ƒê·∫°t,H·∫≠u/D≈©ng - Huy·ªÅn/Lu√¢n,,0:15
3:45,4:00,8,,Ti·ªáp/Th·ªßy - T√≠n/Khi√™m,Ph∆∞∆°ng/Thanh - Hi·ªÉn/P.H√πng,,0:15
4:00,4:15,9,,Tri·ªÅu/Minh - √Ånh/To√†n,Ti·ªáp/Th·ªßy - Ph∆∞∆°ng/Thanh,H·∫°nh/Ti·∫øn - Huy·ªÅn/Lu√¢n,0:15
4:15,4:30,10,,T√≠n/Khi√™m - Ph∆∞∆°ng/Thanh,Giang/Long - H·∫≠u/D≈©ng,,0:15
4:30,4:45,11,H·∫≠u/D≈©ng - H·∫°nh/Ti·∫øn,Giang/Long - H∆∞·ªùng/ƒê·∫°t,Huy·ªÅn/Lu√¢n - Linh/M.H√πng,H·∫≠u/D≈©ng - Linh/M.H√πng,0:15
4:45,5:00,12,,,,0:15
5:00,5:15,13,H·∫≠u/D≈©ng - Giang/Long,Huy·ªÅn/Lu√¢n - H·∫°nh/Ti·∫øn,Linh/M.H√πng - H∆∞·ªùng/ƒê·∫°t,,0:15
5:15,5:30,14,Tri·ªÅu/Minh - Ti·ªáp/Th·ªßy,√Ånh/To√†n - Hi·ªÉn/P.H√πng,Ph∆∞∆°ng/Thanh - T√≠n/Khi√™m,,0:15
5:30,5:45,15,H·∫≠u/D≈©ng - Huy·ªÅn/Lu√¢n,Giang/Long - Linh/M.H√πng,H·∫°nh/Ti·∫øn - H∆∞·ªùng/ƒê·∫°t,,0:15
5:45,6:00,16,,,,0:15
6:00,6:15,17,Huy·ªÅn/Lu√¢n - Giang/Long,H·∫≠u/D≈©ng - H∆∞·ªùng/ƒê·∫°t,H·∫°nh/Ti·∫øn - Linh/M.H√πng,,0:15
6:15,6:30,18,Ti·ªáp/Th·ªßy - Hi·ªÉn/P.H√πng,Ph∆∞∆°ng/Thanh - √Ånh/To√†n,Tri·ªÅu/Minh - T√≠n/Khi√™m,,0:15
6:30,6:45,19,H·∫≠u/D≈©ng - H·∫°nh/Ti·∫øn,Giang/Long - H∆∞·ªùng/ƒê·∫°t,Huy·ªÅn/Lu√¢n - Linh/M.H√πng,Ti·ªáp/Th·ªßy - Ph∆∞∆°ng/Thanh,0:15
6:45,7:00,20,Tri·ªÅu/Minh - Hi·ªÉn/P.H√πng,T√≠n/Khi√™m - √Ånh/To√†n,H·∫≠u/D≈©ng - H∆∞·ªùng/ƒê·∫°t,Giang/Long - Huy·ªÅn/Lu√¢n,0:15
7:00,7:15,21,Ph∆∞∆°ng/Thanh - √Ånh/To√†n,Tri·ªÅu/Minh - T√≠n/Khi√™m,H·∫°nh/Ti·∫øn - Linh/M.H√πng,Ti·ªáp/Th·ªßy - Hi·ªÉn/P.H√πng,0:15
7:15,7:30,22,,H·∫°nh/Ti·∫øn - Giang/Long,Huy·ªÅn/Lu√¢n - H∆∞·ªùng/ƒê·∫°t,H·∫≠u/D≈©ng - Linh/M.H√πng,0:15
7:30,7:45,23,,Ti·ªáp/Th·ªßy - √Ånh/To√†n,T√≠n/Khi√™m - Hi·ªÉn/P.H√πng,,0:15
7:45,8:00,24,,Ph∆∞∆°ng/Thanh - Tri·ªÅu/Minh,Giang/Long - Linh/M.H√πng,,0:15
8:00,8:15,25,,H·∫°nh/Ti·∫øn - H∆∞·ªùng/ƒê·∫°t,H·∫≠u/D≈©ng - Huy·ªÅn/Lu√¢n,,0:15
8:15,8:30,26,,Ti·ªáp/Th·ªßy - T√≠n/Khi√™m,Ph∆∞∆°ng/Thanh - Hi·ªÉn/P.P√πng,,0:15
8:30,8:45,27,,Tri·ªÅu/Minh - √Ånh/To√†n,Ti·ªáp/Th·ªßy - Ph∆∞∆°ng/Thanh,H·∫°nh/Ti·∫øn - Huy·ªÅn/Lu√¢n,0:15
8:45,9:00,28,,T√≠n/Khi√™m - Ph∆∞∆°ng/Thanh,Giang/Long - H·∫≠u/D≈©ng,,0:15
9:00,9:15,29,H·∫≠u/D≈©ng - H·∫°nh/Ti·∫øn,Giang/Long - H∆∞·ªùng/ƒê·∫°t,Huy·ªÅn/Lu√¢n - Linh/M.H√πng,H·∫≠u/D≈©ng - Linh/M.H√πng,0:15
9:15,9:30,30,,,,0:15
9:30,9:45,31,H·∫≠u/D≈©ng - Giang/Long,Huy·ªÅn/Lu√¢n - H·∫°nh/Ti·∫øn,Linh/M.H√πng - H∆∞·ªùng/ƒê·∫°t,,0:15
9:45,10:00,32,Tri·ªÅu/Minh - Ti·ªáp/Th·ªßy,√Ånh/To√†n - Hi·ªÉn/P.H√πng,Ph∆∞∆°ng/Thanh - T√≠n/Khi√™m,,0:15
10:00,10:15,33,H·∫≠u/D≈©ng - Huy·ªÅn/Lu√¢n,Giang/Long - Linh/M.H√πng,H·∫°nh/Ti·∫øn - H∆∞·ªùng/ƒê·∫°t,,0:15
10:15,10:30,34,,,,0:15
10:30,10:45,35,Huy·ªÅn/Lu√¢n - Giang/Long,H·∫≠u/D≈©ng - H∆∞·ªùng/ƒê·∫°t,H·∫°nh/Ti·∫øn - Linh/M.H√πng,,0:15
10:45,11:00,36,Ti·ªáp/Th·ªßy - Hi·ªÉn/P.H√πng,Ph∆∞∆°ng/Thanh - √Ånh/To√†n,Tri·ªÅu/Minh - T√≠n/Khi√™m,,0:15`;

// Bi·∫øn state l∆∞u tr·ªØ d·ªØ li·ªáu ch√≠nh c·ªßa ·ª©ng d·ª•ng.
let state = { 
  mixedTeams: [
    'Ti·ªáp/Th·ªßy', 'Ph∆∞∆°ng/Thanh', 'Giang/Long', 'H∆∞·ªùng/ƒê·∫°t', 'H·∫≠u/D≈©ng', 'H·∫°nh/Ti·∫øn', 'Huy·ªÅn/Lu√¢n', 'Linh/M.H√πng'
  ], 
  maleTeams: [ 
    'Tri·ªÅu/Minh', 'Hi·ªÉn/P.H√πng', 'T√≠n/Khi√™m', '√Ånh/To√†n'
  ],
  matchesA: [], 
  matchesB: [],
  tableA: [], 
  tableB: [], 
  
  // NEW: Court Configuration
  courts: [
    { name: 'S√¢n 1', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, 
    { name: 'S√¢n 2', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, 
    { name: 'S√¢n 3', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }, 
    { name: 'S√¢n 4', startTime: '14:00', maxDurationMinutes: 180, isMixed: false } 
  ],
  
  // LOGIC B√ÅN K·∫æT (ƒê√É ƒêI·ªÄU CH·ªàNH: Nh·∫•t A vs Nh√¨ A, Nh·∫•t B vs Nh√¨ B)
  semifinals: [
    { id: 'SF1', teamA: 'Nh·∫•t A', teamB: 'Nh√¨ A', scoreA: null, scoreB: null, time: '16:30', court: 'S√¢n 1', winner: null, loser: null },
    { id: 'SF2', teamA: 'Nh·∫•t B', teamB: 'Nh√¨ B', scoreA: null, scoreB: null, time: '16:30', court: 'S√¢n 2', winner: null, loser: null }
  ],
  final: { id: 'F', teamA: 'Th·∫Øng SF1', teamB: 'Th·∫Øng SF2', scoreA: null, scoreB: null, time: '17:00', court: 'S√¢n 1', winner: null, runnerUp: null },
  config: {}
};

let stateChanged = false; 
let currentSha = null; 
let autoSaveInterval = null; 

// --- Custom Modal Function ---
function showModal(title, body) {
    document.getElementById('customAlertModalLabel').textContent = title;
    document.getElementById('customAlertModalBody').innerHTML = body;
    const modal = new bootstrap.Modal(document.getElementById('customAlertModal'));
    modal.show();
}

/**
 * H√†m chuy·ªÉn ƒë·ªïi tab
 * @param {string} tabId - ID c·ªßa tab c·∫ßn chuy·ªÉn (v√≠ d·ª•: 'matches', 'overview')
 */
function switchTab(tabId) {
    const tabElement = document.querySelector(`#mainTabs button[data-bs-target="#${tabId}"]`);
    if (tabElement) {
        // T·∫Øt tab ƒëang active
        document.querySelectorAll('#mainTabs .nav-link').forEach(btn => btn.classList.remove('active'));
        document.querySelectorAll('.tab-content .tab-pane').forEach(pane => pane.classList.remove('show', 'active'));

        // B·∫≠t tab m·ªõi
        tabElement.classList.add('active');
        document.getElementById(tabId).classList.add('show', 'active');
        
        // C·∫≠p nh·∫≠t view cho tab matches n·∫øu chuy·ªÉn ƒë·∫øn
        if (tabId === 'matches') {
            renderMatchesView();
        } else if (tabId === 'results') {
            tinhVaCapNhatXepHang();
            renderFinalResults();
        }
    }
}

// --- Helper Functions cho Base64 ---
function b64EncodeUnicode(str) {
  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g,
    function(match, p1) {
      return String.fromCharCode('0x' + p1);
    }));
}

function b64DecodeUnicode(str) {
  return decodeURIComponent(atob(str).split('').map(function(c) {
    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
  }).join(''));
}

// --- GitHub API Functions ---

/**
 * L·∫•y SHA m·ªõi nh·∫•t c·ªßa file tr√™n GitHub.
 * @param {object} cfg - C·∫•u h√¨nh GitHub (owner, repo, folder, file, token)
 * @param {string} fileName - T√™n file c·∫ßn fetch (state.json ho·∫∑c players.json)
 * @returns {Promise<{sha: string|null, content: string|null}>}
 */
async function fetchFileSha(cfg, fileName = cfg.file) {
    const filePath = `${cfg.folder}/${fileName}`;
    const apiUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}/contents/${filePath}`;
    
    try {
        const response = await fetch(apiUrl, {
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });
        
        if (response.ok) {
            const data = await response.json();
            if (fileName === cfg.file) {
                 currentSha = data.sha; 
            }
            return { sha: data.sha, content: data.content };
        } else if (response.status === 404) {
            if (fileName === cfg.file) {
                 currentSha = null; 
            }
            return { sha: null, content: null };
        } else {
            throw new Error(`L·ªói khi l·∫•y SHA: ${response.statusText}`);
        }
    } catch (error) {
        console.error(`L·ªói Fetch SHA (${fileName}):`, error);
        throw new Error(`L·ªói k·∫øt n·ªëi ho·∫∑c API: ${error.message}`);
    }
}

/**
 * NEW: T·∫£i danh s√°ch ƒë·ªôi t·ª´ players.json
 */
async function loadPlayersFromGitHub(cfg) {
    const fileName = 'players.json';
    
    try {
        updateStatus('configStatus', 'info', 'ƒêang t·∫£i danh s√°ch ƒë·ªôi t·ª´ GitHub (players.json)...');
        const result = await fetchFileSha(cfg, fileName); 
        
        if (result.content) {
            const jsonString = b64DecodeUnicode(result.content);
            const loadedTeams = JSON.parse(jsonString);

            if (Array.isArray(loadedTeams.mixedTeams) && Array.isArray(loadedTeams.maleTeams)) {
                state.mixedTeams = loadedTeams.mixedTeams;
                state.maleTeams = loadedTeams.maleTeams;
                updateStatus('configStatus', 'success', `T·∫£i danh s√°ch ƒë·ªôi th√†nh c√¥ng (${state.mixedTeams.length + state.maleTeams.length} ƒë·ªôi).`);
                return true;
            } else {
                throw new Error("File players.json kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng (thi·∫øu mixedTeams/maleTeams).");
            }
        } else {
            updateStatus('configStatus', 'warning', 'Kh√¥ng t√¨m th·∫•y file players.json. D√πng danh s√°ch ƒë·ªôi kh·ªüi t·∫°o m·∫∑c ƒë·ªãnh.');
            return false;
        }
    } catch (error) {
        console.error("L·ªói khi t·∫£i players.json:", error);
        updateStatus('configStatus', 'danger', `L·ªói t·∫£i danh s√°ch ƒë·ªôi: ${error.message}`);
        return false;
    }
}

/**
 * T·∫£i tr·∫°ng th√°i gi·∫£i ƒë·∫•u (state.json) t·ª´ GitHub.
 */
async function loadFromGitHub() {
    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) return;

    // 1. Load Teams (danh s√°ch ƒë·ªôi)
    await loadPlayersFromGitHub(cfg); 

    // 2. Load App State (state.json)
    try {
        updateStatus('configStatus', 'info', 'ƒêang t·∫£i tr·∫°ng th√°i gi·∫£i ƒë·∫•u t·ª´ GitHub (state.json)...');
        const result = await fetchFileSha(cfg, cfg.file); 
        
        if (result.content) {
            const jsonString = b64DecodeUnicode(result.content);
            const loadedState = JSON.parse(jsonString);

            state.matchesA = loadedState.matchesA || [];
            state.matchesB = loadedState.matchesB || [];
            
            if (loadedState.courts) {
                state.courts = loadedState.courts;
            }
            
            // ƒê·∫£m b·∫£o kh√¥ng ghi ƒë√® l·ªãch t·ª± ƒë·ªông ƒë√£ g√°n ƒë·ªôi th·ª±c t·∫ø
            const defaultSF1 = { teamA: 'Nh·∫•t A', teamB: 'Nh√¨ A' };
            const defaultSF2 = { teamA: 'Nh·∫•t B', teamB: 'Nh√¨ B' };
            const loadedSemifinals = loadedState.semifinals;
            
            if (loadedSemifinals && loadedSemifinals.length === 2 && 
                !(loadedSemifinals[0].teamA === defaultSF1.teamA && loadedSemifinals[0].teamB === defaultSF1.teamB)
            ) {
                state.semifinals = loadedSemifinals;
            } else if (loadedSemifinals && loadedSemifinals.length === 2) {
                state.semifinals = loadedSemifinals;
            }

            state.final = loadedState.final || state.final;
            
            // C·∫≠p nh·∫≠t giao di·ªán
            renderMatches(); 
            tinhVaCapNhatXepHang();
            renderFinals();
            renderFinalResults();
            renderOverview();
            
            updateStatus('configStatus', 'success', `T·∫£i tr·∫°ng th√°i gi·∫£i ƒë·∫•u th√†nh c√¥ng t·ª´: ${cfg.owner}/${cfg.repo}/${cfg.folder}/${cfg.file}`);
            document.getElementById('lastSaved').textContent = `L·∫ßn t·∫£i: ${new Date().toLocaleTimeString('vi-VN')}`;
        } else {
            updateStatus('configStatus', 'warning', 'File tr·∫°ng th√°i (state.json) ch∆∞a t·ªìn t·∫°i. Vui l√≤ng nh·∫•n L∆∞u ho·∫∑c T·ª± ƒë·ªông l∆∞u ƒë·ªÉ t·∫°o file.');
        }

        startAutoSave();

    } catch (error) {
        updateStatus('configStatus', 'danger', `L·ªói t·∫£i tr·∫°ng th√°i gi·∫£i ƒë·∫•u: ${error.message}. Vui l√≤ng ki·ªÉm tra l·∫°i Token/Repo.`);
        console.error("L·ªói khi t·∫£i tr·∫°ng th√°i gi·∫£i ƒë·∫•u t·ª´ GitHub:", error);
    }
}

async function saveToGitHub() {
    if (!stateChanged) return;

    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) {
        console.warn("Kh√¥ng th·ªÉ t·ª± ƒë·ªông l∆∞u: Thi·∫øu c·∫•u h√¨nh GitHub.");
        document.getElementById('autoState').className = 'text-warning';
        document.getElementById('autoState').textContent = 'T·∫°m d·ª´ng (Thi·∫øu Config)';
        return;
    }

    document.getElementById('autoState').className = 'text-info';
    document.getElementById('autoState').textContent = 'ƒêang l∆∞u...';

    const apiUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}/contents/${cfg.folder}/${cfg.file}`;
    
    const stateToSave = {
        mixedTeams: state.mixedTeams,
        maleTeams: state.maleTeams,
        matchesA: state.matchesA,
        matchesB: state.matchesB,
        courts: state.courts,
        semifinals: state.semifinals,
        final: state.final
    };
    const content = b64EncodeUnicode(JSON.stringify(stateToSave));
    
    try {
        const result = await fetchFileSha(cfg, cfg.file); 
        const sha = result.sha; 
        
        const payload = {
            message: `[Auto-save] C·∫≠p nh·∫≠t tr·∫°ng th√°i gi·∫£i ƒë·∫•u TKD l√∫c ${new Date().toLocaleString('vi-VN')}`,
            content: content
        };
        
        if (sha) {
             payload.sha = sha;
        }

        const response = await fetch(apiUrl, {
            method: 'PUT',
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Content-Type': 'application/json',
                'Accept': 'application/vnd.github.v3+json'
            },
            body: JSON.stringify(payload)
        });

        if (response.ok) {
            const data = await response.json();
            currentSha = data.content.sha;
            stateChanged = false;
            document.getElementById('lastSaved').textContent = `L·∫ßn l∆∞u: ${new Date().toLocaleTimeString('vi-VN')}`;
            document.getElementById('autoState').className = 'text-success';
            document.getElementById('autoState').textContent = 'ƒê√£ L∆∞u';
        } else {
            if (response.status === 409) {
                console.warn("L·ªói 409 Conflict: D·ªØ li·ªáu ƒë√£ thay ƒë·ªïi tr√™n GitHub. ƒêang c·ªë g·∫Øng l·∫•y SHA m·ªõi.");
                await fetchFileSha(cfg, cfg.file); 
                document.getElementById('autoState').className = 'text-warning';
                document.getElementById('autoState').textContent = 'Conflict. S·∫Ω th·ª≠ l∆∞u l·∫°i sau 1 ph√∫t.';
            } else {
                throw new Error(`L·ªói HTTP: ${response.status} - ${response.statusText}`);
            }
        }
    } catch (error) {
        console.error("L·ªói khi l∆∞u l√™n GitHub:", error);
        document.getElementById('autoState').className = 'text-danger';
        document.getElementById('autoState').textContent = 'L·ªói L∆∞u';
    }
}

async function checkConnection() {
    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) {
        updateStatus('configStatus', 'warning', 'Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß Owner, Repo v√† Token.');
        return;
    }

    try {
        updateStatus('configStatus', 'info', 'ƒêang ki·ªÉm tra k·∫øt n·ªëi...');
        
        const repoCheckUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}`;
        const repoResponse = await fetch(repoCheckUrl, {
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });

        if (!repoResponse.ok) {
            throw new Error(`L·ªói truy c·∫≠p kho l∆∞u tr·ªØ. M√£: ${repoResponse.status}. (Ki·ªÉm tra Token/Repo/Owner)`);
        }
        
        updateStatus('configStatus', 'success', 'K·∫øt n·ªëi GitHub th√†nh c√¥ng! ƒêang t·∫£i d·ªØ li·ªáu...');
        await loadFromGitHub();

    } catch (error) {
        updateStatus('configStatus', 'danger', `Ki·ªÉm tra k·∫øt n·ªëi th·∫•t b·∫°i: ${error.message}.`);
        console.error("L·ªói ki·ªÉm tra k·∫øt n·ªëi:", error);
    }
}

// --- C·∫•u h√¨nh & Kh·ªüi t·∫°o ---

function renderConfig() {
    renderCourtList();
    document.getElementById('courtConfigStatus').innerHTML = '';
}

/**
 * Hi·ªÉn th·ªã danh s√°ch s√¢n d∆∞·ªõi d·∫°ng b·∫£ng v·ªõi n√∫t S·ª≠a/X√≥a.
 */
function renderCourtList() {
    const container = document.getElementById('courtListContainer');
    if (!container) return;
    
    if (state.courts.length === 0) {
        container.innerHTML = `<div class="alert alert-warning">Ch∆∞a c√≥ s√¢n n√†o ƒë∆∞·ª£c c·∫•u h√¨nh.</div>`;
        return;
    }
    
    let html = `<div class='table-responsive'><table class='table table-striped table-sm'>
        <thead>
            <tr>
                <th>T√™n S√¢n</th>
                <th>Gi·ªù B·∫Øt ƒê·∫ßu</th>
                <th>Th·ªùi L∆∞·ª£ng Max (Ph√∫t)</th>
                <th>Ph√¢n Lo·∫°i</th>
                <th class="text-center">H√†nh ƒë·ªông</th>
            </tr>
        </thead>
        <tbody>`;
        
    state.courts.forEach((court, index) => {
        const type = court.isMixed ? 'B·∫£ng A (Nam-N·ªØ)' : 'B·∫£ng B (Nam)';
        const typeClass = court.isMixed ? 'badge bg-primary' : 'badge bg-info';
        
        html += `<tr>
            <td>${court.name}</td>
            <td>${court.startTime}</td>
            <td>${court.maxDurationMinutes}</td>
            <td><span class="${typeClass}">${type}</span></td>
            <td class="text-center">
                <button class="btn btn-sm btn-outline-secondary me-1" onclick="openCourtModal(${index})">S·ª≠a</button>
                <button class="btn btn-sm btn-outline-danger" onclick="deleteCourt(${index})">X√≥a</button>
            </td>
        </tr>`;
    });
    
    html += `</tbody></table></div>`;
    container.innerHTML = html;
}

/**
 * M·ªü modal th√™m/s·ª≠a s√¢n v√† ƒëi·ªÅn d·ªØ li·ªáu n·∫øu l√† ch·∫ø ƒë·ªô s·ª≠a.
 * @param {number | null} index - Ch·ªâ s·ªë c·ªßa s√¢n c·∫ßn s·ª≠a, ho·∫∑c null n·∫øu th√™m m·ªõi.
 */
function openCourtModal(index = null) {
    const modal = new bootstrap.Modal(document.getElementById('courtModal'));
    document.getElementById('courtFormStatus').innerHTML = '';

    document.getElementById('courtIndex').value = index !== null ? index : '';
    document.getElementById('courtModalLabel').textContent = index !== null ? 'S·ª≠a C·∫•u h√¨nh S√¢n' : 'Th√™m S√¢n M·ªõi';

    if (index !== null) {
        const court = state.courts[index];
        document.getElementById('courtName').value = court.name || '';
        document.getElementById('courtStartTime').value = court.startTime || '14:00';
        document.getElementById('courtMaxDuration').value = court.maxDurationMinutes || 180;
        document.getElementById('courtIsMixed').checked = court.isMixed || false;
    } else {
        // Ch·∫ø ƒë·ªô th√™m m·ªõi: Reset form
        document.getElementById('courtName').value = '';
        document.getElementById('courtStartTime').value = '14:00';
        document.getElementById('courtMaxDuration').value = '180';
        document.getElementById('courtIsMixed').checked = true; // Default to Mixed (B·∫£ng A)
    }

    modal.show();
}

/**
 * L∆∞u thay ƒë·ªïi t·ª´ modal v√†o state.courts
 */
function saveCourtChanges() {
    const indexStr = document.getElementById('courtIndex').value;
    const index = indexStr === '' ? null : parseInt(indexStr);
    
    const name = document.getElementById('courtName').value.trim();
    const startTime = document.getElementById('courtStartTime').value;
    const maxDurationMinutes = parseInt(document.getElementById('courtMaxDuration').value);
    const isMixed = document.getElementById('courtIsMixed').checked;

    const statusDiv = document.getElementById('courtFormStatus');

    // Validation
    if (!name || !startTime || isNaN(maxDurationMinutes) || maxDurationMinutes <= 0) {
        statusDiv.innerHTML = `<div class="alert alert-danger p-2">Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß v√† h·ª£p l·ªá c√°c tr∆∞·ªùng (T√™n, Gi·ªù, Th·ªùi l∆∞·ª£ng > 0).</div>`;
        return;
    }
    
    // Check for duplicate name (excluding the current edited court)
    const isDuplicate = state.courts.some((c, i) => 
        i !== index && c.name.toLowerCase() === name.toLowerCase()
    );

    if (isDuplicate) {
         statusDiv.innerHTML = `<div class="alert alert-danger p-2">T√™n s√¢n "${name}" ƒë√£ t·ªìn t·∫°i.</div>`;
        return;
    }

    const newCourt = { 
        name, 
        startTime, 
        maxDurationMinutes, 
        isMixed 
    };

    if (index !== null) {
        // Edit mode
        state.courts[index] = newCourt;
    } else {
        // Add mode
        state.courts.push(newCourt);
    }
    
    // Close modal
    bootstrap.Modal.getInstance(document.getElementById('courtModal')).hide();

    // Update UI and save
    renderCourtList();
    stateChanged = true;
    updateStatus('courtConfigStatus', 'success', `ƒê√£ ${index !== null ? 'c·∫≠p nh·∫≠t' : 'th√™m'} s√¢n "${name}". D·ªØ li·ªáu s·∫Ω ƒë∆∞·ª£c t·ª± ƒë·ªông l∆∞u l√™n GitHub.`);
    saveToGitHub();
}

/**
 * X√≥a s√¢n kh·ªèi danh s√°ch.
 * @param {number} index - Ch·ªâ s·ªë c·ªßa s√¢n c·∫ßn x√≥a.
 */
function deleteCourt(index) {
    if (confirm(`B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a s√¢n "${state.courts[index].name}"?`)) {
        const deletedCourtName = state.courts[index].name;
        state.courts.splice(index, 1);
        renderCourtList();
        stateChanged = true;
        updateStatus('courtConfigStatus', 'success', `ƒê√£ x√≥a s√¢n "${deletedCourtName}". D·ªØ li·ªáu s·∫Ω ƒë∆∞·ª£c t·ª± ƒë·ªông l∆∞u l√™n GitHub.`);
        saveToGitHub();
    }
}

/**
 * T·∫£i c·∫•u h√¨nh m·∫∑c ƒë·ªãnh (ph·∫£i ƒë∆∞·ª£c c·∫≠p nh·∫≠t ƒë·ªÉ d√πng logic m·ªõi)
 */
function loadDefaultCourtConfig() {
    state.courts = [
        { name: 'S√¢n 1', startTime: '14:00', maxDurationMinutes: 180, isMixed: true },
        { name: 'S√¢n 2', startTime: '14:00', maxDurationMinutes: 180, isMixed: true },
        { name: 'S√¢n 3', startTime: '14:00', maxDurationMinutes: 180, isMixed: false },
        { name: 'S√¢n 4', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }
    ];
    renderCourtList();
    stateChanged = true;
    updateStatus('courtConfigStatus', 'success', 'ƒê√£ t·∫£i c·∫•u h√¨nh s√¢n M·∫∑c ƒë·ªãnh. D·ªØ li·ªáu s·∫Ω ƒë∆∞·ª£c t·ª± ƒë·ªông l∆∞u l√™n GitHub.');
    saveToGitHub();
}

function loadConfig() {
    const savedConfig = localStorage.getItem('pkb_config');
    if (savedConfig) {
        state.config = JSON.parse(savedConfig);
        document.getElementById('cfgOwner').value = state.config.owner || '';
        document.getElementById('cfgRepo').value = state.config.repo || '';
        document.getElementById('cfgFolder').value = state.config.folder || 'data';
        document.getElementById('cfgFile').value = state.config.file || 'state.json';
        document.getElementById('cfgToken').value = state.config.token || '';
    }
}

function saveConfig(){
    const cfg = {
        owner: document.getElementById('cfgOwner').value,
        repo: document.getElementById('cfgRepo').value,
        folder: document.getElementById('cfgFolder').value,
        file: document.getElementById('cfgFile').value,
        token: document.getElementById('cfgToken').value
    };
    state.config = cfg;
    localStorage.setItem('pkb_config', JSON.stringify(cfg));
    updateStatus('configStatus', 'success', 'ƒê√£ l∆∞u c·∫•u h√¨nh GitHub v√†o tr√¨nh duy·ªát. Vui l√≤ng Ki·ªÉm tra & T·∫£i D·ªØ li·ªáu.');
}

function updateStatus(id, type, message) {
    const statusDiv = document.getElementById(id);
    statusDiv.innerHTML = `<div class="alert alert-${type} p-2 mt-2">${message}</div>`;
}

function startAutoSave() {
    if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
    }
    if (state.config.token && state.config.owner && state.config.repo) {
        autoSaveInterval = setInterval(saveToGitHub, 60000); // 1 ph√∫t
        document.getElementById('autoState').className = 'text-warning';
        document.getElementById('autoState').textContent = 'Ho·∫°t ƒë·ªông...';
    } else {
        document.getElementById('autoState').className = 'text-danger';
        document.getElementById('autoState').textContent = 'T·∫Øt';
    }
}

window.onload = function() {
    loadConfig(); 
    
    // ƒê·∫∑t m·∫∑c ƒë·ªãnh cho select box th√†nh 'court'
    const viewModeSelect = document.getElementById('viewMode');
    if (viewModeSelect && viewModeSelect.value !== 'court') {
        viewModeSelect.value = 'court';
    }
    
    if (state.config.token) {
        loadFromGitHub();
    } else {
        renderConfig();
        renderMatches(); 
        tinhVaCapNhatXepHang();
        renderFinals();
        renderFinalResults();
        renderOverview();
        startAutoSave(); 
    }
};

// --- Tab T·ªïng quan (Overview) --- 
function renderOverview() {
    const allPlayers = [...state.mixedTeams, ...state.maleTeams]
        .flatMap(team => team.split('/').map(p => p.trim()));
    const uniquePlayers = Array.from(new Set(allPlayers)).sort();
    const totalTeams = state.mixedTeams.length + state.maleTeams.length;
    const totalMatchesA = state.matchesA.length;
    const totalMatchesB = state.matchesB.length;
    const completedMatches = [...state.matchesA, ...state.matchesB].filter(m => m.scoreA !== null && m.scoreB !== null).length;
    const totalMatches = totalMatchesA + totalMatchesB;
    const totalFinals = state.semifinals.length + 1; // 2 SF + 1 F
    const completedFinals = [...state.semifinals, state.final].filter(m => m.winner).length;
    
    let mixedPlayed = state.matchesA.filter(m => m.winner).length;
    let malePlayed = state.matchesB.filter(m => m.winner).length;
    
    let html = `
        <div class="row">
            <div class="col-md-6 mb-4">
                <div class="card shadow-sm border-primary">
                    <div class="card-body">
                        <h5 class="card-title text-primary">üìä Th√¥ng tin Gi·∫£i ƒë·∫•u</h5>
                        <p><strong>T·ªïng s·ªë V·∫≠n ƒë·ªông vi√™n:</strong> <span class="badge bg-primary">${uniquePlayers.length}</span> ng∆∞·ªùi</p>
                        <p><strong>T·ªïng s·ªë ƒê·ªôi tham gia:</strong> <span class="badge bg-primary">${totalTeams}</span> ƒë·ªôi (A: ${state.mixedTeams.length}, B: ${state.maleTeams.length})</p>
                    </div>
                </div>
            </div>
            <div class="col-md-6 mb-4">
                <div class="card shadow-sm border-success">
                    <div class="card-body">
                        <h5 class="card-title text-success">üèÜ T√¨nh h√¨nh Tr·∫≠n ƒë·∫•u</h5>
                        <p><strong>T·ªïng s·ªë Tr·∫≠n (V√≤ng B·∫£ng):</strong> <span class="badge bg-success">${totalMatches}</span> tr·∫≠n (A: ${totalMatchesA}, B: ${totalMatchesB})</p>
                        <p><strong>Tr·∫≠n ƒë√£ ho√†n th√†nh:</strong> <span class="badge bg-success">${completedMatches}</span> / ${totalMatches} (${(totalMatches > 0 ? (completedMatches / totalMatches * 100) : 0).toFixed(1)}%)</p>
                        <p><strong>Tr·∫≠n V√≤ng Chung k·∫øt:</strong> <span class="badge bg-success">${completedFinals}</span> / ${totalFinals} (${(totalFinals > 0 ? (completedFinals / totalFinals * 100) : 0).toFixed(1)}%)</p>
                    </div>
                </div>
            </div>
        </div>
        
        <h5 class="mt-2">B·∫£ng x·∫øp h·∫°ng T·∫°m th·ªùi</h5>
        <div id="overviewRanking" class="row">
            <div class="col-md-6">
                <h6>B·∫£ng A (Nam - N·ªØ)</h6>
                ${renderRankingTable('tableA', state.tableA, 5)}
            </div>
            <div class="col-md-6">
                <h6>B·∫£ng B (Nam)</h6>
                ${renderRankingTable('tableB', state.tableB, 5)}
            </div>
        </div>
    `;
    document.getElementById('overviewContent').innerHTML = html;
}

// --- Logic B·∫£ng X·∫øp H·∫°ng & Th·ªëng k√™ ---

/**
 * T√≠nh to√°n v√† c·∫≠p nh·∫≠t B·∫£ng X·∫øp H·∫°ng (state.tableA, state.tableB)
 */
function tinhVaCapNhatXepHang() {
    const calculateTable = (teams, matches) => {
        const table = teams.map(team => ({
            team: team,
            matchesPlayed: 0,
            wins: 0,
            losses: 0,
            scoreFor: 0,
            scoreAgainst: 0,
            scoreDiff: 0,
            points: 0 // 3 points for a win, 0 for a loss
        }));

        matches.forEach(match => {
            if (match.scoreA !== null && match.scoreB !== null) {
                const teamA = table.find(t => t.team === match.teamA);
                const teamB = table.find(t => t.team === match.teamB);

                if (!teamA || !teamB) return; 

                teamA.matchesPlayed++;
                teamB.matchesPlayed++;
                teamA.scoreFor += match.scoreA;
                teamA.scoreAgainst += match.scoreB;
                teamB.scoreFor += match.scoreB;
                teamB.scoreAgainst += match.scoreA;

                if (match.scoreA > match.scoreB) {
                    teamA.wins++;
                    teamB.losses++;
                    teamA.points += 3;
                } else if (match.scoreB > match.scoreA) {
                    teamB.wins++;
                    teamA.losses++;
                    teamB.points += 3;
                }
            }
        });

        table.forEach(t => {
            t.scoreDiff = t.scoreFor - t.scoreAgainst;
        });

        // S·∫Øp x·∫øp: 1. ƒêi·ªÉm, 2. Hi·ªáu s·ªë, 3. ƒêi·ªÉm Th·∫Øng
        table.sort((a, b) => {
            if (b.points !== a.points) return b.points - a.points;
            if (b.scoreDiff !== a.scoreDiff) return b.scoreDiff - a.scoreDiff;
            return b.scoreFor - a.scoreFor;
        });
        
        return table;
    };

    state.tableA = calculateTable(state.mixedTeams, state.matchesA);
    state.tableB = calculateTable(state.maleTeams, state.matchesB);
    
    // C·∫≠p nh·∫≠t giao di·ªán K·∫øt qu·∫£ Chung cu·ªôc n·∫øu ƒëang xem tab n√†y
    if (document.getElementById('results').classList.contains('active')) {
        renderFinalResults();
    }
}

/**
 * T·∫°o HTML cho b·∫£ng x·∫øp h·∫°ng.
 * @param {string} tableId - ID c·ªßa b·∫£ng
 * @param {Array} rankingData - D·ªØ li·ªáu x·∫øp h·∫°ng
 * @param {number} maxRows - S·ªë h√†ng t·ªëi ƒëa mu·ªën hi·ªÉn th·ªã
 */
function renderRankingTable(tableId, rankingData, maxRows = Infinity) {
    if (!rankingData || rankingData.length === 0) {
        return `<p class="text-muted small">Ch∆∞a c√≥ ƒë·ªôi ho·∫∑c l·ªãch thi ƒë·∫•u.</p>`;
    }
    
    let html = `<div class='table-responsive'><table class='table table-sm table-striped caption-top' id='${tableId}'>
        <thead class='table-dark'>
            <tr>
                <th>#</th>
                <th>ƒê·ªôi</th>
                <th>P</th>
                <th>W</th>
                <th>L</th>
                <th>+/-</th>
            </tr>
        </thead>
        <tbody>`;
        
    rankingData.slice(0, maxRows).forEach((teamStats, index) => {
        html += `<tr>
            <td>${index + 1}</td>
            <td class="${index < 2 ? 'winner' : ''}">${teamStats.team}</td>
            <td>${teamStats.points}</td>
            <td>${teamStats.wins}</td>
            <td>${teamStats.losses}</td>
            <td>${teamStats.scoreDiff > 0 ? '+' : ''}${teamStats.scoreDiff}</td>
        </tr>`;
    });
    
    html += `</tbody></table></div>`;
    return html;
}

function renderFinalResults() {
    // 1. Render Ranking Tables (full)
    const rankingContainer = document.getElementById('rankingTables');
    rankingContainer.innerHTML = `
        <div>
            <h6>B·∫£ng A (Nam - N·ªØ)</h6>
            ${renderRankingTable('rankingTableA', state.tableA, Infinity)}
        </div>
        <div>
            <h6>B·∫£ng B (Nam)</h6>
            ${renderRankingTable('rankingTableB', state.tableB, Infinity)}
        </div>
    `;

    // 2. Render Final Results
    const finalMatch = state.final;
    if (finalMatch.winner) {
        document.getElementById('champion').innerHTML = `V√¥ ƒë·ªãch: <strong class="text-primary">${finalMatch.winner}</strong>`;
        document.getElementById('runnerUp').innerHTML = `√Å qu√¢n: <strong class="text-info">${finalMatch.runnerUp}</strong>`;
    } else {
         document.getElementById('champion').innerHTML = `V√¥ ƒë·ªãch: ƒêang ch·ªù k·∫øt qu·∫£...`;
        document.getElementById('runnerUp').innerHTML = `√Å qu√¢n: ƒêang ch·ªù k·∫øt qu·∫£...`;
    }
    
    // Logic H·∫°ng Ba (2 ƒë·ªôi thua b√°n k·∫øt)
    const thirdPlaceTeams = state.semifinals.map(sf => sf.loser).filter(l => l);
    if (thirdPlaceTeams.length === 2) {
        document.getElementById('thirdPlace').innerHTML = `H·∫°ng Ba ƒê·ªìng H·∫°ng: <strong class="text-success">${thirdPlaceTeams.join(' & ')}</strong>`;
    } else {
        document.getElementById('thirdPlace').innerHTML = `H·∫°ng Ba ƒê·ªìng H·∫°ng: ƒêang ch·ªù k·∫øt qu·∫£ V√≤ng B√°n k·∫øt...`;
    }
}

// --- Logic V√≤ng B·∫£ng (Matches) ---

/**
 * H√†m chung ƒë·ªÉ t·∫°o HTML cho b·∫£ng tr·∫≠n ƒë·∫•u.
 * @param {Array} matches - Danh s√°ch tr·∫≠n ƒë·∫•u
 * @param {string} mode - 'table' (grouping by team) or 'court' (grouping by time/court)
 * @returns {string} HTML content
 */
function createMatchesHTML(matches, mode, courtFilter = null) {
    if (matches.length === 0) {
        return `<div class="alert alert-info">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u.</div>`;
    }

    // 1. Prepare data (Group by Court/Time if mode='court')
    let groupedMatches = {};
    if (mode === 'court') {
        matches.sort((a, b) => {
            if (a.time !== b.time) return a.time.localeCompare(b.time);
            return a.court.localeCompare(b.court);
        });
        
        // Group by Time-Slot (Time-Court)
        matches.forEach(match => {
            const key = `${match.time} | ${match.court}`;
            if (!groupedMatches[key]) {
                groupedMatches[key] = [];
            }
            groupedMatches[key].push(match);
        });

    } else { // mode === 'table'
        matches.forEach(match => {
            const keyA = match.teamA;
            const keyB = match.teamB;
            
            if (!groupedMatches[keyA]) groupedMatches[keyA] = [];
            if (!groupedMatches[keyB]) groupedMatches[keyB] = [];
            
            groupedMatches[keyA].push(match);
            groupedMatches[keyB].push(match);
        });
    }

    let html = '';
    
    if (mode === 'court') {
        // Render Court/Time View
        let currentHeader = '';
        
        for (const key in groupedMatches) {
            const [time, court] = key.split(' | ');
            if (courtFilter && court !== courtFilter) continue;
            
            if (time !== currentHeader) {
                html += `<h6 class="mt-4 border-bottom pb-1 text-primary">${time} - L∆∞·ª£t tr·∫≠n ${matches.filter(m => m.time === time).length / state.courts.length}</h6>`;
                currentHeader = time;
            }
            
            const match = groupedMatches[key][0]; // Ch·ªâ c√≥ 1 tr·∫≠n/time-court
            const matchIndexA = state.matchesA.findIndex(m => m.time === match.time && m.court === match.court);
            const matchIndexB = state.matchesB.findIndex(m => m.time === match.time && m.court === match.court);
            const bang = matchIndexA !== -1 ? 'A' : 'B';
            const index = matchIndexA !== -1 ? matchIndexA : matchIndexB;
            const dataSet = bang === 'A' ? 'A' : 'B';
            
            const teamAClass = match.winner === match.teamA ? 'winner' : (match.loser === match.teamA ? 'loser' : '');
            const teamBClass = match.winner === match.teamB ? 'winner' : (match.loser === match.teamB ? 'loser' : '');
            
            html += `
                <div class="card card-body p-2 mb-2 bg-light shadow-sm">
                    <div class="d-flex justify-content-between align-items-center">
                        <span class="badge bg-secondary me-2">${court}</span>
                        <div class="flex-grow-1 row g-1">
                            <div class="col-5 text-end ${teamAClass}">${match.teamA}</div>
                            <div class="col-2 text-center match-score-cell d-flex justify-content-center gap-1">
                                <input type="number" min="0" max="15" value="${match.scoreA === null ? '' : match.scoreA}" 
                                    onchange="updateMatchScore('${dataSet}', ${index}, 'A', this.value)" class="form-control form-control-sm" style="width: 45px;">
                                <span class="align-self-center">-</span>
                                <input type="number" min="0" max="15" value="${match.scoreB === null ? '' : match.scoreB}" 
                                    onchange="updateMatchScore('${dataSet}', ${index}, 'B', this.value)" class="form-control form-control-sm" style="width: 45px;">
                            </div>
                            <div class="col-5 text-start ${teamBClass}">${match.teamB}</div>
                        </div>
                    </div>
                </div>`;
        }
    } else {
        // Render Table View (Group by Team)
        const allTeams = [...state.mixedTeams, ...state.maleTeams];
        const currentMatches = [...state.matchesA, ...state.matchesB];
        
        html += `<div class='table-responsive'><table class='table table-sm table-bordered'>
            <thead class='table-dark'><tr><th>ƒê·ªôi</th>`;
        allTeams.forEach(team => html += `<th>${team.split('/').slice(-1)}</th>`); // T√™n cu·ªëi c√πng
        html += `<th>W-L</th></tr></thead><tbody>`;

        allTeams.forEach(teamA => {
            html += `<tr><th>${teamA}</th>`;
            allTeams.forEach(teamB => {
                if (teamA === teamB) {
                    html += `<td class="bg-dark text-white">X</td>`;
                } else {
                    const match = currentMatches.find(m => 
                        (m.teamA === teamA && m.teamB === teamB) || (m.teamA === teamB && m.teamB === teamA)
                    );
                    if (match) {
                        const scoreA = match.teamA === teamA ? match.scoreA : match.scoreB;
                        const scoreB = match.teamA === teamA ? match.scoreB : match.scoreA;
                        
                        let cellClass = '';
                        let cellText = `${scoreA !== null ? scoreA : '-'} - ${scoreB !== null ? scoreB : '-'}`;
                        
                        if (scoreA !== null && scoreB !== null) {
                            if (scoreA > scoreB) {
                                cellClass = 'bg-success text-white';
                                cellText = `W (${scoreA}-${scoreB})`;
                            } else if (scoreB > scoreA) {
                                cellClass = 'bg-danger text-white';
                                cellText = `L (${scoreA}-${scoreB})`;
                            } else {
                                cellClass = 'bg-warning';
                            }
                        }
                        
                        html += `<td class="${cellClass}">${cellText}</td>`;
                    } else {
                        html += `<td>-</td>`;
                    }
                }
            });
            
            const stats = [...state.tableA, ...state.tableB].find(t => t.team === teamA) || { wins: 0, losses: 0 };
            html += `<td>${stats.wins}-${stats.losses}</td>`;
            html += `</tr>`;
        });
        
        html += `</tbody></table></div>`;
    }

    return html;
}

/**
 * H√†m c·∫≠p nh·∫≠t ƒëi·ªÉm s·ªë tr·∫≠n ƒë·∫•u.
 * @param {string} bang - 'A' ho·∫∑c 'B'
 * @param {number} index - Ch·ªâ s·ªë tr·∫≠n ƒë·∫•u trong m·∫£ng matchesA/matchesB
 * @param {string} team - 'A' ho·∫∑c 'B' (t∆∞∆°ng ·ª©ng v·ªõi teamA/teamB trong match object)
 * @param {string} scoreStr - Gi√° tr·ªã ƒëi·ªÉm s·ªë m·ªõi (string)
 */
function updateMatchScore(bang, index, team, scoreStr) {
    const score = parseInt(scoreStr) || 0; 
    let match;
    let matches;

    if (bang === 'A') {
        matches = state.matchesA;
    } else {
        matches = state.matchesB;
    }

    match = matches[index];

    if (!match) return;
    
    // ƒê·∫£m b·∫£o ƒëi·ªÉm s·ªë h·ª£p l·ªá (t·ª´ 0 ƒë·∫øn 15, v√† ph·∫£i th·∫Øng 15)
    if (score < 0 || score > 15) return;

    if (team === 'A') {
        match.scoreA = score;
    } else if (team === 'B') {
        match.scoreB = score;
    }

    // T·ª± ƒë·ªông g√°n winner/loser khi c·∫£ hai ƒëi·ªÉm ƒë√£ ƒë∆∞·ª£c nh·∫≠p
    if (match.scoreA !== null && match.scoreB !== null) {
        if (match.scoreA === 15 && match.scoreB <= 14) {
            match.winner = match.teamA;
            match.loser = match.teamB;
        } else if (match.scoreB === 15 && match.scoreA <= 14) {
            match.winner = match.teamB;
            match.loser = match.teamA;
        } else if (match.scoreA === 15 && match.scoreB === 15) {
             // Invalid state, reset winner/loser
            match.winner = null;
            match.loser = null;
            match.scoreA = null;
            match.scoreB = null;
            showModal('L·ªói ƒêi·ªÉm s·ªë', 'Tr·∫≠n ƒë·∫•u kh√¥ng th·ªÉ k·∫øt th√∫c v·ªõi t·ªâ s·ªë 15-15. Vui l√≤ng nh·∫≠p l·∫°i ƒëi·ªÉm (ch·ªâ th·∫Øng khi ƒë·∫°t 15 ƒëi·ªÉm v√† ƒë·ªëi th·ªß d∆∞·ªõi 15).');
            renderMatchesView(); // Re-render ƒë·ªÉ reset input
            return;
        } else {
            match.winner = null;
            match.loser = null;
        }
    } else {
        match.winner = null;
        match.loser = null;
    }

    // Sau khi c·∫≠p nh·∫≠t ƒëi·ªÉm, t√≠nh l·∫°i x·∫øp h·∫°ng
    tinhVaCapNhatXepHang();
    
    // C·∫≠p nh·∫≠t giao di·ªán (·ªü tab ƒëang xem)
    renderMatchesView(); 
    renderOverview(); // C·∫≠p nh·∫≠t t·ªïng quan
    
    stateChanged = true;
    saveToGitHub();
}

/**
 * H√†m render Matches View ch√≠nh (Table/Court)
 */
function renderMatchesView() {
    const viewMode = document.getElementById('viewMode').value;
    const container = document.getElementById('matchesViewContent');
    
    let html = '';
    
    if (viewMode === 'table') {
        html = `
            <h6 class="mt-4">B·∫£ng A (Nam - N·ªØ) & B·∫£ng B (Nam) - Ch·∫ø ƒë·ªô xem ƒê·ªëi ƒë·∫ßu</h6>
            ${createMatchesHTML([...state.matchesA, ...state.matchesB], 'table')}
        `;
        document.getElementById('scheduleAHeader').style.display = 'none';
        document.getElementById('tableMatchesA').style.display = 'none';
        document.getElementById('tableMatchesB').style.display = 'none';
        container.innerHTML = html;
        
    } else { // viewMode === 'court'
        const courtsMixed = state.courts.filter(c => c.isMixed).map(c => c.name);
        const courtsMale = state.courts.filter(c => !c.isMixed).map(c => c.name);
        const allMatches = [...state.matchesA, ...state.matchesB];
        
        let courtViewHtml = '';
        state.courts.forEach(court => {
            const courtMatches = allMatches.filter(m => m.court === court.name);
            if (courtMatches.length > 0) {
                 courtViewHtml += `<h6 class="mt-4 border-bottom pb-1 text-info">${court.name} (${court.isMixed ? 'B·∫£ng A' : 'B·∫£ng B'} - ${courtMatches.length} tr·∫≠n)</h6>`;
                 courtViewHtml += createMatchesHTML(courtMatches, 'court', court.name);
            }
        });
        
        container.innerHTML = courtViewHtml || `<div class="alert alert-info mt-4">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u n√†o ƒë∆∞·ª£c t·∫°o.</div>`;
    }
}

/**
 * Kh·ªüi t·∫°o Match List (m·∫∑c ƒë·ªãnh l√† Round Robin)
 */
function createRoundRobinMatches(teams, bang, courtType) {
    const matches = [];
    for (let i = 0; i < teams.length; i++) {
        for (let j = i + 1; j < teams.length; j++) {
            matches.push({
                teamA: teams[i],
                teamB: teams[j],
                scoreA: null,
                scoreB: null,
                bang: bang, // 'A' or 'B'
                time: null,
                court: null,
                winner: null,
                loser: null
            });
        }
    }
    return matches;
}

/**
 * H√†m l√™n l·ªãch thi ƒë·∫•u T·ªëi ∆∞u: Round Robin + G√°n s√¢n/gi·ªù h·ª£p l√Ω
 */
function taoLichThiDauCungGio() {
    if (state.mixedTeams.length < 2 || state.maleTeams.length < 2) {
         showModal('L·ªói', 'C·∫ßn t·ªëi thi·ªÉu 2 ƒë·ªôi cho m·ªói b·∫£ng (A v√† B) ƒë·ªÉ t·∫°o l·ªãch ƒë·∫•u v√≤ng tr√≤n.');
         return;
    }
    
    if (!confirm("B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën t·∫°o l·∫°i l·ªãch thi ƒë·∫•u T·ªëi ∆∞u? To√†n b·ªô l·ªãch hi·ªán t·∫°i v√† k·∫øt qu·∫£ s·∫Ω b·ªã X√ìA.")) return;

    // 1. Kh·ªüi t·∫°o matches A & B
    state.matchesA = createRoundRobinMatches(state.mixedTeams, 'A', true);
    state.matchesB = createRoundRobinMatches(state.maleTeams, 'B', false);
    
    if (state.matchesA.length === 0 && state.matchesB.length === 0) {
        showModal('L·ªói L·ªãch', 'Kh√¥ng ƒë·ªß ƒë·ªôi ƒë·ªÉ t·∫°o l·ªãch (min 2 ƒë·ªôi/b·∫£ng).');
        return;
    }
    
    // 2. L·∫•y danh s√°ch s√¢n theo lo·∫°i
    const mixedCourts = state.courts.filter(c => c.isMixed);
    const maleCourts = state.courts.filter(c => !c.isMixed);
    
    if (mixedCourts.length === 0 || maleCourts.length === 0) {
        showModal('L·ªói C·∫•u h√¨nh S√¢n', 'Kh√¥ng t√¨m th·∫•y s√¢n cho c·∫£ B·∫£ng A (Nam-N·ªØ) v√† B·∫£ng B (Nam). Vui l√≤ng c·∫•u h√¨nh s√¢n.');
        return;
    }

    // 3. Chu·∫©n b·ªã Match List (L·∫∑p lu√¢n phi√™n A v√† B)
    const totalMatches = [...state.matchesA, ...state.matchesB];
    const maxMatches = Math.max(state.matchesA.length, state.matchesB.length);
    
    // L·ªãch tr√¨nh T·ªëi ∆∞u: L·∫ßn l∆∞·ª£t g√°n tr·∫≠n A r·ªìi tr·∫≠n B
    let matchesToSchedule = [];
    for (let i = 0; i < maxMatches; i++) {
        if (state.matchesA[i]) matchesToSchedule.push(state.matchesA[i]);
        if (state.matchesB[i]) matchesToSchedule.push(state.matchesB[i]);
    }

    // 4. G√°n gi·ªù v√† s√¢n
    let currentSlot = { hour: 14, minute: 0 };
    const matchDurationMinutes = 15; // Gi·∫£ ƒë·ªãnh 15 ph√∫t/tr·∫≠n
    let matchIndex = 0;

    // T√≠nh to√°n th·ªùi gian k·∫øt th√∫c c·ªßa s√¢n
    const courtEndTimes = state.courts.reduce((acc, court) => {
        const [h, m] = court.startTime.split(':').map(Number);
        const startTimeInMinutes = h * 60 + m;
        acc[court.name] = startTimeInMinutes + court.maxDurationMinutes;
        return acc;
    }, {});
    
    let matchCounterA = 0;
    let matchCounterB = 0;
    
    let scheduledMatchesA = [];
    let scheduledMatchesB = [];
    
    // L·∫∑p qua t·ª´ng l∆∞·ª£t tr·∫≠n (Time Slot)
    while (matchIndex < matchesToSchedule.length) {
        const timeSlot = `${String(currentSlot.hour).padStart(2, '0')}:${String(currentSlot.minute).padStart(2, '0')}`;
        
        // L·∫•y danh s√°ch s√¢n c√≥ th·ªÉ s·ª≠ d·ª•ng (ch∆∞a h·∫øt gi·ªù)
        const availableCourts = state.courts.filter(court => {
            const currentTimeInMinutes = currentSlot.hour * 60 + currentSlot.minute;
            return currentTimeInMinutes + matchDurationMinutes <= courtEndTimes[court.name];
        });
        
        if (availableCourts.length === 0) {
            showModal('K·∫øt th√∫c L·ªãch', `ƒê√£ h·∫øt th·ªùi gian t·ªëi ƒëa ƒë·ªÉ l√™n l·ªãch thi ƒë·∫•u l√∫c ${timeSlot}. (Vui l√≤ng ƒëi·ªÅu ch·ªânh th·ªùi gian t·ªëi ƒëa trong C·∫•u h√¨nh S√¢n).`);
            break;
        }
        
        let courtsUsedInSlot = [];
        
        // G√°n tr·∫≠n ƒë·∫•u cho c√°c s√¢n kh·∫£ d·ª•ng trong time slot n√†y
        for (const court of availableCourts) {
            let match = matchesToSchedule[matchIndex];
            
            if (!match) continue; 
            
            // ƒê·∫£m b·∫£o lo·∫°i tr·∫≠n ƒë·∫•u kh·ªõp v·ªõi lo·∫°i s√¢n
            const isMatchMixed = match.bang === 'A';
            if (court.isMixed === isMatchMixed) {
                match.time = timeSlot;
                match.court = court.name;
                courtsUsedInSlot.push(court.name);
                
                if (match.bang === 'A') {
                    scheduledMatchesA.push(match);
                } else {
                    scheduledMatchesB.push(match);
                }
                
                matchIndex++; // Chuy·ªÉn sang tr·∫≠n ti·∫øp theo
            }
        }
        
        // Chuy·ªÉn sang Time Slot ti·∫øp theo (15 ph√∫t sau)
        currentSlot.minute += matchDurationMinutes;
        if (currentSlot.minute >= 60) {
            currentSlot.hour += Math.floor(currentSlot.minute / 60);
            currentSlot.minute = currentSlot.minute % 60;
        }
    }
    
    state.matchesA = scheduledMatchesA;
    state.matchesB = scheduledMatchesB;
    
    // Reset v√≤ng chung k·∫øt
    scheduleFinalsReset();
    
    renderMatchesView();
    renderOverview();
    
    stateChanged = true;
    saveToGitHub();
    showModal('Th√†nh c√¥ng', `ƒê√£ t·∫°o ${state.matchesA.length + state.matchesB.length} tr·∫≠n ƒë·∫•u (A: ${state.matchesA.length}, B: ${state.matchesB.length}) theo l·ªãch T·ªëi ∆∞u.`);
}

/**
 * H√†m t·∫°o l·ªãch C·ªë ƒë·ªãnh t·ª´ FIXED_SCHEDULE_CSV
 */
function taoLichCoDinh() {
    if (!confirm("B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën t·∫£i l·ªãch C·ªë ƒë·ªãnh? To√†n b·ªô l·ªãch hi·ªán t·∫°i v√† k·∫øt qu·∫£ s·∫Ω b·ªã X√ìA.")) return;

    // Reset matches and finals
    state.matchesA = [];
    state.matchesB = [];
    scheduleFinalsReset();
    
    // Logic parse CSV
    const rows = FIXED_SCHEDULE_CSV.trim().split('\n').slice(1); // B·ªè header
    const headers = ['start_time', 'end_time', 'round', 'S√¢n 1', 'S√¢n 2', 'S√¢n 3', 'S√¢n 7'];
    
    const allTeams = [...state.mixedTeams, ...state.maleTeams];

    rows.forEach(row => {
        const values = row.split(',').map(v => v.trim());
        const time = values[0];
        
        // C·ªôt S√¢n b·∫Øt ƒë·∫ßu t·ª´ index 3
        for (let i = 3; i < 7; i++) {
            const matchStr = values[i];
            const courtName = headers[i];
            
            if (matchStr && matchStr.includes(' - ')) {
                const [teamA, teamB] = matchStr.split(' - ').map(t => t.trim());
                
                // X√°c ƒë·ªãnh b·∫£ng A hay B (d·ª±a tr√™n ƒë·ªôi c√≥ trong mixedTeams hay maleTeams)
                let bang = null;
                if (state.mixedTeams.includes(teamA) || state.mixedTeams.includes(teamB)) {
                    bang = 'A';
                } else if (state.maleTeams.includes(teamA) || state.maleTeams.includes(teamB)) {
                    bang = 'B';
                }
                
                if (bang) {
                    const newMatch = {
                        teamA,
                        teamB,
                        scoreA: null,
                        scoreB: null,
                        bang: bang,
                        time: time,
                        court: courtName,
                        winner: null,
                        loser: null
                    };
                    
                    if (bang === 'A') {
                        state.matchesA.push(newMatch);
                    } else {
                        state.matchesB.push(newMatch);
                    }
                } else {
                    console.warn(`ƒê·ªôi ${teamA}/${teamB} kh√¥ng t√¨m th·∫•y trong danh s√°ch ƒë·ªôi A ho·∫∑c B. B·ªè qua tr·∫≠n ƒë·∫•u.`);
                }
            }
        }
    });

    renderMatchesView();
    renderOverview();
    
    stateChanged = true;
    saveToGitHub();
    showModal('Th√†nh c√¥ng', `ƒê√£ t·∫£i ${state.matchesA.length + state.matchesB.length} tr·∫≠n ƒë·∫•u t·ª´ l·ªãch C·ªë ƒë·ªãnh.`);
}

/**
 * X√≥a to√†n b·ªô l·ªãch thi ƒë·∫•u (V√≤ng B·∫£ng v√† Chung k·∫øt)
 */
function clearAllSchedules() {
    if (confirm("B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën X√ìA TO√ÄN B·ªò l·ªãch thi ƒë·∫•u v√† k·∫øt qu·∫£ v√≤ng b·∫£ng/chung k·∫øt?")) {
        state.matchesA = [];
        state.matchesB = [];
        scheduleFinalsReset();
        tinhVaCapNhatXepHang();
        
        renderMatchesView();
        renderFinals();
        renderOverview();
        
        stateChanged = true;
        saveToGitHub();
        showModal('Th√†nh c√¥ng', 'ƒê√£ x√≥a to√†n b·ªô l·ªãch thi ƒë·∫•u v√† k·∫øt qu·∫£.');
    }
}

/**
 * ƒêi·ªÅn k·∫øt qu·∫£ t·ª± ƒë·ªông (11 - X, ch·ªâ cho c√°c tr·∫≠n ch∆∞a ƒë·∫•u)
 */
function autoFillScores() {
    if (!confirm("B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën T·ª∞ ƒê·ªòNG ƒëi·ªÅn k·∫øt qu·∫£ cho T·∫§T C·∫¢ tr·∫≠n ch∆∞a ƒë·∫•u (V√≤ng B·∫£ng v√† Chung k·∫øt)?")) return;

    // V√≤ng b·∫£ng
    [...state.matchesA, ...state.matchesB].forEach(match => {
        if (match.scoreA === null && match.scoreB === null) {
            // Randomly assign a winner (15 - X)
            if (Math.random() < 0.5) {
                match.scoreA = 15;
                match.scoreB = Math.floor(Math.random() * 15); // ƒêi·ªÉm thua t·ª´ 0-14
            } else {
                match.scoreB = 15;
                match.scoreA = Math.floor(Math.random() * 15);
            }
            
            // C·∫≠p nh·∫≠t winner/loser
            if (match.scoreA === 15 && match.scoreB <= 14) {
                match.winner = match.teamA;
                match.loser = match.teamB;
            } else if (match.scoreB === 15 && match.scoreA <= 14) {
                match.winner = match.teamB;
                match.loser = match.teamA;
            }
        }
    });
    
    // T√≠nh l·∫°i x·∫øp h·∫°ng v√† l√™n l·ªãch chung k·∫øt
    tinhVaCapNhatXepHang();
    scheduleFinalsAuto();
    
    // V√≤ng chung k·∫øt (ch·ªâ ƒëi·ªÅn khi ƒë√£ c√≥ ƒë·ªôi th·ª±c t·∫ø)
    [...state.semifinals, state.final].forEach(match => {
        if (match.scoreA === null && match.scoreB === null) {
             // Ki·ªÉm tra n·∫øu c·∫∑p ƒë·∫•u ƒë√£ ƒë∆∞·ª£c g√°n ƒë·ªôi th·ª±c t·∫ø
            const isAssigned = match.teamA !== 'Nh·∫•t A' && match.teamA !== 'Th·∫Øng SF1' && match.teamA !== 'Nh·∫•t B';
            
            if (isAssigned) {
                 if (Math.random() < 0.5) {
                    match.scoreA = 15;
                    match.scoreB = Math.floor(Math.random() * 15); 
                } else {
                    match.scoreB = 15;
                    match.scoreA = Math.floor(Math.random() * 15);
                }
                
                // C·∫≠p nh·∫≠t winner/loser
                if (match.scoreA === 15 && match.scoreB <= 14) {
                    match.winner = match.teamA;
                    match.loser = match.teamB;
                } else if (match.scoreB === 15 && match.scoreA <= 14) {
                    match.winner = match.teamB;
                    match.loser = match.teamA;
                }
                
                if (match.id === 'F') {
                    match.runnerUp = match.loser;
                }
            }
        }
    });


    renderMatchesView();
    renderFinals();
    renderOverview();
    
    stateChanged = true;
    saveToGitHub();
    showModal('ƒêi·ªÉm t·ª± ƒë·ªông', 'ƒê√£ ƒëi·ªÅn ƒëi·ªÉm ng·∫´u nhi√™n (15 - X) cho c√°c tr·∫≠n ƒë·∫•u c√≤n l·∫°i.');
}

// --- Logic V√≤ng Chung K·∫øt (Finals) ---

/**
 * ƒê·∫∑t l·∫°i tr·∫°ng th√°i v√≤ng chung k·∫øt v·ªÅ m·∫∑c ƒë·ªãnh.
 */
function scheduleFinalsReset() {
    state.semifinals = [
        { id: 'SF1', teamA: 'Nh·∫•t A', teamB: 'Nh√¨ A', scoreA: null, scoreB: null, time: '16:30', court: 'S√¢n 1', winner: null, loser: null },
        { id: 'SF2', teamA: 'Nh·∫•t B', teamB: 'Nh√¨ B', scoreA: null, scoreB: null, time: '16:30', court: 'S√¢n 2', winner: null, loser: null }
    ];
    state.final = { id: 'F', teamA: 'Th·∫Øng SF1', teamB: 'Th·∫Øng SF2', scoreA: null, scoreB: null, time: '17:00', court: 'S√¢n 1', winner: null, runnerUp: null };
}

/**
 * L√™n l·ªãch v√≤ng chung k·∫øt T·ª∞ ƒê·ªòNG (d·ª±a tr√™n b·∫£ng x·∫øp h·∫°ng)
 */
function scheduleFinalsAuto() {
    tinhVaCapNhatXepHang();
    
    const tableA = state.tableA;
    const tableB = state.tableB;
    
    if (tableA.length < 2 || tableB.length < 2) {
        // Kh√¥ng hi·ªán modal n·∫øu ch·ªâ l√† l·ªói khi g·ªçi autoFillScores/load, ch·ªâ c·∫ßn reset.
        if (state.matchesA.length > 0 || state.matchesB.length > 0) {
             // Show warning only if group stage data exists but ranking is insufficient.
        } else {
             // If no matches were created, don't show the error, just reset.
             scheduleFinalsReset();
             renderFinals();
             return;
        }
        
    }
    
    // G√°n Nh·∫•t/Nh√¨ B·∫£ng (d√πng ƒë·ªôi ƒë·∫ßu ti√™n/th·ª© hai n·∫øu c√≥)
    const nhatA = tableA.length >= 1 ? tableA[0].team : 'Nh·∫•t A';
    const nhiA = tableA.length >= 2 ? tableA[1].team : 'Nh√¨ A';
    const nhatB = tableB.length >= 1 ? tableB[0].team : 'Nh·∫•t B';
    const nhiB = tableB.length >= 2 ? tableB[1].team : 'Nh√¨ B';
    
    // C·∫≠p nh·∫≠t V√≤ng B√°n k·∫øt (gi·ªØ nguy√™n k·∫øt qu·∫£ n·∫øu ƒë√£ c√≥)
    state.semifinals[0].teamA = nhatA;
    state.semifinals[0].teamB = nhiA;
    
    state.semifinals[1].teamA = nhatB;
    state.semifinals[1].teamB = nhiB;
    
    // Reset k·∫øt qu·∫£ B√°n k·∫øt n·∫øu ƒë·ªôi ƒë·∫•u ƒë√£ thay ƒë·ªïi (ho·∫∑c ch∆∞a c√≥)
    state.semifinals.forEach(sf => {
        if (!sf.winner && (sf.teamA === 'Nh·∫•t A' || sf.teamB === 'Nh√¨ A' || sf.teamA === 'Nh·∫•t B' || sf.teamB === 'Nh√¨ B')) {
            sf.scoreA = null;
            sf.scoreB = null;
            sf.loser = null;
        }
    });
    
    // C·∫≠p nh·∫≠t Chung k·∫øt
    state.final.teamA = state.semifinals[0].winner || 'Th·∫Øng SF1';
    state.final.teamB = state.semifinals[1].winner || 'Th·∫Øng SF2';
    
    // Reset Chung k·∫øt n·∫øu ƒë·ªôi ƒë·∫•u ƒë√£ thay ƒë·ªïi
    if (state.final.teamA === 'Th·∫Øng SF1' || state.final.teamB === 'Th·∫Øng SF2') {
        state.final.scoreA = null;
        state.final.scoreB = null;
        state.final.winner = null;
        state.final.runnerUp = null;
    }

    renderFinals();
    renderFinalResults();
    
    stateChanged = true;
    saveToGitHub();
    
    // Ch·ªâ show modal n·∫øu ƒë∆∞·ª£c g·ªçi t·ª´ n√∫t
    if (document.activeElement && document.activeElement.id !== 'matchesTabButton') {
        showModal('Th√†nh c√¥ng', 'ƒê√£ l√™n l·ªãch V√≤ng B√°n k·∫øt t·ª± ƒë·ªông d·ª±a tr√™n B·∫£ng x·∫øp h·∫°ng V√≤ng B·∫£ng.');
    }
}


/**
 * Render V√≤ng Chung K·∫øt
 */
function renderFinals() {
    const renderMatch = (match, dataSet) => {
        const teamAClass = match.winner === match.teamA ? 'winner' : (match.loser === match.teamA ? 'loser' : '');
        const teamBClass = match.winner === match.teamB ? 'winner' : (match.loser === match.teamB ? 'loser' : '');
        const dataIndex = dataSet === 'SF' ? state.semifinals.findIndex(m => m.id === match.id) : 0;
        const finalSet = dataSet === 'SF' ? 'semifinals' : 'final';
        
        // Ch·ªâ cho ph√©p nh·∫≠p ƒëi·ªÉm n·∫øu ƒë√£ c√≥ ƒë·ªôi th·ª±c t·∫ø
        const isAssigned = match.teamA !== 'Nh·∫•t A' && match.teamA !== 'Nh·∫•t B' && match.teamA !== 'Th·∫Øng SF1' && match.teamB !== 'Th·∫Øng SF2';
        const disabled = isAssigned ? '' : 'disabled';
        
        return `
            <div class="card card-body p-3 mb-3 shadow-sm ${match.winner ? 'border-success' : 'border-info'}">
                <div class="d-flex justify-content-between align-items-center">
                    <div>
                        <span class="badge bg-secondary me-2">${match.court} - ${match.time}</span>
                        <strong class="text-dark">${match.id === 'F' ? 'Chung k·∫øt' : match.id}</strong>
                    </div>
                    <div class="flex-grow-1 row g-1">
                        <div class="col-5 text-end ${teamAClass}">${match.teamA}</div>
                        <div class="col-2 text-center match-score-cell d-flex justify-content-center gap-1">
                            <input type="number" min="0" max="15" value="${match.scoreA === null ? '' : match.scoreA}" 
                                onchange="updateFinalScore('${finalSet}', ${dataIndex}, 'A', this.value)" 
                                class="form-control form-control-sm" style="width: 45px;" ${disabled}>
                            <span class="align-self-center">-</span>
                            <input type="number" min="0" max="15" value="${match.scoreB === null ? '' : match.scoreB}" 
                                onchange="updateFinalScore('${finalSet}', ${dataIndex}, 'B', this.value)" 
                                class="form-control form-control-sm" style="width: 45px;" ${disabled}>
                        </div>
                        <div class="col-5 text-start ${teamBClass}">${match.teamB}</div>
                    </div>
                </div>
            </div>
        `;
    };

    // Render B√°n k·∫øt
    const semifinalsHtml = state.semifinals.map(sf => renderMatch(sf, 'SF')).join('');
    document.getElementById('semifinalMatches').innerHTML = semifinalsHtml || 
        '<div class="alert alert-info">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u b√°n k·∫øt. Vui l√≤ng nh·∫•n "L√™n l·ªãch V√≤ng Chung k·∫øt" ·ªü tab V√≤ng B·∫£ng.</div>';
    
    // Render Chung k·∫øt
    document.getElementById('finalMatch').innerHTML = renderMatch(state.final, 'F');
}

/**
 * C·∫≠p nh·∫≠t ƒëi·ªÉm s·ªë cho V√≤ng Chung K·∫øt.
 */
function updateFinalScore(dataSet, index, team, scoreStr) {
    const score = parseInt(scoreStr) || 0; 
    let match;
    let matchesArray;

    if (dataSet === 'semifinals') {
        matchesArray = state.semifinals;
        match = matchesArray[index];
    } else { // final
        match = state.final;
    }
    
    // Kh√¥ng cho ph√©p nh·∫≠p ƒëi·ªÉm n·∫øu ch∆∞a c√≥ ƒë·ªôi th·ª±c t·∫ø
    if (!match || match.teamA === 'Nh·∫•t A' || match.teamA === 'Th·∫Øng SF1') return; 

    if (score < 0 || score > 15) return;

    if (team === 'A') {
        match.scoreA = score;
    } else if (team === 'B') {
        match.scoreB = score;
    }

    // G√°n winner/loser khi c·∫£ hai ƒëi·ªÉm ƒë√£ ƒë∆∞·ª£c nh·∫≠p
    if (match.scoreA !== null && match.scoreB !== null) {
        if (match.scoreA === 15 && match.scoreB <= 14) {
            match.winner = match.teamA;
            match.loser = match.teamB;
        } else if (match.scoreB === 15 && match.scoreA <= 14) {
            match.winner = match.teamB;
            match.loser = match.teamA;
        } else if (match.scoreA === 15 && match.scoreB === 15) {
             // Invalid state, reset
            match.winner = null;
            match.loser = null;
            match.scoreA = null;
            match.scoreB = null;
            showModal('L·ªói ƒêi·ªÉm s·ªë', 'Tr·∫≠n ƒë·∫•u kh√¥ng th·ªÉ k·∫øt th√∫c v·ªõi t·ªâ s·ªë 15-15. Vui l√≤ng nh·∫≠p l·∫°i ƒëi·ªÉm.');
            renderFinals();
            return;
        } else {
            match.winner = null;
            match.loser = null;
        }
    } else {
        match.winner = null;
        match.loser = null;
    }
    
    // Logic ƒë·∫∑c bi·ªát cho Chung k·∫øt
    if (dataSet === 'final' && match.winner) {
        match.runnerUp = match.loser;
    }
    
    // T·ª± ƒë·ªông c·∫≠p nh·∫≠t ƒë·ªôi v√†o Chung k·∫øt n·∫øu l√† B√°n k·∫øt
    if (dataSet === 'semifinals' && match.winner) {
        scheduleFinalsAuto(); // Ch·∫°y l·∫°i ƒë·ªÉ c·∫≠p nh·∫≠t Chung k·∫øt
    }
    
    renderFinals();
    renderFinalResults();
    renderOverview();
    
    stateChanged = true;
    saveToGitHub();
}

// --- Import/Export Logic ---

/**
 * X·ª≠ l√Ω file CSV ƒë∆∞·ª£c ch·ªçn (Import L·ªãch)
 */
function handleFileSelect(event) {
    const file = event.target.files[0];
    if (!file) {
        return;
    }

    if (!confirm("B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën Import L·ªãch t·ª´ CSV? To√†n b·ªô l·ªãch hi·ªán t·∫°i v√† k·∫øt qu·∫£ s·∫Ω b·ªã X√ìA.")) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
        const csvContent = e.target.result;
        importScheduleFromCSV(csvContent);
    };
    reader.readAsText(file);
}

/**
 * Logic parse v√† import l·ªãch t·ª´ CSV
 * Format d·ª± ki·∫øn: teamA,teamB,time,court,bang,scoreA,scoreB
 */
function importScheduleFromCSV(csvContent) {
    const rows = csvContent.split('\n').map(row => row.trim()).filter(row => row);
    if (rows.length < 2) {
        showModal('L·ªói Import', 'File CSV kh√¥ng h·ª£p l·ªá ho·∫∑c tr·ªëng.');
        return;
    }
    
    const headers = rows[0].split(',').map(h => h.trim().toLowerCase());
    const dataRows = rows.slice(1);
    
    const requiredHeaders = ['teama', 'teamb', 'time', 'court', 'bang'];
    if (!requiredHeaders.every(h => headers.includes(h))) {
        showModal('L·ªói Header', `File CSV thi·∫øu c√°c c·ªôt b·∫Øt bu·ªôc: ${requiredHeaders.join(', ')}.`);
        return;
    }
    
    const colIndex = requiredHeaders.reduce((acc, h) => {
        acc[h] = headers.indexOf(h);
        return acc;
    }, {});
    colIndex.scoreA = headers.indexOf('scorea');
    colIndex.scoreB = headers.indexOf('scoreb');

    state.matchesA = [];
    state.matchesB = [];
    scheduleFinalsReset();
    
    let importedCount = 0;
    
    dataRows.forEach(row => {
        const values = row.split(',').map(v => v.trim());
        
        const teamA = values[colIndex.teama];
        const teamB = values[colIndex.teamb];
        const bang = values[colIndex.bang].toUpperCase();
        
        if (teamA && teamB && (bang === 'A' || bang === 'B')) {
            const scoreA = colIndex.scoreA !== -1 && values[colIndex.scoreA] ? parseInt(values[colIndex.scoreA]) : null;
            const scoreB = colIndex.scoreB !== -1 && values[colIndex.scoreB] ? parseInt(values[colIndex.scoreB]) : null;
            
            let winner = null;
            let loser = null;
            
            if (scoreA !== null && scoreB !== null && scoreA !== scoreB) {
                 if (scoreA > scoreB) {
                    winner = teamA;
                    loser = teamB;
                } else if (scoreB > scoreA) {
                    winner = teamB;
                    loser = teamA;
                }
            }
            
            const newMatch = {
                teamA: teamA,
                teamB: teamB,
                time: values[colIndex.time],
                court: values[colIndex.court],
                bang: bang,
                scoreA: scoreA,
                scoreB: scoreB,
                winner: winner,
                loser: loser
            };
            
            if (bang === 'A') {
                state.matchesA.push(newMatch);
            } else {
                state.matchesB.push(newMatch);
            }
            importedCount++;
        }
    });

    tinhVaCapNhatXepHang();
    scheduleFinalsAuto();
    renderMatchesView();
    renderOverview();
    
    stateChanged = true;
    saveToGitHub();
    showModal('Th√†nh c√¥ng', `ƒê√£ Import ${importedCount} tr·∫≠n ƒë·∫•u t·ª´ file CSV.`);
}

/**
 * Export l·ªãch thi ƒë·∫•u (V√≤ng B·∫£ng) sang CSV
 */
function exportSchedule() {
    const matches = [...state.matchesA, ...state.matchesB];
    if (matches.length === 0) {
        showModal('L·ªói Export', 'Kh√¥ng c√≥ l·ªãch thi ƒë·∫•u n√†o ƒë·ªÉ Export.');
        return;
    }

    let csv = "teamA,teamB,time,court,bang,scoreA,scoreB\n";
    
    matches.forEach(m => {
        const scoreA = m.scoreA !== null ? m.scoreA : '';
        const scoreB = m.scoreB !== null ? m.scoreB : '';
        csv += `${m.teamA},${m.teamB},${m.time},${m.court},${m.bang},${scoreA},${scoreB}\n`;
    });

    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute("download", "schedule_export_" + new Date().toISOString().slice(0, 10) + ".csv");
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    showModal('Th√†nh c√¥ng', 'ƒê√£ Export l·ªãch thi ƒë·∫•u (V√≤ng B·∫£ng) th√†nh file CSV.');
}

/**
 * H√†m tr·ªëng ƒë·ªÉ renderMatches (v√¨ renderMatchesView ƒë√£ ƒë·∫£m nh·∫≠n)
 */
function renderMatches() {
    // Ch·ªâ c·∫ßn g·ªçi renderMatchesView khi c·∫ßn
}
</script>
</body>
</html>
