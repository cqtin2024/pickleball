<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TKD Championship 2025 ‚Äî Qu·∫£n l√Ω gi·∫£i Pickleball V28 GitHub (Logic Auto-seed B√°n k·∫øt 100%)</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body { background:#f7f9fc; font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial; color:#222; padding:18px; }
    .tab-content { margin-top: 18px; }
    .logo { 
      width:64px; 
      height:64px; 
      object-fit:contain; 
      border-radius:8px; 
      border:1px solid #e6eefc; 
      padding:6px; 
      background:#fff; 
    }
    table th { background:#0d6efd; color:#fff; position:sticky; top:0; }
    .status { font-size:0.95rem; color:#555; }
    /* Responsive adjustment for match inputs */
    .match-score-cell input {
      width: 45px;
      text-align: center;
      padding: 0.1rem;
    }
    @media (max-width: 576px) {
      .match-score-cell input {
        width: 35px;
      }
    }
    .winner { font-weight: bold; color: green; }
    .loser { color: red; }
    .ranking-container { display: flex; flex-direction: column; gap: 20px; }
    @media (min-width: 768px) {
        .ranking-container > div { flex: 1; }
    }
  </style>
</head>
<body onload="initApp()">
<div class="container">
  <div class="d-flex justify-content-between align-items-center mb-3">
    <div class="d-flex align-items-center gap-2">
      <img class="logo" src="data/logoTKD.png" alt="Logo TKD">
      <div>
        <h3 class="mb-0">TKD Championship 2025</h3>
        <div>Ng√†y thi ƒë·∫•u: 18/10/2025 (**V28**)</div>
      </div>
    </div>
    <div>
      <div id="autoSaveStatus" class="text-end status">Auto-save (30s): <span id="autoState" class="text-danger">T·∫Øt</span></div>
      <div id="lastSaved" class="text-end status">Ch∆∞a l∆∞u</div>
    </div>
  </div>

  <ul class="nav nav-tabs" id="mainTabs">
    <li class="nav-item"><button class="nav-link active" data-bs-toggle="tab" data-bs-target="#overview" onclick="renderOverview()">T·ªïng quan</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#matches" id="matchesTabButton" onclick="renderMatchesView()">V√≤ng B·∫£ng</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#finals" onclick="renderFinals()">V√≤ng Chung K·∫øt</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#results" onclick="tinhVaCapNhatXepHang(); renderFinalResults();">K·∫øt qu·∫£ Chung cu·ªôc</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#config" id="configTabButton" onclick="renderConfig()">C·∫•u h√¨nh</button></li>
  </ul>

  <div class="tab-content">
    <div class="tab-pane fade show active p-3" id="overview">
        <div id="overviewContent">ƒêang t·∫£i d·ªØ li·ªáu...</div>
    </div>
    
    <div class="tab-pane fade p-3" id="matches">
      <div class="d-flex gap-2 mb-3 flex-wrap">
        <label for="viewMode" class="form-label mb-0 align-self-center text-nowrap">Ch·∫ø ƒë·ªô xem:</label>
        <select id="viewMode" class="form-select form-select-sm w-auto" onchange="renderMatchesView()">
            <option value="table">Theo B·∫£ng ƒë·∫•u</option>
            <option value="court" selected>Theo S√¢n thi ƒë·∫•u</option>
        </select>
        
        <button class="btn btn-sm btn-info ms-auto" onclick="document.getElementById('fileInput').click()">Import L·ªãch (CSV)</button>
        <input type="file" id="fileInput" accept=".csv" style="display: none;" onchange="handleFileSelect(event)">
        
        <button class="btn btn-sm btn-warning" onclick="exportSchedule()">Export L·ªãch (CSV)</button>
      </div>
      
      <div id="matchesViewContent">
        <h6 id="scheduleAHeader" class="mt-4">B·∫£ng A (Nam - N·ªØ)</h6><div id="tableMatchesA">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u.</div>
        
        <h6 class="mt-4">B·∫£ng B (Nam)</h6><div id="tableMatchesB">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u.</div>
      </div>

      <button class="btn btn-warning mt-4" onclick="scheduleFinalsAuto()">L√™n l·ªãch V√≤ng Chung k·∫øt (T·ª± ƒë·ªông h√≥a)</button>
    </div>

    <div class="tab-pane fade p-3" id="finals">
        <div id="finalsContent">
            <h6 class="mt-4">V√≤ng B√°n k·∫øt (SF1: 16:40, SF2: 17:05, S√¢n 3)</h6>
            <div id="semifinalMatches">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u b√°n k·∫øt. K·∫øt qu·∫£ V√≤ng B·∫£ng s·∫Ω t·ª± ƒë·ªông c·∫≠p nh·∫≠t l·ªãch.</div>

            <h6 class="mt-4">Tr·∫≠n Chung k·∫øt (17:30, S√¢n 3)</h6>
            <div id="finalMatch">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u chung k·∫øt.</div>
        </div>
    </div>

    <div class="tab-pane fade p-3" id="results">
        <h5 class="mb-3">B·∫£ng x·∫øp h·∫°ng V√≤ng B·∫£ng (∆Øu ti√™n: W > ƒê·ªëi ƒë·∫ßu > Hi·ªáu s·ªë > T·ªïng ƒëi·ªÉm)</h5>
        <div id="rankingTables" class="ranking-container">
            </div>

        <hr class="my-4">

        <h5 class="mb-3">Danh hi·ªáu Chung cu·ªôc</h5>
        <p id="champion">V√¥ ƒë·ªãch: ƒêang ch·ªù k·∫øt qu·∫£...</p>
        <p id="runnerUp">√Å qu√¢n: ƒêang ch·ªù k·∫øt qu·∫£...</p>
        <p id="thirdPlace">H·∫°ng Ba ƒê·ªìng H·∫°ng: ƒêang ch·ªù k·∫øt qu·∫£...</p>
    </div>

    <div class="tab-pane fade p-3" id="config">
      <h5 class="mb-3">C√¥ng c·ª• L·∫≠p & ƒêi·ªÅn L·ªãch Thi ƒë·∫•u</h5>
      <div class="d-flex gap-2 mb-4 flex-wrap">
        <button class="btn btn-sm btn-primary" onclick="taoLichThiDauCungGio()">T·∫°o l·ªãch thi ƒë·∫•u T·ªëi ∆∞u (T·ª± ƒë·ªông)</button>
        <button class="btn btn-sm btn-secondary" onclick="taoLichCoDinh()">T·∫£i l·ªãch M·∫´u (**CalendarTKD30**)</button>
        <button class="btn btn-sm btn-success" onclick="autoFillScores()">ƒêi·ªÅn k·∫øt qu·∫£ T·ª± ƒë·ªông (11 - X)</button>
        <button class="btn btn-sm btn-danger" onclick="clearAllSchedules()">X√≥a To√†n b·ªô L·ªãch</button>
      </div>
      
      <hr>
      
      <h5 class="mt-4">üßπ C√¥ng c·ª• X√≥a K·∫øt qu·∫£ V√≤ng B·∫£ng</h5>
      <div class="d-flex gap-2 mb-4 flex-wrap">
          <button class="btn btn-sm btn-outline-danger" onclick="clearGroupScores('A')">X√≥a K·∫øt qu·∫£ B·∫£ng A</button>
          <button class="btn btn-sm btn-outline-danger" onclick="clearGroupScores('B')">X√≥a K·∫øt qu·∫£ B·∫£ng B</button>
          <button class="btn btn-sm btn-danger ms-auto" onclick="clearGroupScores('ALL')">X√≥a To√†n b·ªô V√≤ng B·∫£ng</button>
      </div>
      <div id="clearScoreStatus"></div>
      <hr>
      <h5 class="mt-4">‚öôÔ∏è C·∫•u h√¨nh S√¢n thi ƒë·∫•u & L·ªãch T·ªëi ∆∞u</h5>
      <p class="text-muted small">Qu·∫£n l√Ω danh s√°ch s√¢n thi ƒë·∫•u. S√¢n ƒë∆∞·ª£c g√°n lo·∫°i b·∫£ng ƒë·∫•u (A/B) ƒë·ªÉ ph·ª•c v·ª• ch·ª©c nƒÉng t·∫°o l·ªãch T·ªëi ∆∞u.</p>
      <div class="d-flex gap-2 mb-3 flex-wrap">
          <button class="btn btn-sm btn-primary" onclick="openCourtModal()">+ Th√™m S√¢n M·ªõi</button>
          <button class="btn btn-sm btn-outline-info" onclick="loadDefaultCourtConfig()">T·∫£i c·∫•u h√¨nh M·∫∑c ƒë·ªãnh</button>
      </div>
      <div id="courtListContainer">
          </div>
      <div id="courtConfigStatus"></div>
      <hr>
      
      <h5 class="mt-4">üõ†Ô∏è C·∫•u h√¨nh T·ªëi ∆∞u L·ªãch thi ƒë·∫•u</h5>
      <div class="row g-2 mb-4">
        <div class="col-md-6">
          <label for="preferredCourtType" class="form-label">∆Øu ti√™n S√¢n n√†o cho tr·∫≠n ƒë·∫ßu ti√™n (Ch·ª©c nƒÉng T·∫°o l·ªãch T·ªëi ∆∞u)?</label>
          <select id="preferredCourtType" class="form-select" onchange="updatePreferredCourtType()">
            <option value="mixed">B·∫£ng A (Nam - N·ªØ) - M·∫∑c ƒë·ªãnh</option>
            <option value="male">B·∫£ng B (Nam)</option>
          </select>
          <div class="form-text">X√°c ƒë·ªãnh lo·∫°i s√¢n s·∫Ω ƒë∆∞·ª£c ∆∞u ti√™n g√°n tr·∫≠n ƒë·∫•u ƒë·∫ßu ti√™n trong thu·∫≠t to√°n t·∫°o l·ªãch.</div>
        </div>
        <div class="col-md-6">
            <label class="form-label">C√¥ng c·ª• Xu·∫•t/L∆∞u D·ªØ li·ªáu</label>
            <div class="d-flex gap-2">
                 <button class="btn btn-success" onclick="saveToGitHub(true)">C·∫≠p nh·∫≠t l√™n GitHub ngay</button>
                 <button class="btn btn-secondary" onclick="exportDataToJson()">Xu·∫•t t·∫•t c·∫£ ra JSON</button>
            </div>
            <div class="form-text">L∆∞u tr·∫°ng th√°i hi·ªán t·∫°i (state.json) l√™n GitHub ho·∫∑c t·∫£i v·ªÅ m√°y.</div>
        </div>
      </div>
      <hr>
      <h5 class="mt-4">üíæ C·∫•u h√¨nh K·∫øt n·ªëi GitHub</h5>
      <p class="text-muted">Nh·∫≠p th√¥ng tin kho l∆∞u tr·ªØ GitHub ƒë·ªÉ t·ª± ƒë·ªông l∆∞u tr·ªØ d·ªØ li·ªáu gi·∫£i ƒë·∫•u (Auto-save: 30s).</p>
      <div class="row g-2 mb-2">
        <div class="col-md-3"><input id="cfgOwner" class="form-control" placeholder="Owner (V√≠ d·ª•: user_name)"></div>
        <div class="col-md-3"><input id="cfgRepo" class="form-control" placeholder="Repo (V√≠ d·ª•: my-data-repo)"></div>
        <div class="col-md-3"><input id="cfgFolder" class="form-control" value="data"></div>
        <div class="col-md-3"><input id="cfgFile" class="form-control" value="state.json"></div>
      </div>
      <input id="cfgToken" type="password" class="form-control mb-2" placeholder="D√°n GitHub Personal Access Token (PAT) t·∫°i ƒë√¢y">
      <div class="d-flex gap-2">
        <button class="btn btn-primary" onclick="saveConfig()">L∆∞u c·∫•u h√¨nh Local</button>
        <button class="btn btn-success" onclick="checkConnection()">Ki·ªÉm tra & T·∫£i D·ªØ li·ªáu</button>
      </div>
      <div class="mt-2" id="configStatus"></div>
      
      <div class="card bg-light mt-4 shadow-sm">
        <div class="card-body">
            <h5 class="card-title text-info">üîë H∆∞·ªõng d·∫´n l·∫•y GitHub Token (PAT)</h5>
            <ol class="small mb-0">
                <li>Truy c·∫≠p <a href="https://github.com/settings/tokens" target="_blank" class="text-info">GitHub Tokens Settings</a> (B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p).</li>
                <li>Ch·ªçn **Generate new token** (ho·∫∑c **Generate new token (classic)** n·∫øu b·∫°n d√πng t√†i kho·∫£n c≈©).</li>
                <li>**T√™n Token:** ƒê·∫∑t t√™n d·ªÖ nh·ªõ (v√≠ d·ª•: `TKDManager_AutoSave`).</li>
                <li>**Th·ªùi h·∫°n:** Ch·ªçn t√πy √Ω (n√™n ch·ªçn 90 ng√†y ho·∫∑c T√πy ch·ªânh).</li>
                <li>**Ph·∫°m vi (Scopes):** **B·∫ÆT BU·ªòC** t√≠ch ch·ªçn √¥ **`repo`** (cho ph√©p truy c·∫≠p v√†o kho l∆∞u tr·ªØ).</li>
                <li>Nh·∫•n **Generate token** v√† **SAO CH√âP** chu·ªói Token v·ª´a ƒë∆∞·ª£c t·∫°o.</li>
                <li>D√°n chu·ªói Token ƒë√≥ v√†o √¥ "D√°n GitHub Personal Access Token (PAT) t·∫°i ƒë√¢y" b√™n tr√™n.</li>
            </ol>
            <p class="mt-2 mb-0 text-danger small">‚ö†Ô∏è **L∆∞u √Ω:** Token ch·ªâ hi·ªÉn th·ªã **M·ªòT L·∫¶N**. H√£y sao ch√©p ngay l·∫≠p t·ª©c v√† gi·ªØ b√≠ m·∫≠t. N·∫øu m·∫•t, b·∫°n ph·∫£i t·∫°o l·∫°i Token m·ªõi.</p>
        </div>
      </div>
      </div>
  </div>
</div>

<div class="modal fade" id="courtModal" tabindex="-1" aria-labelledby="courtModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="courtModalLabel">Th√™m/S·ª≠a C·∫•u h√¨nh S√¢n</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="courtForm">
          <input type="hidden" id="courtIndex" value="">
          <div class="mb-3">
            <label for="courtName" class="form-label">T√™n S√¢n</label>
            <input type="text" class="form-control" id="courtName" required>
          </div>
          <div class="mb-3">
            <label for="courtStartTime" class="form-label">Gi·ªù B·∫Øt ƒê·∫ßu (HH:mm)</label>
            <input type="time" class="form-control" id="courtStartTime" required>
          </div>
          <div class="mb-3">
            <label for="courtMaxDuration" class="form-label">Th·ªùi L∆∞·ª£ng T·ªëi ƒêa (Ph√∫t)</label>
            <input type="number" class="form-control" id="courtMaxDuration" min="1" required>
          </div>
          <div class="form-check mb-3">
            <input class="form-check-input" type="checkbox" id="courtIsMixed">
            <label class="form-check-label" for="courtIsMixed">
              D√†nh cho B·∫£ng A (Nam - N·ªØ)
            </label>
            <div class="form-text">N·∫øu kh√¥ng ch·ªçn, s√¢n s·∫Ω d√†nh cho B·∫£ng B (Nam).</div>
          </div>
          <div id="courtFormStatus" class="mt-2"></div>
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">H·ªßy</button>
        <button type="button" class="btn btn-primary" onclick="saveCourtChanges()">L∆∞u Thay ƒê·ªïi</button>
      </div>
    </div>
  </div>
</div>
<div class="modal fade" id="customAlertModal" tabindex="-1" aria-labelledby="customAlertModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="customAlertModalLabel">Th√¥ng b√°o</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="customAlertModalBody">
        N·ªôi dung th√¥ng b√°o
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-primary" data-bs-dismiss="modal">ƒê√≥ng</button>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script> 

<script>
// D·ªØ li·ªáu l·ªãch c·ªë ƒë·ªãnh t·ª´ file CalendarTKD30.csv (ƒê√É C·∫¨P NH·∫¨T theo y√™u c·∫ßu)
const FIXED_SCHEDULE_CSV = `teamA,teamB,time,court,bang,scoreA,scoreB
Tri·ªÅu/Minh,Hi·ªÉn/P.H√πng,14:00,S√¢n 1,B,,
Giang/Long,H∆∞·ªùng/ƒê·∫°t,14:00,S√¢n 2,A,,
H·∫≠u/D≈©ng,H·∫°nh/Ti·∫øn,14:00,S√¢n 3,A,,
Huy·ªÅn/Lu√¢n,Linh/M.H√πng,14:00,S√¢n 7,A,,
Ti·ªáp/Th·ªßy,Ph∆∞∆°ng/Thanh,14:15,S√¢n 1,B,,
T√≠n/Khi√™m,√Ånh/To√†n,14:15,S√¢n 2,B,,
H·∫≠u/D≈©ng,H∆∞·ªùng/ƒê·∫°t,14:15,S√¢n 3,A,,
Giang/Long,Huy·ªÅn/Lu√¢n,14:15,S√¢n 7,A,,
Tri·ªÅu/Minh,T√≠n/Khi√™m,14:30,S√¢n 1,B,,
Ti·ªáp/Th·ªßy,Hi·ªÉn/P.H√πng,14:30,S√¢n 2,B,,
H·∫°nh/Ti·∫øn,Linh/M.H√πng,14:30,S√¢n 3,A,,
Ph∆∞∆°ng/Thanh,√Ånh/To√†n,14:30,S√¢n 7,B,,
Huy·ªÅn/Lu√¢n,H∆∞·ªùng/ƒê·∫°t,14:45,S√¢n 2,A,,
H·∫°nh/Ti·∫øn,Giang/Long,14:45,S√¢n 3,A,,
H·∫≠u/D≈©ng,Linh/M.H√πng,14:45,S√¢n 7,A,,
Ti·ªáp/Th·ªßy,√Ånh/To√†n,15:00,S√¢n 2,B,,
T√≠n/Khi√™m,Hi·ªÉn/P.H√πng,15:00,S√¢n 3,B,,
Ph∆∞∆°ng/Thanh,Tri·ªÅu/Minh,15:15,S√¢n 2,B,,
Giang/Long,Linh/M.H√πng,15:15,S√¢n 3,A,,
H·∫°nh/Ti·∫øn,H∆∞·ªùng/ƒê·∫°t,15:30,S√¢n 2,A,,
H·∫≠u/D≈©ng,Huy·ªÅn/Lu√¢n,15:30,S√¢n 3,A,,
Ti·ªáp/Th·ªßy,T√≠n/Khi√™m,15:45,S√¢n 2,B,,
Ph∆∞∆°ng/Thanh,Hi·ªÉn/P.H√πng,15:45,S√¢n 3,B,,
Tri·ªÅu/Minh,√Ånh/To√†n,16:00,S√¢n 2,B,,
H·∫≠u/D≈©ng,Giang/Long,16:00,S√¢n 3,A,,
H·∫°nh/Ti·∫øn,Huy·ªÅn/Lu√¢n,16:15,S√¢n 2,A,,
Linh/M.H√πng,H∆∞·ªùng/ƒê·∫°t,16:15,S√¢n 3,A,,
Ti·ªáp/Th·ªßy,Tri·ªÅu/Minh,16:30,S√¢n 2,B,,
√Ånh/To√†n,Hi·ªÉn/P.H√πng,16:30,S√¢n 3,B,,
Ph∆∞∆°ng/Thanh,T√≠n/Khi√™m,16:45,S√¢n 2,B,`;

// Bi·∫øn state l∆∞u tr·ªØ d·ªØ li·ªáu ch√≠nh c·ªßa ·ª©ng d·ª•ng.
let state = { 
  mixedTeams: [], // S·∫Ω ƒë∆∞·ª£c t·∫£i t·ª´ players.json
  maleTeams: [],  // S·∫Ω ƒë∆∞·ª£c t·∫£i t·ª´ players.json
  matchesA: [], 
  matchesB: [],
  tableA: [], // B·∫£ng x·∫øp h·∫°ng A (S·∫Ω ƒë∆∞·ª£c l∆∞u v√† t·∫£i)
  tableB: [], // B·∫£ng x·∫øp h·∫°ng B (S·∫Ω ƒë∆∞·ª£c l∆∞u v√† t·∫£i)
  
  // Court Configuration
  courts: [
    { name: 'S√¢n 1', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, 
    { name: 'S√¢n 2', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, 
    { name: 'S√¢n 3', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, 
    { name: 'S√¢n 4', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, 
    { name: 'S√¢n 5', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }, 
    { name: 'S√¢n 6', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }, 
    { name: 'S√¢n 7', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }, 
    { name: 'S√¢n 8', startTime: '14:00', maxDurationMinutes: 180, isMixed: false } 
  ],
  
  // LOGIC B√ÅN K·∫æT 
  semifinals: [
    { id: 'SF1', teamA: 'Nh·∫•t A', teamB: 'Nh√¨ B', scoreA: null, scoreB: null, time: '16:40', court: 'S√¢n 3', winner: null, loser: null }, 
    { id: 'SF2', teamA: 'Nh·∫•t B', teamB: 'Nh√¨ A', scoreA: null, scoreB: null, time: '17:05', court: 'S√¢n 3', winner: null, loser: null }  
  ],
  final: { id: 'F', teamA: 'Th·∫Øng SF1', teamB: 'Th·∫Øng SF2', scoreA: null, scoreB: null, time: '17:30', court: 'S√¢n 3', winner: null, runnerUp: null }, 
  config: { 
    preferredCourtType: 'mixed',
    owner: '', 
    repo: '', 
    folder: 'data', 
    file: 'state.json', 
    token: ''
  }
};

// ===============================================
// V26/V28 FIX: ƒê·ªãnh nghƒ©a c√°c Constants cho Reset
// ===============================================
const DEFAULT_SF1 = { id: 'SF1', teamA: 'Nh·∫•t A', teamB: 'Nh√¨ B', scoreA: null, scoreB: null, time: '16:40', court: 'S√¢n 3', winner: null, loser: null };
const DEFAULT_SF2 = { id: 'SF2', teamA: 'Nh·∫•t B', teamB: 'Nh√¨ A', scoreA: null, scoreB: null, time: '17:05', court: 'S√¢n 3', winner: null, loser: null };
const DEFAULT_FINAL = { id: 'F', teamA: 'Th·∫Øng SF1', teamB: 'Th·∫Øng SF2', scoreA: null, scoreB: null, time: '17:30', court: 'S√¢n 3', winner: null, runnerUp: null };
// ===============================================

let stateChanged = false; // Bi·∫øn c·ªù theo d√µi thay ƒë·ªïi d·ªØ li·ªáu
let currentSha = null; // Bi·∫øn l∆∞u tr·ªØ SHA c·ªßa file tr√™n GitHub
let autoSaveInterval = null; // Bi·∫øn l∆∞u tr·ªØ ID c·ªßa interval

// --- Kh·ªüi t·∫°o ·ª©ng d·ª•ng ---
function initApp() {
    loadConfig();
    checkConnection(); // T·∫£i config xong l√† check connection v√† load data lu√¥n
}

// --- Custom Modal Function ---
function showModal(title, body) {
    document.getElementById('customAlertModalLabel').textContent = title;
    document.getElementById('customAlertModalBody').innerHTML = body;
    const modal = new bootstrap.Modal(document.getElementById('customAlertModal'));
    modal.show();
}

/**
 * H√†m hi·ªÉn th·ªã th√¥ng b√°o tr·∫°ng th√°i t·∫°m th·ªùi
 * @param {string} id - ID c·ªßa div ch·ª©a status
 * @param {string} type - lo·∫°i alert (success, danger, info, warning)
 * @param {string} message - n·ªôi dung th√¥ng b√°o
 */
function updateStatus(id, type, message) {
    const statusDiv = document.getElementById(id);
    if (statusDiv) {
        statusDiv.innerHTML = `<div class="alert alert-${type} alert-dismissible fade show p-2 small" role="alert">
            ${message}
            <button type="button" class="btn-close p-2" data-bs-dismiss="alert" aria-label="Close"></button>
        </div>`;
    }
}

// --- Helper Functions cho Base64 ---
function b64EncodeUnicode(str) {
  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g,
    function(match, p1) {
      return String.fromCharCode('0x' + p1);
    }));
}

function b64DecodeUnicode(str) {
  return decodeURIComponent(atob(str).split('').map(function(c) {
    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
  }).join(''));
}

// --- GitHub API Functions ---

/**
 * L·∫•y SHA m·ªõi nh·∫•t v√† n·ªôi dung (Base64) c·ªßa file tr√™n GitHub.
 * **V27 FIX:** TƒÉng c∆∞·ªùng x·ª≠ l√Ω 404 (file kh√¥ng t·ªìn t·∫°i)
 * @param {object} cfg - C·∫•u h√¨nh GitHub (owner, repo, folder, file, token)
 * @param {string} fileName - T√™n file c·∫ßn l·∫•y SHA (m·∫∑c ƒë·ªãnh l√† cfg.file)
 * @returns {Promise<{sha: string|null, content: string|null}>}
 */
async function fetchFileSha(cfg, fileName = cfg.file) {
    const filePath = `${cfg.folder}/${fileName}`;
    const apiUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}/contents/${filePath}`;
    
    try {
        const response = await fetch(apiUrl, {
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });
        
        if (response.ok) {
            const data = await response.json();
            if (fileName === cfg.file) {
                 currentSha = data.sha; // Ch·ªâ l∆∞u SHA c·ªßa state.json
            }
            return { sha: data.sha, content: data.content };
        } else if (response.status === 404) {
            // Tr∆∞·ªùng h·ª£p file kh√¥ng t·ªìn t·∫°i: tr·∫£ v·ªÅ null m√† kh√¥ng b√°o l·ªói
            if (fileName === cfg.file) {
                 currentSha = null; 
            }
            return { sha: null, content: null };
        } else {
            // L·ªói kh√°c (401, 403, 500...)
            const errorData = await response.json();
            throw new Error(`L·ªói HTTP ${response.status}: ${errorData.message || response.statusText}`);
        }
    } catch (error) {
        console.error(`L·ªói Fetch SHA (${fileName}):`, error);
        throw new Error(`L·ªói k·∫øt n·ªëi ho·∫∑c API: ${error.message}`);
    }
}

/**
 * T·∫£i danh s√°ch ƒë·ªôi t·ª´ players.json
 * **V27 FIX:** ƒê·∫£m b·∫£o lu√¥n tr·∫£ v·ªÅ true/false v√† kh√¥ng b·ªã l·ªói n·∫øu players.json kh√¥ng t·ªìn t·∫°i.
 */
async function loadPlayersFromGitHub(cfg) {
    const fileName = 'players.json';
    
    try {
        updateStatus('configStatus', 'info', 'ƒêang t·∫£i danh s√°ch ƒë·ªôi t·ª´ GitHub (players.json)...');
        // fetchFileSha s·∫Ω tr·∫£ v·ªÅ {sha: null, content: null} n·∫øu 404
        const result = await fetchFileSha(cfg, fileName); 
        
        if (result.content) {
            const jsonString = b64DecodeUnicode(result.content);
            const loadedTeams = JSON.parse(jsonString);

            if (Array.isArray(loadedTeams.mixedTeams) && Array.isArray(loadedTeams.maleTeams)) {
                state.mixedTeams = loadedTeams.mixedTeams;
                state.maleTeams = loadedTeams.maleTeams;
                updateStatus('configStatus', 'success', `T·∫£i danh s√°ch ƒë·ªôi th√†nh c√¥ng (${state.mixedTeams.length + state.maleTeams.length} ƒë·ªôi).`);
                return true;
            } else {
                throw new Error("File players.json kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng (thi·∫øu mixedTeams/maleTeams).");
            }
        } else {
            // File kh√¥ng t·ªìn t·∫°i (404) ho·∫∑c tr·ªëng
            updateStatus('configStatus', 'warning', 'Kh√¥ng t√¨m th·∫•y file players.json. D√πng danh s√°ch ƒë·ªôi kh·ªüi t·∫°o (tr·ªëng).');
            return false;
        }
    } catch (error) {
        // X·ª≠ l√Ω l·ªói JSON Parse ho·∫∑c l·ªói k·∫øt n·ªëi. V·∫´n tr·∫£ v·ªÅ true ƒë·ªÉ cho ph√©p state.json load.
        console.error("L·ªói khi t·∫£i players.json:", error);
        updateStatus('configStatus', 'danger', `L·ªói t·∫£i danh s√°ch ƒë·ªôi: ${error.message}. S·ª≠ d·ª•ng d·ªØ li·ªáu tr·ªëng.`);
        return true; 
    }
}

/**
 * T·∫£i tr·∫°ng th√°i gi·∫£i ƒë·∫•u (state.json) t·ª´ GitHub.
 */
async function loadFromGitHub() {
    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) {
         updateStatus('configStatus', 'warning', 'Thi·∫øu th√¥ng tin k·∫øt n·ªëi GitHub. Vui l√≤ng nh·∫≠p Token/Repo.');
         return;
    }

    // 1. Load Teams (danh s√°ch ƒë·ªôi) - D√π l·ªói c≈©ng c·ªë g·∫Øng load state.json
    await loadPlayersFromGitHub(cfg); 

    // 2. Load App State (state.json)
    try {
        updateStatus('configStatus', 'info', 'ƒêang t·∫£i tr·∫°ng th√°i gi·∫£i ƒë·∫•u t·ª´ GitHub (state.json)...');
        // fetchFileSha s·∫Ω t·ª± ƒë·ªông c·∫≠p nh·∫≠t currentSha, v√† tr·∫£ v·ªÅ null n·∫øu 404
        const result = await fetchFileSha(cfg, cfg.file); 
        
        if (result.content) {
            const jsonString = b64DecodeUnicode(result.content);
            const loadedState = JSON.parse(jsonString);

            // Ghi ƒë√® c√°c gi√° tr·ªã kh√°c ngo√†i teams (teams ƒë√£ ƒë∆∞·ª£c load t·ª´ players.json)
            state.matchesA = loadedState.matchesA || [];
            state.matchesB = loadedState.matchesB || [];
            
            // NEW: T·∫£i b·∫£ng x·∫øp h·∫°ng n·∫øu c√≥ 
            state.tableA = loadedState.tableA || []; 
            state.tableB = loadedState.tableB || [];
            
            if (loadedState.courts) {
                state.courts = loadedState.courts;
            }
            
            // C·∫•u tr√∫c m·∫∑c ƒë·ªãnh m·ªõi cho b√°n k·∫øt/chung k·∫øt
            const defaultSF1Info = { teamA: 'Nh·∫•t A', teamB: 'Nh√¨ B', court: 'S√¢n 3', time: '16:40' };
            const defaultSF2Info = { teamA: 'Nh·∫•t B', teamB: 'Nh√¨ A', court: 'S√¢n 3', time: '17:05' };
            const defaultFinalInfo = { teamA: 'Th·∫Øng SF1', teamB: 'Th·∫Øng SF2', court: 'S√¢n 3', time: '17:30' };

            // Logic t·∫£i cho semifinals/final (gi·ªØ l·∫°i k·∫øt qu·∫£ n·∫øu ƒë√£ c√≥, reset ƒë·ªôi n·∫øu ƒë·ªôi v√≤ng b·∫£ng thay ƒë·ªïi)
            if (loadedState.semifinals && loadedState.semifinals.length === 2) {
                 // N·∫øu ƒë√£ c√≥ ƒë·ªôi th·ª±c t·∫ø ƒë∆∞·ª£c g√°n (v√≠ d·ª•: Team X), gi·ªØ nguy√™n 
                state.semifinals = loadedState.semifinals;
                // N·∫øu l√† tr·∫°ng th√°i r·ªóng default (Nh·∫•t A vs Nh√¨ A), c·∫≠p nh·∫≠t l·∫°i th·ªùi gian v√† s√¢n theo V24
                state.semifinals.forEach((sf, index) => {
                     if (sf.teamA === 'Nh·∫•t A' || sf.teamA === 'Nh·∫•t B') {
                        sf.court = defaultSF1Info.court;
                        sf.time = index === 0 ? defaultSF1Info.time : defaultSF2Info.time;
                    }
                });
            } else {
                 // D√πng default V24/V28
                 state.semifinals = [ DEFAULT_SF1, DEFAULT_SF2 ];
            }
            
            state.final = loadedState.final || state.final;
            if (!state.final.winner) {
                state.final.court = defaultFinalInfo.court;
                state.final.time = defaultFinalInfo.time;
            }
            
            updateStatus('configStatus', 'success', `T·∫£i tr·∫°ng th√°i gi·∫£i ƒë·∫•u th√†nh c√¥ng t·ª´: ${cfg.owner}/${cfg.repo}/${cfg.folder}/${cfg.file}`);
            document.getElementById('lastSaved').textContent = `L·∫ßn t·∫£i: ${new Date().toLocaleTimeString('vi-VN')}`;
        } else {
             // File state.json kh√¥ng t·ªìn t·∫°i (404)
            updateStatus('configStatus', 'warning', 'File tr·∫°ng th√°i (state.json) ch∆∞a t·ªìn t·∫°i. D√πng d·ªØ li·ªáu tr·ªëng kh·ªüi t·∫°o. Vui l√≤ng nh·∫•n L∆∞u ho·∫∑c T·ª± ƒë·ªông l∆∞u ƒë·ªÉ t·∫°o file.');
        }
        
        // Lu√¥n c·∫≠p nh·∫≠t giao di·ªán sau khi t·∫£i xong teams/state (ho·∫∑c d√πng m·∫∑c ƒë·ªãnh)
        tinhVaCapNhatXepHang(); 
        renderMatchesView(); 
        renderFinals();
        renderFinalResults();
        renderOverview();
        startAutoSave();

    } catch (error) {
        updateStatus('configStatus', 'danger', `L·ªói t·∫£i tr·∫°ng th√°i gi·∫£i ƒë·∫•u: ${error.message}. Vui l√≤ng ki·ªÉm tra l·∫°i Token/Repo.`);
        console.error("L·ªói khi t·∫£i tr·∫°ng th√°i gi·∫£i ƒë·∫•u t·ª´ GitHub:", error);
    }
}

/**
 * L∆∞u tr·∫°ng th√°i gi·∫£i ƒë·∫•u (state.json) l√™n GitHub.
 * @param {boolean} force - B·∫Øt bu·ªôc l∆∞u ngay c·∫£ khi stateChanged l√† false.
 */
async function saveToGitHub(force = false) {
    // B·ªè qua n·∫øu kh√¥ng c√≥ thay ƒë·ªïi v√† kh√¥ng √©p bu·ªôc l∆∞u
    if (!stateChanged && !force) return;
    
    // **CHECKPOINT:** T√≠nh l·∫°i b·∫£ng x·∫øp h·∫°ng tr∆∞·ªõc khi l∆∞u (ƒë·∫£m b·∫£o d·ªØ li·ªáu ranking l√† m·ªõi nh·∫•t)
    tinhVaCapNhatXepHang();

    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) {
        console.warn("Kh√¥ng th·ªÉ t·ª± ƒë·ªông l∆∞u: Thi·∫øu c·∫•u h√¨nh GitHub.");
        document.getElementById('autoState').className = 'text-warning';
        document.getElementById('autoState').textContent = 'T·∫°m d·ª´ng (Thi·∫øu Config)';
        return;
    }

    document.getElementById('autoState').className = 'text-info';
    document.getElementById('autoState').textContent = 'ƒêang l∆∞u...';
    if (force) {
         updateStatus('configStatus', 'info', 'ƒêang c·∫≠p nh·∫≠t d·ªØ li·ªáu l√™n GitHub...');
    }


    const apiUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}/contents/${cfg.folder}/${cfg.file}`;
    
    // Ch·ªâ l∆∞u c√°c tr∆∞·ªùng c·∫ßn thi·∫øt, bao g·ªìm c·∫£ b·∫£ng x·∫øp h·∫°ng (tableA, tableB)
    const stateToSave = {
        mixedTeams: state.mixedTeams,
        maleTeams: state.maleTeams,
        matchesA: state.matchesA,
        matchesB: state.matchesB,
        courts: state.courts,
        semifinals: state.semifinals,
        final: state.final,
        // **B·∫¢NG X·∫æP H·∫†NG V√íNG B·∫¢NG ƒê√É T√çNH TO√ÅN**
        tableA: state.tableA,
        tableB: state.tableB 
    };
    const content = b64EncodeUnicode(JSON.stringify(stateToSave));
    
    try {
        // Lu√¥n fetch SHA m·ªõi nh·∫•t tr∆∞·ªõc khi c·ªë g·∫Øng l∆∞u
        const result = await fetchFileSha(cfg, cfg.file); // L·∫•y SHA c·ªßa state.json
        const sha = result.sha; 
        
        const payload = {
            message: `${force ? '[Manual-save]' : '[Auto-save]'} C·∫≠p nh·∫≠t tr·∫°ng th√°i gi·∫£i ƒë·∫•u TKD l√∫c ${new Date().toLocaleString('vi-VN')}`,
            content: content
        };
        
        // Th√™m SHA ƒë·ªÉ c·∫≠p nh·∫≠t, n·∫øu kh√¥ng c√≥ SHA s·∫Ω t·∫°o m·ªõi (v√¨ fetchFileSha ƒë√£ c·∫≠p nh·∫≠t currentSha)
        if (sha) {
             payload.sha = sha;
        }

        const response = await fetch(apiUrl, {
            method: 'PUT',
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Content-Type': 'application/json',
                'Accept': 'application/vnd.github.v3+json'
            },
            body: JSON.stringify(payload)
        });

        if (response.ok) {
            const data = await response.json();
            currentSha = data.content.sha;
            stateChanged = false;
            document.getElementById('lastSaved').textContent = `L·∫ßn l∆∞u: ${new Date().toLocaleTimeString('vi-VN')}`;
            document.getElementById('autoState').className = 'text-success';
            document.getElementById('autoState').textContent = 'ƒê√£ L∆∞u';
            if (force) {
                 updateStatus('configStatus', 'success', `C·∫≠p nh·∫≠t d·ªØ li·ªáu l√™n GitHub th√†nh c√¥ng l√∫c ${new Date().toLocaleTimeString('vi-VN')}.`);
            }
        } else {
            // X·ª≠ l√Ω l·ªói 409 Conflict ho·∫∑c l·ªói kh√°c
             const errorData = await response.json();
            // X·ª≠ l√Ω l·ªói 409 Conflict
            if (response.status === 409) {
                console.warn("L·ªói 409 Conflict: D·ªØ li·ªáu ƒë√£ thay ƒë·ªïi tr√™n GitHub. ƒêang c·ªë g·∫Øng l·∫•y SHA m·ªõi.");
                
                await fetchFileSha(cfg, cfg.file); // L·∫•y l·∫°i SHA m·ªõi
                
                document.getElementById('autoState').className = 'text-warning';
                document.getElementById('autoState').textContent = 'Conflict. S·∫Ω th·ª≠ l∆∞u l·∫°i sau 30s.';
                if (force) {
                     updateStatus('configStatus', 'warning', `L·ªói Conflict (D·ªØ li·ªáu ƒë√£ thay ƒë·ªïi tr√™n GitHub). Vui l√≤ng th·ª≠ l·∫°i sau 30s.`);
                }
            } else {
                throw new Error(`L·ªói HTTP: ${response.status} - ${errorData.message || response.statusText}`);
            }
        }
    } catch (error) {
        console.error("L·ªói khi l∆∞u l√™n GitHub:", error);
        document.getElementById('autoState').className = 'text-danger';
        document.getElementById('autoState').textContent = 'L·ªói L∆∞u';
        if (force) {
             updateStatus('configStatus', 'danger', `L·ªói c·∫≠p nh·∫≠t l√™n GitHub: ${error.message}.`);
        }
    }
}

/**
 * B·∫Øt ƒë·∫ßu c∆° ch·∫ø t·ª± ƒë·ªông l∆∞u sau m·ªói 30 gi√¢y.
 */
function startAutoSave() {
    stopAutoSave(); // ƒê·∫£m b·∫£o kh√¥ng c√≥ interval n√†o ƒëang ch·∫°y
    
    // Ch·ªâ kh·ªüi ƒë·ªông auto-save n·∫øu c√≥ ƒë·ªß config
    if (state.config.owner && state.config.repo && state.config.token) {
        document.getElementById('autoState').className = 'text-info';
        document.getElementById('autoState').textContent = 'Ho·∫°t ƒë·ªông';
        autoSaveInterval = setInterval(() => {
            saveToGitHub(false); // L∆∞u kh√¥ng b·∫Øt bu·ªôc
        }, 30000); // 30 gi√¢y
    } else {
        document.getElementById('autoState').className = 'text-danger';
        document.getElementById('autoState').textContent = 'T·∫Øt (Thi·∫øu Config)';
    }
}

/**
 * D·ª´ng c∆° ch·∫ø t·ª± ƒë·ªông l∆∞u.
 */
function stopAutoSave() {
    if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
        autoSaveInterval = null;
    }
}


/**
 * Ki·ªÉm tra k·∫øt n·ªëi v√† T·∫£i d·ªØ li·ªáu
 */
async function checkConnection() {
    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) {
        updateStatus('configStatus', 'warning', 'Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß Owner, Repo v√† Token.');
        return;
    }

    try {
        updateStatus('configStatus', 'info', 'ƒêang ki·ªÉm tra k·∫øt n·ªëi t·ªõi kho l∆∞u tr·ªØ...');
        
        const repoCheckUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}`;
        const repoResponse = await fetch(repoCheckUrl, {
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });

        if (!repoResponse.ok) {
            const errorData = await repoResponse.json();
            throw new Error(`L·ªói truy c·∫≠p kho l∆∞u tr·ªØ. M√£: ${repoResponse.status}. ${errorData.message || ''} (Ki·ªÉm tra Token/Repo/Owner)`);
        }
        
        updateStatus('configStatus', 'success', '‚úÖ K·∫øt n·ªëi GitHub th√†nh c√¥ng! ƒêang ti·∫øn h√†nh t·∫£i d·ªØ li·ªáu...');
        await loadFromGitHub();

    } catch (error) {
        updateStatus('configStatus', 'danger', `‚ùå Ki·ªÉm tra k·∫øt n·ªëi th·∫•t b·∫°i: ${error.message}.`);
        console.error("L·ªói ki·ªÉm tra k·∫øt n·ªëi:", error);
    }
}

// --- Local Storage Configuration Functions ---

/**
 * L∆∞u c·∫•u h√¨nh GitHub v√†o Local Storage.
 */
function saveConfig() {
    const owner = document.getElementById('cfgOwner').value.trim();
    const repo = document.getElementById('cfgRepo').value.trim();
    const token = document.getElementById('cfgToken').value.trim();
    const folder = document.getElementById('cfgFolder').value.trim();
    const file = document.getElementById('cfgFile').value.trim();
    
    state.config.owner = owner;
    state.config.repo = repo;
    state.config.token = token;
    state.config.folder = folder;
    state.config.file = file;

    // L∆∞u config v√†o localStorage (Kh√¥ng l∆∞u Token)
    const configToSave = { ...state.config, token: '' };
    localStorage.setItem('tkd_app_config', JSON.stringify(configToSave));
    
    // L∆∞u token ri√™ng (ƒë·ªÉ tr√°nh hi·ªÉn th·ªã trong UI sau khi load)
    if (token) {
        localStorage.setItem('tkd_pat_token', token);
    }
    
    // C·∫≠p nh·∫≠t l·∫°i UI sau khi save (n·∫øu ƒëang ·ªü tab config)
    if (document.getElementById('config').classList.contains('active')) {
         updateStatus('configStatus', 'success', 'ƒê√£ l∆∞u c·∫•u h√¨nh GitHub v√†o Local.');
    }
    
    // Kh·ªüi ƒë·ªông l·∫°i auto-save
    startAutoSave();
}

/**
 * T·∫£i c·∫•u h√¨nh GitHub t·ª´ Local Storage.
 */
function loadConfig() {
    const storedConfig = localStorage.getItem('tkd_app_config');
    const storedToken = localStorage.getItem('tkd_pat_token');

    if (storedConfig) {
        const loadedConfig = JSON.parse(storedConfig);
        // G√°n l·∫°i c√°c gi√° tr·ªã ƒë√£ l∆∞u
        state.config = { ...state.config, ...loadedConfig };
    }
    
    if (storedToken) {
        state.config.token = storedToken;
    }
    
    // C·∫≠p nh·∫≠t UI
    document.getElementById('cfgOwner').value = state.config.owner;
    document.getElementById('cfgRepo').value = state.config.repo;
    document.getElementById('cfgFolder').value = state.config.folder;
    document.getElementById('cfgFile').value = state.config.file;
    document.getElementById('cfgToken').value = state.config.token;
    
    const select = document.getElementById('preferredCourtType');
    if (select) {
        select.value = state.config.preferredCourtType || 'mixed';
    }
}

// --- Match and Ranking Core Logic ---

/**
 * C·∫≠p nh·∫≠t ƒëi·ªÉm s·ªë c·ªßa m·ªôt tr·∫≠n ƒë·∫•u.
 */
function updateScore(group, index) {
    const match = group === 'A' ? state.matchesA[index] : state.matchesB[index];
    const scoreA = document.getElementById(`score-${group}-${index}-A`).value;
    const scoreB = document.getElementById(`score-${group}-${index}-B`).value;
    
    // Ch·ªâ l·∫•y gi√° tr·ªã h·ª£p l·ªá (s·ªë nguy√™n >= 0)
    const newScoreA = scoreA === '' ? null : parseInt(scoreA, 10);
    const newScoreB = scoreB === '' ? null : parseInt(scoreB, 10);

    // X√°c ƒë·ªãnh th·∫Øng thua
    if (newScoreA !== null && newScoreB !== null) {
        if (newScoreA >= 11 && newScoreA > newScoreB + 1) {
            match.winner = match.teamA;
            match.loser = match.teamB;
        } else if (newScoreB >= 11 && newScoreB > newScoreA + 1) {
            match.winner = match.teamB;
            match.loser = match.teamA;
        } else {
             // Ch∆∞a k·∫øt th√∫c ho·∫∑c kh√¥ng h·ª£p l·ªá theo lu·∫≠t (ch∆∞a ƒë·∫øn 11, ho·∫∑c c√°ch bi·ªát 1 ƒëi·ªÉm)
            match.winner = null;
            match.loser = null;
        }
        
        match.scoreA = newScoreA;
        match.scoreB = newScoreB;
    } else {
        match.scoreA = newScoreA;
        match.scoreB = newScoreB;
        match.winner = null;
        match.loser = null;
    }
    
    stateChanged = true;
    
    // T√°i t√≠nh v√† c·∫≠p nh·∫≠t
    tinhVaCapNhatXepHang();
    renderMatchesView(); // ƒê·ªÉ c·∫≠p nh·∫≠t m√†u s·∫Øc ƒë·ªôi th·∫Øng/thua ngay l·∫≠p t·ª©c
    renderFinals(); // C·∫≠p nh·∫≠t ƒë·ªôi v√†o b√°n k·∫øt n·∫øu ƒë·ªß
    renderOverview(); // C·∫≠p nh·∫≠t overview
}

/**
 * T√≠nh to√°n v√† c·∫≠p nh·∫≠t b·∫£ng x·∫øp h·∫°ng V√≤ng B·∫£ng.
 */
function tinhVaCapNhatXepHang() {
    state.tableA = tinhXepHang(state.mixedTeams, state.matchesA, 'A');
    state.tableB = tinhXepHang(state.maleTeams, state.matchesB, 'B');
    
    renderRankingTables();
    
    // T·ª± ƒë·ªông l√™n l·ªãch b√°n k·∫øt sau khi c√≥ x·∫øp h·∫°ng
    capNhatDoiVaoVongChungKet(state.tableA, state.tableB);
}

/**
 * H√†m core t√≠nh to√°n x·∫øp h·∫°ng cho m·ªôt b·∫£ng ƒë·∫•u.
 * @param {Array} teams - Danh s√°ch ƒë·ªôi
 * @param {Array} matches - Danh s√°ch tr·∫≠n ƒë·∫•u
 * @param {string} group - T√™n b·∫£ng (A/B)
 */
function tinhXepHang(teams, matches, group) {
    // 1. Kh·ªüi t·∫°o th·ªëng k√™
    const stats = {};
    teams.forEach(team => {
        stats[team.name] = { 
            team: team.name, 
            P: 0, // Played
            W: 0, // Win
            L: 0, // Loss
            GF: 0, // Goals For (ƒêi·ªÉm th·∫Øng)
            GA: 0, // Goals Against (ƒêi·ªÉm thua)
            GD: 0, // Goal Difference (Hi·ªáu s·ªë)
            Pts: 0 // Points (ƒêi·ªÉm)
        };
    });

    // 2. C·∫≠p nh·∫≠t th·ªëng k√™ t·ª´ k·∫øt qu·∫£ tr·∫≠n ƒë·∫•u
    matches.forEach(match => {
        if (match.winner) {
            const statA = stats[match.teamA];
            const statB = stats[match.teamB];

            // C·∫≠p nh·∫≠t s·ªë tr·∫≠n
            statA.P += 1;
            statB.P += 1;
            
            // C·∫≠p nh·∫≠t ƒëi·ªÉm th·∫Øng/thua
            const scoreA = match.scoreA || 0;
            const scoreB = match.scoreB || 0;
            
            statA.GF += scoreA;
            statA.GA += scoreB;
            statB.GF += scoreB;
            statB.GA += scoreA;
            
            // C·∫≠p nh·∫≠t th·∫Øng/thua/ƒëi·ªÉm
            if (match.winner === match.teamA) {
                statA.W += 1;
                statA.Pts += 3; // Th·∫Øng ƒë∆∞·ª£c 3 ƒëi·ªÉm
                statB.L += 1;
            } else if (match.winner === match.teamB) {
                statB.W += 1;
                statB.Pts += 3;
                statA.L += 1;
            } 
            // Kh√¥ng c√≥ h√≤a trong pickleball, n·∫øu kh√¥ng c√≥ winner th√¨ tr·∫≠n ƒë·∫•u ch∆∞a ho√†n th√†nh ho·∫∑c ƒëi·ªÉm kh√¥ng h·ª£p l·ªá
        } else if (match.scoreA !== null && match.scoreB !== null) {
            // Tr·∫≠n ƒë·∫•u ch∆∞a ho√†n th√†nh (ch∆∞a ƒë·ªß 11 ƒëi·ªÉm v√† c√°ch bi·ªát 2), v·∫´n t√≠nh P, GF, GA
            const statA = stats[match.teamA];
            const statB = stats[match.teamB];
            statA.P += 1;
            statB.P += 1;

            const scoreA = match.scoreA || 0;
            const scoreB = match.scoreB || 0;
            
            statA.GF += scoreA;
            statA.GA += scoreB;
            statB.GF += scoreB;
            statB.GA += scoreA;
        }
    });

    // 3. T√≠nh hi·ªáu s·ªë
    Object.values(stats).forEach(stat => {
        stat.GD = stat.GF - stat.GA;
    });

    // 4. S·∫Øp x·∫øp (Tie-breaker logic)
    const ranking = Object.values(stats).filter(stat => stat.P > 0);
    
    ranking.sort((a, b) => {
        // 1. ƒêi·ªÉm s·ªë (Pts)
        if (b.Pts !== a.Pts) return b.Pts - a.Pts;

        // 2. ƒê·ªëi ƒë·∫ßu (Head-to-head) - Ch·ªâ √°p d·ª•ng n·∫øu ch·ªâ c√≥ 2 ƒë·ªôi h√≤a ƒëi·ªÉm
        const h2h = checkHeadToHead(a.team, b.team, matches);
        if (h2h !== 0) return h2h;

        // 3. Hi·ªáu s·ªë b√†n th·∫Øng (GD)
        if (b.GD !== a.GD) return b.GD - a.GD;

        // 4. T·ªïng ƒëi·ªÉm th·∫Øng (GF)
        return b.GF - a.GF;
    });
    
    // G√°n l·∫°i Rank
    ranking.forEach((stat, index) => {
        stat.Rank = index + 1;
    });

    // Tr·∫£ v·ªÅ c·∫£ ƒë·ªôi c√≥ ch∆°i v√† ƒë·ªôi ch∆∞a ch∆°i (cho UI)
    const allTeams = Object.values(stats);
    allTeams.sort((a, b) => {
        // ∆Øu ti√™n ƒë·ªôi ƒë√£ ch∆°i l√™n tr√™n
        if (a.P > 0 && b.P === 0) return -1;
        if (a.P === 0 && b.P > 0) return 1;
        
        // Sau ƒë√≥ √°p d·ª•ng x·∫øp h·∫°ng cho ƒë·ªôi ƒë√£ ch∆°i
        const rankA = ranking.find(r => r.team === a.team);
        const rankB = ranking.find(r => r.team === b.team);
        
        if (rankA && rankB) {
            return rankA.Rank - rankB.Rank;
        }
        
        return a.team.localeCompare(b.team); // S·∫Øp x·∫øp theo t√™n n·∫øu ch∆∞a ch∆°i
    });

    return allTeams;
}

/**
 * Ki·ªÉm tra k·∫øt qu·∫£ ƒë·ªëi ƒë·∫ßu gi·ªØa hai ƒë·ªôi.
 * @param {string} teamA - T√™n ƒë·ªôi A
 * @param {string} teamB - T√™n ƒë·ªôi B
 * @param {Array} matches - Danh s√°ch tr·∫≠n ƒë·∫•u
 * @returns {number} - 1 n·∫øu B th·∫Øng A (B x·∫øp tr√™n), -1 n·∫øu A th·∫Øng B (A x·∫øp tr√™n), 0 n·∫øu h√≤a ho·∫∑c ch∆∞a ƒë·∫•u
 */
function checkHeadToHead(teamA, teamB, matches) {
    let winsA = 0;
    let winsB = 0;

    matches.forEach(match => {
        if (match.winner) {
            if (match.teamA === teamA && match.teamB === teamB) {
                if (match.winner === teamA) winsA++;
                else winsB++;
            } else if (match.teamA === teamB && match.teamB === teamA) {
                if (match.winner === teamB) winsB++;
                else winsA++;
            }
        }
    });

    if (winsA > winsB) return -1; // A th·∫Øng B
    if (winsB > winsA) return 1;  // B th·∫Øng A
    return 0; // H√≤a ho·∫∑c ch∆∞a ƒë·∫•u
}

// ===============================================
// START V28 FIX: Logic T·ª± ƒë·ªông ƒëi·ªÅn ƒë·ªôi B√°n k·∫øt 100%
// ===============================================

/**
 * T√≠nh s·ªë tr·∫≠n ƒë·∫•u c·∫ßn thi·∫øt cho v√≤ng tr√≤n 1 l∆∞·ª£t (N * (N-1) / 2)
 * @param {number} N - S·ªë ƒë·ªôi
 * @returns {number}
 */
function requiredMatches(N) {
    if (N < 2) return 0;
    return N * (N - 1) / 2;
}

/**
 * C·∫≠p nh·∫≠t ƒë·ªôi Nh·∫•t/Nh√¨ V√≤ng B·∫£ng v√†o V√≤ng B√°n k·∫øt.
 */
function capNhatDoiVaoVongChungKet(tableA, tableB) {
    // Ch·ªâ c·∫≠p nh·∫≠t n·∫øu V√≤ng Chung k·∫øt ch∆∞a c√≥ k·∫øt qu·∫£
    const finalsCompleted = state.semifinals.some(sf => sf.winner !== null) || state.final.winner !== null;
    if (finalsCompleted) return;
    
    // V28 Logic: KI·ªÇM TRA T·∫§T C·∫¢ TR·∫¨N V√íNG B·∫¢NG ƒê√É HO√ÄN TH√ÄNH
    const requiredA = requiredMatches(state.mixedTeams.length);
    const completedA = state.matchesA.filter(m => m.winner).length;
    const isGroupACompleted = completedA >= requiredA;

    const requiredB = requiredMatches(state.maleTeams.length);
    const completedB = state.matchesB.filter(m => m.winner).length;
    const isGroupBCompleted = completedB >= requiredB;
    
    const team1A = tableA.find(t => t.Rank === 1);
    const team2A = tableA.find(t => t.Rank === 2);
    const team1B = tableB.find(t => t.Rank === 1);
    const team2B = tableB.find(t => t.Rank === 2);
    
    let changed = false;

    // C·∫≠p nh·∫≠t B√°n k·∫øt 1 (SF1: Nh·∫•t A vs Nh√¨ B)
    if (state.semifinals[0].scoreA === null && state.semifinals[0].scoreB === null) {
        // V28 Logic: Ch·ªâ ƒëi·ªÅn t√™n ƒë·ªôi n·∫øu b·∫£ng ƒë·∫•u t∆∞∆°ng ·ª©ng ƒë√£ ho√†n th√†nh
        const newTeamA = (isGroupACompleted && team1A) ? team1A.team : 'Nh·∫•t A'; 
        const newTeamB = (isGroupBCompleted && team2B) ? team2B.team : 'Nh√¨ B';
        
        if (state.semifinals[0].teamA !== newTeamA || state.semifinals[0].teamB !== newTeamB) {
            state.semifinals[0].teamA = newTeamA;
            state.semifinals[0].teamB = newTeamB;
            changed = true;
        }
    }

    // C·∫≠p nh·∫≠t B√°n k·∫øt 2 (SF2: Nh·∫•t B vs Nh√¨ A)
    if (state.semifinals[1].scoreA === null && state.semifinals[1].scoreB === null) {
        // V28 Logic: Ch·ªâ ƒëi·ªÅn t√™n ƒë·ªôi n·∫øu b·∫£ng ƒë·∫•u t∆∞∆°ng ·ª©ng ƒë√£ ho√†n th√†nh
        const newTeamA = (isGroupBCompleted && team1B) ? team1B.team : 'Nh·∫•t B';
        const newTeamB = (isGroupACompleted && team2A) ? team2A.team : 'Nh√¨ A';
        
        if (state.semifinals[1].teamA !== newTeamA || state.semifinals[1].teamB !== newTeamB) {
            state.semifinals[1].teamA = newTeamA;
            state.semifinals[1].teamB = newTeamB;
            changed = true;
        }
    }

    // C·∫≠p nh·∫≠t Chung k·∫øt (F: Th·∫Øng SF1 vs Th·∫Øng SF2)
    if (state.final.scoreA === null && state.final.scoreB === null) {
        const winnerSF1 = state.semifinals[0].winner || 'Th·∫Øng SF1';
        const winnerSF2 = state.semifinals[1].winner || 'Th·∫Øng SF2';
        
        if (state.final.teamA !== winnerSF1 || state.final.teamB !== winnerSF2) {
            state.final.teamA = winnerSF1;
            state.final.teamB = winnerSF2;
            changed = true;
        }
    }
    
    if (changed) {
        stateChanged = true;
        // renderFinals() s·∫Ω ƒë∆∞·ª£c g·ªçi sau h√†m g·ªçi capNhatDoiVaoVongChungKet
    }
}
// ===============================================
// END V28 FIX: Logic T·ª± ƒë·ªông ƒëi·ªÅn ƒë·ªôi B√°n k·∫øt 100%
// ===============================================


// --- Rendering Functions ---

/**
 * Hi·ªÉn th·ªã b·∫£ng x·∫øp h·∫°ng V√≤ng B·∫£ng.
 */
function renderRankingTables() {
    const container = document.getElementById('rankingTables');
    let html = '';

    const renderTable = (table, title) => {
        if (table.length === 0) return '';
        
        let tableHtml = `<div class="ranking-table"><h5>${title}</h5><div class='table-responsive'><table class='table table-bordered table-sm'>
            <thead class="table-primary">
                <tr><th>#</th><th>ƒê·ªôi</th><th>P</th><th>W</th><th>L</th><th>HS</th><th>ƒêi·ªÉm</th></tr>
            </thead>
            <tbody>`;
        
        table.forEach((stat, index) => {
            const rank = stat.Rank || '-';
            const rowClass = (stat.Rank === 1 || stat.Rank === 2) && stat.P > 0 ? 'table-success' : '';
            tableHtml += `<tr class="${rowClass}">
                <td>${rank}</td>
                <td class="text-truncate" style="max-width:150px;">${stat.team}</td>
                <td>${stat.P}</td>
                <td>${stat.W}</td>
                <td>${stat.L}</td>
                <td>${stat.GD}</td>
                <td>${stat.Pts}</td>
            </tr>`;
        });
        
        tableHtml += `</tbody></table></div></div>`;
        return tableHtml;
    };

    html += renderTable(state.tableA, 'B·∫£ng A (Nam - N·ªØ)');
    html += renderTable(state.tableB, 'B·∫£ng B (Nam)');

    container.innerHTML = html || `<p class="text-muted">Ch∆∞a c√≥ k·∫øt qu·∫£ ho·∫∑c l·ªãch thi ƒë·∫•u.</p>`;
}

/**
 * Hi·ªÉn th·ªã k·∫øt qu·∫£ V√≤ng Chung cu·ªôc.
 */
function renderFinalResults() {
    const tableA = state.tableA;
    const tableB = state.tableB;
    const final = state.final;
    const sf1 = state.semifinals[0];
    const sf2 = state.semifinals[1];

    let champion = 'ƒêang ch·ªù k·∫øt qu·∫£...';
    let runnerUp = 'ƒêang ch·ªù k·∫øt qu·∫£...';
    let thirdPlaces = ['ƒêang ch·ªù k·∫øt qu·∫£...'];

    if (final.winner) {
        champion = `<span class="badge bg-success">${final.winner}</span>`;
        runnerUp = `<span class="badge bg-warning">${final.runnerUp}</span>`;
        
        // H·∫°ng Ba: ƒê·ªôi thua ·ªü B√°n k·∫øt 1 v√† B√°n k·∫øt 2
        let loserSF1 = sf1.loser || 'ƒê·ªôi thua SF1';
        let loserSF2 = sf2.loser || 'ƒê·ªôi thua SF2';
        
        // Ch·ªâ hi·ªán t√™n ƒë·ªôi n·∫øu tr·∫≠n b√°n k·∫øt ƒë√£ c√≥ k·∫øt qu·∫£
        if (sf1.winner && sf2.winner) {
             thirdPlaces = [`<span class="badge bg-info">${loserSF1}</span>`, `<span class="badge bg-info">${loserSF2}</span>`];
        } else {
             thirdPlaces = ['ƒêang ch·ªù k·∫øt qu·∫£...'];
        }
    } else if (sf1.winner && sf2.winner) {
        // Chung k·∫øt ch∆∞a xong
        champion = 'ƒêang ch·ªù k·∫øt qu·∫£ Chung k·∫øt...';
        runnerUp = 'ƒêang ch·ªù k·∫øt qu·∫£ Chung k·∫øt...';
        thirdPlaces = [`<span class="badge bg-info">${sf1.loser}</span>`, `<span class="badge bg-info">${sf2.loser}</span>`];
    }

    document.getElementById('champion').innerHTML = `V√¥ ƒë·ªãch: ${champion}`;
    document.getElementById('runnerUp').innerHTML = `√Å qu√¢n: ${runnerUp}`;
    document.getElementById('thirdPlace').innerHTML = `H·∫°ng Ba ƒê·ªìng H·∫°ng: ${thirdPlaces.join(' v√† ')}`;
}

/**
 * Hi·ªÉn th·ªã V√≤ng Chung K·∫øt (B√°n k·∫øt & Chung k·∫øt).
 */
function renderFinals() {
    const sfContainer = document.getElementById('semifinalMatches');
    const fContainer = document.getElementById('finalMatch');
    
    // --- Render B√°n k·∫øt ---
    let sfHtml = `<div class='table-responsive'><table class='table table-striped table-bordered table-sm'>
        <thead class="table-dark"><tr><th>Tr·∫≠n</th><th>Gi·ªù/S√¢n</th><th>ƒê·ªôi A</th><th>ƒê·ªôi B</th><th colspan="2">ƒêi·ªÉm</th></tr></thead>
        <tbody>`;
        
    state.semifinals.forEach((match, index) => {
        const teamA_Class = match.winner === match.teamA ? 'winner' : (match.loser === match.teamA ? 'loser' : '');
        const teamB_Class = match.winner === match.teamB ? 'winner' : (match.loser === match.teamB ? 'loser' : '');
        const matchRowClass = match.winner ? 'table-success' : (match.teamA.includes('Nh·∫•t') ? 'table-light' : ''); // Nh·∫•t A/B ch∆∞a ƒë√°
        
        sfHtml += `
            <tr class="${matchRowClass}">
                <td>${match.id}</td>
                <td>${match.time || '-'} / ${match.court || '-'}</td>
                <td class="text-truncate ${teamA_Class}">${match.teamA}</td>
                <td class="text-truncate ${teamB_Class}">${match.teamB}</td>
                <td class="match-score-cell">
                    <input type="number" id="sf-score-${index}-A" 
                        value="${match.scoreA !== null ? match.scoreA : ''}" 
                        min="0" onchange="updateFinalScore('SF', ${index})">
                </td>
                <td class="match-score-cell">
                    <input type="number" id="sf-score-${index}-B" 
                        value="${match.scoreB !== null ? match.scoreB : ''}" 
                        min="0" onchange="updateFinalScore('SF', ${index})">
                </td>
            </tr>
        `;
    });
    
    sfHtml += `</tbody></table></div>`;
    sfContainer.innerHTML = sfHtml;

    // --- Render Chung k·∫øt ---
    const match = state.final;
    const teamA_Class = match.winner === match.teamA ? 'winner' : (match.runnerUp === match.teamA ? 'loser' : '');
    const teamB_Class = match.winner === match.teamB ? 'winner' : (match.runnerUp === match.teamB ? 'loser' : '');
    const matchRowClass = match.winner ? 'table-danger' : (match.teamA.includes('Th·∫Øng') ? 'table-light' : '');
    
    let fHtml = `<div class='table-responsive'><table class='table table-striped table-bordered table-sm'>
        <thead class="table-dark"><tr><th>Tr·∫≠n</th><th>Gi·ªù/S√¢n</th><th>ƒê·ªôi A</th><th>ƒê·ªôi B</th><th colspan="2">ƒêi·ªÉm</th></tr></thead>
        <tbody>
            <tr class="${matchRowClass}">
                <td>${match.id}</td>
                <td>${match.time || '-'} / ${match.court || '-'}</td>
                <td class="text-truncate ${teamA_Class}">${match.teamA}</td>
                <td class="text-truncate ${teamB_Class}">${match.teamB}</td>
                <td class="match-score-cell">
                    <input type="number" id="sf-score-F-A" 
                        value="${match.scoreA !== null ? match.scoreA : ''}" 
                        min="0" onchange="updateFinalScore('F', 0)">
                </td>
                <td class="match-score-cell">
                    <input type="number" id="sf-score-F-B" 
                        value="${match.scoreB !== null ? match.scoreB : ''}" 
                        min="0" onchange="updateFinalScore('F', 0)">
                </td>
            </tr>
        </tbody>
        </table></div>`;
        
    fContainer.innerHTML = fHtml;
    
    // C·∫≠p nh·∫≠t k·∫øt qu·∫£ chung cu·ªôc ngay
    renderFinalResults();
}

/**
 * C·∫≠p nh·∫≠t ƒëi·ªÉm V√≤ng Chung K·∫øt (SF1, SF2, F).
 */
function updateFinalScore(matchType, index) {
    let match;
    let scoreA_id;
    let scoreB_id;
    
    if (matchType === 'SF') {
        match = state.semifinals[index];
        scoreA_id = `sf-score-${index}-A`;
        scoreB_id = `sf-score-${index}-B`;
    } else { // 'F'
        match = state.final;
        scoreA_id = `sf-score-F-A`;
        scoreB_id = `sf-score-F-B`;
    }
    
    if (match.teamA.includes('Nh·∫•t') || match.teamA.includes('Th·∫Øng')) {
        alert("Ch∆∞a ƒë·ªß ƒë·ªôi v√†o V√≤ng Chung k·∫øt. Vui l√≤ng ho√†n th√†nh V√≤ng B·∫£ng/B√°n k·∫øt tr∆∞·ªõc.");
        document.getElementById(scoreA_id).value = match.scoreA !== null ? match.scoreA : '';
        document.getElementById(scoreB_id).value = match.scoreB !== null ? match.scoreB : '';
        return;
    }

    const scoreA = document.getElementById(scoreA_id).value;
    const scoreB = document.getElementById(scoreB_id).value;
    
    const newScoreA = scoreA === '' ? null : parseInt(scoreA, 10);
    const newScoreB = scoreB === '' ? null : parseInt(scoreB, 10);
    
    // Logic th·∫Øng thua (gi·ªëng updateScore)
    let winner = null;
    let loser = null;

    if (newScoreA !== null && newScoreB !== null) {
        if (newScoreA >= 11 && newScoreA > newScoreB + 1) {
            winner = match.teamA;
            loser = match.teamB;
        } else if (newScoreB >= 11 && newScoreB > newScoreA + 1) {
            winner = match.teamB;
            loser = match.teamA;
        }
    }
    
    match.scoreA = newScoreA;
    match.scoreB = newScoreB;
    match.winner = winner;
    
    if (matchType === 'SF') {
        match.loser = loser;
    } else { // 'F'
        match.runnerUp = loser;
    }

    stateChanged = true;
    
    capNhatDoiVaoVongChungKet(state.tableA, state.tableB);
    renderFinals();
    renderOverview();
}


/**
 * Hi·ªÉn th·ªã l·ªãch thi ƒë·∫•u theo ch·∫ø ƒë·ªô xem (B·∫£ng ƒë·∫•u ho·∫∑c S√¢n).
 */
function renderMatchesView() {
    const viewMode = document.getElementById('viewMode').value;
    const container = document.getElementById('matchesViewContent');
    
    // 1. L·∫•y d·ªØ li·ªáu theo ch·∫ø ƒë·ªô xem
    let dataA = state.matchesA;
    let dataB = state.matchesB;
    
    if (viewMode === 'court') {
        // Gom nh√≥m theo s√¢n v√† s·∫Øp x·∫øp theo th·ªùi gian
        const allMatches = [...state.matchesA, ...state.matchesB];
        const groupedByCourt = allMatches.reduce((acc, match) => {
            if (!acc[match.court]) {
                acc[match.court] = [];
            }
            acc[match.court].push(match);
            return acc;
        }, {});
        
        // S·∫Øp x·∫øp c√°c tr·∫≠n ƒë·∫•u trong m·ªói s√¢n theo th·ªùi gian
        Object.values(groupedByCourt).forEach(matches => {
            matches.sort((a, b) => a.time.localeCompare(b.time));
        });
        
        // S·∫Øp x·∫øp c√°c s√¢n theo t√™n
        const sortedCourts = Object.keys(groupedByCourt).sort((a, b) => a.localeCompare(b));
        
        // T·∫°o HTML theo s√¢n
        let courtHtml = '';
        sortedCourts.forEach(courtName => {
            courtHtml += `<h6 class="mt-4">S√¢n: ${courtName}</h6>`;
            courtHtml += renderMatchesTable(groupedByCourt[courtName], courtName);
        });
        
        container.innerHTML = courtHtml || `<p class="text-muted">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u.</p>`;

    } else { // viewMode === 'table'
        
        let tableHtml = `<h6 class="mt-4">B·∫£ng A (Nam - N·ªØ)</h6>`;
        tableHtml += renderMatchesTable(dataA, 'A');
        
        tableHtml += `<h6 class="mt-4">B·∫£ng B (Nam)</h6>`;
        tableHtml += renderMatchesTable(dataB, 'B');
        
        container.innerHTML = tableHtml;
    }
}

/**
 * T·∫°o b·∫£ng HTML cho m·ªôt nh√≥m tr·∫≠n ƒë·∫•u.
 */
function renderMatchesTable(matches, groupOrCourt) {
    if (matches.length === 0) return `<div class="alert alert-light">Ch∆∞a c√≥ tr·∫≠n ƒë·∫•u n√†o.</div>`;
    
    let tableHtml = `<div class='table-responsive'><table class='table table-striped table-bordered table-sm'>
        <thead class="table-primary">
            <tr>
                <th>Gi·ªù</th>
                <th>S√¢n</th>
                <th>ƒê·ªôi A</th>
                <th>ƒê·ªôi B</th>
                <th colspan="2">ƒêi·ªÉm</th>
            </tr>
        </thead>
        <tbody>`;
        
    matches.forEach(match => {
        // T√¨m index trong state ƒë·ªÉ updateScore
        let group, index;
        if (state.matchesA.includes(match)) {
             group = 'A';
             index = state.matchesA.indexOf(match);
        } else if (state.matchesB.includes(match)) {
             group = 'B';
             index = state.matchesB.indexOf(match);
        } else {
            // Kh√¥ng t√¨m th·∫•y trong state, ch·ªâ hi·ªÉn th·ªã (ch·ªâ x·∫£y ra khi viewMode=court)
            group = match.bang;
            index = -1; 
        }

        const teamA_Class = match.winner === match.teamA ? 'winner' : (match.loser === match.teamA ? 'loser' : '');
        const teamB_Class = match.winner === match.teamB ? 'winner' : (match.loser === match.teamB ? 'loser' : '');
        const matchRowClass = match.winner ? 'table-success' : '';
        
        tableHtml += `
            <tr class="${matchRowClass}">
                <td>${match.time || '-'}</td>
                <td>${match.court || '-'}</td>
                <td class="text-truncate ${teamA_Class}">${match.teamA}</td>
                <td class="text-truncate ${teamB_Class}">${match.teamB}</td>
                <td class="match-score-cell">
                    ${index !== -1 ? `
                    <input type="number" id="score-${group}-${index}-A" 
                        value="${match.scoreA !== null ? match.scoreA : ''}" 
                        min="0" onchange="updateScore('${group}', ${index})">` : (match.scoreA !== null ? match.scoreA : '')}
                </td>
                <td class="match-score-cell">
                    ${index !== -1 ? `
                    <input type="number" id="score-${group}-${index}-B" 
                        value="${match.scoreB !== null ? match.scoreB : ''}" 
                        min="0" onchange="updateScore('${group}', ${index})">` : (match.scoreB !== null ? match.scoreB : '')}
                </td>
            </tr>
        `;
    });
    
    tableHtml += `</tbody></table></div>`;
    return tableHtml;
}


/**
 * Hi·ªÉn th·ªã t·ªïng quan c√°c ƒë·ªôi v√† tr·∫≠n ƒë·∫•u c√≤n l·∫°i.
 */
function renderOverview() {
    const container = document.getElementById('overviewContent');
    const totalTeams = state.mixedTeams.length + state.maleTeams.length;
    const allMatches = [...state.matchesA, ...state.matchesB];
    const matchesPlayed = allMatches.filter(m => m.winner).length;
    const totalMatches = allMatches.length;
    const matchesRemaining = totalMatches - matchesPlayed;
    
    const finalMatches = [...state.semifinals, state.final];
    const finalMatchesPlayed = finalMatches.filter(m => m.winner).length;
    const finalMatchesRemaining = finalMatches.length - finalMatchesPlayed;
    
    let html = `
        <div class="row g-3">
            <div class="col-md-4">
                <div class="card shadow-sm">
                    <div class="card-body">
                        <h5 class="card-title text-primary">ƒê·ªôi Tham Gia</h5>
                        <p class="card-text fs-4">${totalTeams}</p>
                        <ul class="list-unstyled small">
                            <li>B·∫£ng A (Nam - N·ªØ): ${state.mixedTeams.length} ƒë·ªôi</li>
                            <li>B·∫£ng B (Nam): ${state.maleTeams.length} ƒë·ªôi</li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="card shadow-sm">
                    <div class="card-body">
                        <h5 class="card-title text-success">V√≤ng B·∫£ng</h5>
                        <p class="card-text fs-4">${matchesPlayed}/${totalMatches} tr·∫≠n</p>
                        <ul class="list-unstyled small">
                            <li>**ƒê√£ ho√†n th√†nh:** ${matchesPlayed} tr·∫≠n</li>
                            <li>**C√≤n l·∫°i:** ${matchesRemaining} tr·∫≠n</li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="card shadow-sm">
                    <div class="card-body">
                        <h5 class="card-title text-danger">V√≤ng Chung K·∫øt</h5>
                        <p class="card-text fs-4">${finalMatchesPlayed}/3 tr·∫≠n</p>
                        <ul class="list-unstyled small">
                            <li>**ƒê√£ ho√†n th√†nh:** ${finalMatchesPlayed} tr·∫≠n</li>
                            <li>**C√≤n l·∫°i:** ${finalMatchesRemaining} tr·∫≠n (SF1, SF2, F)</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        
        <h5 class="mt-4">Tr·∫≠n ƒê·∫•u S·∫Øp T·ªõi (C√≤n L·∫°i ${matchesRemaining} tr·∫≠n V√≤ng B·∫£ng)</h5>
        `;
        
        const remainingMatches = allMatches
            .filter(m => !m.winner)
            .sort((a, b) => {
                // S·∫Øp x·∫øp theo gi·ªù, sau ƒë√≥ theo s√¢n
                if (a.time && b.time && a.time.localeCompare(b.time) !== 0) {
                    return a.time.localeCompare(b.time);
                }
                return a.court.localeCompare(b.court);
            });
            
        if (remainingMatches.length > 0) {
            html += `<div class='table-responsive'><table class='table table-striped table-sm mt-3'>
                <thead><tr><th>Gi·ªù</th><th>S√¢n</th><th>B·∫£ng</th><th>ƒê·ªôi A</th><th>ƒê·ªôi B</th></tr></thead>
                <tbody>`;
            
            remainingMatches.slice(0, 10).forEach(match => { // Ch·ªâ hi·ªÉn th·ªã 10 tr·∫≠n ƒë·∫ßu
                html += `<tr>
                    <td>${match.time}</td>
                    <td>${match.court}</td>
                    <td>${match.bang}</td>
                    <td>${match.teamA}</td>
                    <td>${match.teamB}</td>
                </tr>`;
            });
            html += `</tbody></table></div>`;
            if (remainingMatches.length > 10) {
                html += `<p class="small text-muted">V√† ${remainingMatches.length - 10} tr·∫≠n ƒë·∫•u kh√°c...</p>`;
            }
        } else {
            html += `<div class="alert alert-info mt-3">‚úÖ V√≤ng B·∫£ng ƒë√£ ho√†n th√†nh! Vui l√≤ng ki·ªÉm tra tab V√≤ng Chung K·∫øt.</div>`;
        }
    
    container.innerHTML = html;
}

// --- Configuration Tab Functions (ƒë√£ c√≥ ·ªü tr√™n) ---

function updatePreferredCourtType() {
    const select = document.getElementById('preferredCourtType');
    if (select) {
        state.config.preferredCourtType = select.value;
        saveConfig();
        updateStatus('configStatus', 'success', `ƒê√£ c·∫≠p nh·∫≠t ∆∞u ti√™n s√¢n th√†nh: ${select.options[select.selectedIndex].text}.`);
    }
}

function exportDataToJson() {
    tinhVaCapNhatXepHang();
    const stateToSave = {
        mixedTeams: state.mixedTeams,
        maleTeams: state.maleTeams,
        matchesA: state.matchesA,
        matchesB: state.matchesB,
        courts: state.courts,
        semifinals: state.semifinals,
        final: state.final,
        tableA: state.tableA,
        tableB: state.tableB
    };
    const jsonString = JSON.stringify(stateToSave, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `data_tkd_export_${new Date().toISOString().slice(0, 10)}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    showModal('Export D·ªØ li·ªáu', 'ƒê√£ xu·∫•t to√†n b·ªô d·ªØ li·ªáu gi·∫£i ƒë·∫•u hi·ªán t·∫°i ra file JSON.');
}

function renderConfig() {
    renderCourtList();
    document.getElementById('courtConfigStatus').innerHTML = '';
    document.getElementById('clearScoreStatus').innerHTML = '';

    const select = document.getElementById('preferredCourtType');
    if (select) {
        select.value = state.config.preferredCourtType || 'mixed';
    }
}

function renderCourtList() {
    const container = document.getElementById('courtListContainer');
    if (!container) return;
    
    if (state.courts.length === 0) {
        container.innerHTML = `<div class="alert alert-warning">Ch∆∞a c√≥ s√¢n n√†o ƒë∆∞·ª£c c·∫•u h√¨nh.</div>`;
        return;
    }

    let html = `<div class='table-responsive'><table class='table table-striped table-sm'>
        <thead>
            <tr>
                <th>T√™n S√¢n</th>
                <th>Gi·ªù B·∫Øt ƒê·∫ßu</th>
                <th>Th·ªùi L∆∞·ª£ng Max (Ph√∫t)</th>
                <th>Ph√¢n Lo·∫°i</th>
                <th class="text-center">H√†nh ƒë·ªông</th>
            </tr>
        </thead>
        <tbody>`;
    
    state.courts.forEach((court, index) => {
        const type = court.isMixed ? 'B·∫£ng A (Nam - N·ªØ)' : 'B·∫£ng B (Nam)';
        const typeClass = court.isMixed ? 'badge bg-primary' : 'badge bg-info';
        html += `<tr>
            <td>${court.name}</td>
            <td>${court.startTime}</td>
            <td>${court.maxDurationMinutes}</td>
            <td><span class="${typeClass}">${type}</span></td>
            <td class="text-center">
                <button class="btn btn-sm btn-outline-secondary me-1" onclick="openCourtModal(${index})">S·ª≠a</button>
                <button class="btn btn-sm btn-outline-danger" onclick="deleteCourt(${index})">X√≥a</button>
            </td>
        </tr>`;
    });

    html += `</tbody></table></div>`;
    container.innerHTML = html;
}

function openCourtModal(index = null) {
    const modal = new bootstrap.Modal(document.getElementById('courtModal'));
    document.getElementById('courtFormStatus').innerHTML = '';
    document.getElementById('courtIndex').value = index !== null ? index : '';
    document.getElementById('courtModalLabel').textContent = index !== null ? 'S·ª≠a C·∫•u h√¨nh S√¢n' : 'Th√™m S√¢n M·ªõi';

    if (index !== null) {
        const court = state.courts[index];
        document.getElementById('courtName').value = court.name || '';
        document.getElementById('courtStartTime').value = court.startTime || '14:00';
        document.getElementById('courtMaxDuration').value = court.maxDurationMinutes || 180;
        document.getElementById('courtIsMixed').checked = court.isMixed || false;
    } else {
        document.getElementById('courtName').value = '';
        document.getElementById('courtStartTime').value = '14:00';
        document.getElementById('courtMaxDuration').value = 180;
        document.getElementById('courtIsMixed').checked = true;
    }
    modal.show();
}

function saveCourtChanges() {
    const index = document.getElementById('courtIndex').value;
    const name = document.getElementById('courtName').value.trim();
    const startTime = document.getElementById('courtStartTime').value;
    const maxDurationMinutes = parseInt(document.getElementById('courtMaxDuration').value);
    const isMixed = document.getElementById('courtIsMixed').checked;
    
    if (!name || !startTime || isNaN(maxDurationMinutes) || maxDurationMinutes <= 0) {
        document.getElementById('courtFormStatus').innerHTML = '<div class="alert alert-danger">Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß th√¥ng tin h·ª£p l·ªá.</div>';
        return;
    }

    const newCourt = { name, startTime, maxDurationMinutes, isMixed };

    if (index !== '') {
        state.courts[parseInt(index)] = newCourt;
        updateStatus('courtConfigStatus', 'success', `ƒê√£ c·∫≠p nh·∫≠t c·∫•u h√¨nh s√¢n ${name} th√†nh c√¥ng.`);
    } else {
        state.courts.push(newCourt);
        updateStatus('courtConfigStatus', 'success', `ƒê√£ th√™m s√¢n ${name} m·ªõi th√†nh c√¥ng.`);
    }
    
    stateChanged = true;
    saveConfig(); 
    renderCourtList();
    bootstrap.Modal.getInstance(document.getElementById('courtModal')).hide();
}

function deleteCourt(index) {
    if (confirm(`B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a s√¢n "${state.courts[index].name}"? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.`)) {
        const deletedName = state.courts[index].name;
        state.courts.splice(index, 1);
        stateChanged = true;
        saveConfig();
        renderCourtList();
        updateStatus('courtConfigStatus', 'success', `ƒê√£ x√≥a s√¢n ${deletedName} th√†nh c√¥ng.`);
    }
}

function loadDefaultCourtConfig() {
    if (confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën T·∫£i l·∫°i c·∫•u h√¨nh s√¢n M·∫∑c ƒë·ªãnh? M·ªçi thay ƒë·ªïi hi·ªán t·∫°i s·∫Ω b·ªã ghi ƒë√®.')) {
        state.courts = [
            { name: 'S√¢n 1', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, 
            { name: 'S√¢n 2', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, 
            { name: 'S√¢n 3', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, 
            { name: 'S√¢n 4', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, 
            { name: 'S√¢n 5', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }, 
            { name: 'S√¢n 6', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }, 
            { name: 'S√¢n 7', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }, 
            { name: 'S√¢n 8', startTime: '14:00', maxDurationMinutes: 180, isMixed: false } 
        ];
        stateChanged = true;
        saveConfig();
        renderCourtList();
        updateStatus('courtConfigStatus', 'success', 'ƒê√£ t·∫£i c·∫•u h√¨nh s√¢n m·∫∑c ƒë·ªãnh th√†nh c√¥ng.');
    }
}

function clearAllSchedules() {
    if (confirm("‚ö†Ô∏è C·∫¢NH B√ÅO: B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën X√ìA TO√ÄN B·ªò L·ªäCH THI ƒê·∫§U (c·∫£ k·∫øt qu·∫£, l·ªãch, v√≤ng chung k·∫øt)? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.")) {
        state.matchesA = [];
        state.matchesB = [];
        state.tableA = [];
        state.tableB = [];
        
        // Reset V√≤ng Chung k·∫øt v·ªÅ m·∫∑c ƒë·ªãnh (V26 Fix)
        state.semifinals = [ DEFAULT_SF1, DEFAULT_SF2 ];
        state.final = DEFAULT_FINAL;

        stateChanged = true;
        saveToGitHub();
        tinhVaCapNhatXepHang();
        renderMatchesView();
        renderFinals();
        renderOverview();
        showModal('X√≥a th√†nh c√¥ng', 'ƒê√£ x√≥a to√†n b·ªô l·ªãch thi ƒë·∫•u v√† k·∫øt qu·∫£. Vui l√≤ng t·∫°o l·ªãch m·ªõi.');
    }
}

/**
 * X√≥a ƒëi·ªÉm s·ªë c√°c tr·∫≠n ƒë·∫•u V√≤ng B·∫£ng.
 * V26 FIX: Th√™m logic reset V√≤ng Chung k·∫øt
 */
function clearGroupScores(group) {
    // Ki·ªÉm tra V√≤ng Chung k·∫øt ch∆∞a ho√†n th√†nh
    const finalsCompleted = state.semifinals.some(sf => sf.winner !== null) || state.final.winner !== null;
    
    if (finalsCompleted) {
        showModal('L·ªói X√≥a K·∫øt Qu·∫£', 'Kh√¥ng th·ªÉ x√≥a k·∫øt qu·∫£ V√≤ng B·∫£ng. Vui l√≤ng **X√≥a to√†n b·ªô l·ªãch** (·ªü tab C·∫•u h√¨nh) n·∫øu mu·ªën reset V√≤ng Chung k·∫øt, ho·∫∑c x√≥a k·∫øt qu·∫£ V√≤ng CK th·ªß c√¥ng.');
        return;
    }
    
    const message = group === 'ALL' 
        ? "B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën X√ìA TO√ÄN B·ªò k·∫øt qu·∫£ V√≤ng B·∫£ng (B·∫£ng A & B)? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c."
        : `B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën X√ìA TO√ÄN B·ªò k·∫øt qu·∫£ c·ªßa B·∫£ng ${group}? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.`;
    
    if (!confirm(message)) return;

    let clearedCount = 0;
    
    const matchesToClear = [];
    if (group === 'A' || group === 'ALL') matchesToClear.push(...state.matchesA);
    if (group === 'B' || group === 'ALL') matchesToClear.push(...state.matchesB);
    
    matchesToClear.forEach(match => {
        if (match.scoreA !== null || match.scoreB !== null) {
            match.scoreA = null;
            match.scoreB = null;
            match.winner = null;
            match.loser = null;
            clearedCount++;
        }
    });

    if (clearedCount > 0) {
        
        // ===============================================
        // START V26 FIX: Reset V√≤ng Chung K·∫øt
        // ===============================================
        state.semifinals = [ DEFAULT_SF1, DEFAULT_SF2 ];
        state.final = DEFAULT_FINAL;
        // ===============================================
        // END V26 FIX: Reset V√≤ng Chung K·∫øt
        // ===============================================
        
        tinhVaCapNhatXepHang();
        renderMatchesView();
        renderFinals(); // C·∫≠p nh·∫≠t giao di·ªán tab Chung k·∫øt
        renderOverview();
        
        stateChanged = true;
        saveToGitHub();
        updateStatus('clearScoreStatus', 'success', `ƒê√£ x√≥a ${clearedCount} k·∫øt qu·∫£ tr·∫≠n ƒë·∫•u th√†nh c√¥ng. V√≤ng Chung K·∫øt ƒë√£ ƒë∆∞·ª£c Reset.`);
    } else {
        updateStatus('clearScoreStatus', 'info', `Kh√¥ng c√≥ k·∫øt qu·∫£ n√†o c·ªßa B·∫£ng ${group} c·∫ßn x√≥a.`);
    }
}

// --- Import/Export CSV Logic ---

function handleFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const csvText = e.target.result;
            const matches = parseCSV(csvText);
            
            state.matchesA = matches.filter(m => m.bang === 'A');
            state.matchesB = matches.filter(m => m.bang === 'B');
            
            // X√≥a ƒëi·ªÉm v√≤ng chung k·∫øt khi import l·ªãch m·ªõi
            state.semifinals = [ DEFAULT_SF1, DEFAULT_SF2 ];
            state.final = DEFAULT_FINAL;

            stateChanged = true;
            tinhVaCapNhatXepHang();
            renderMatchesView();
            renderFinals();
            renderOverview();
            showModal('Import th√†nh c√¥ng', `ƒê√£ t·∫£i ${state.matchesA.length} tr·∫≠n B·∫£ng A v√† ${state.matchesB.length} tr·∫≠n B·∫£ng B.`);
        } catch (error) {
            showModal('L·ªói Import', `ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω file: ${error.message}`);
            console.error(error);
        }
    };
    reader.readAsText(file);
}

function parseCSV(csvText) {
    const lines = csvText.trim().split('\n');
    if (lines.length < 2) throw new Error("File CSV kh√¥ng c√≥ d·ªØ li·ªáu.");
    
    const headers = lines[0].split(',').map(h => h.trim());
    const dataLines = lines.slice(1);
    
    if (!headers.includes('teamA') || !headers.includes('teamB')) {
        throw new Error("CSV thi·∫øu c·ªôt b·∫Øt bu·ªôc (teamA, teamB).");
    }

    return dataLines.map(line => {
        const values = line.split(',');
        let match = {};
        headers.forEach((header, index) => {
            let value = values[index] ? values[index].trim() : '';
            if (header.startsWith('score')) {
                match[header] = value === '' ? null : parseInt(value, 10);
            } else {
                match[header] = value;
            }
        });
        
        // Ensure winner/loser are reset on import
        if (match.scoreA !== null && match.scoreB !== null) {
            if (match.scoreA >= 11 && match.scoreA > match.scoreB + 1) {
                match.winner = match.teamA;
                match.loser = match.teamB;
            } else if (match.scoreB >= 11 && match.scoreB > match.scoreA + 1) {
                match.winner = match.teamB;
                match.loser = match.teamA;
            } else {
                match.winner = null;
                match.loser = null;
            }
        } else {
            match.winner = null;
            match.loser = null;
        }

        return match;
    });
}

function exportSchedule() {
    const allMatches = [...state.matchesA, ...state.matchesB];
    const headers = ["teamA", "teamB", "time", "court", "bang", "scoreA", "scoreB", "winner", "loser"];
    let csv = headers.join(',') + '\n';

    allMatches.forEach(match => {
        const row = headers.map(header => {
            let value = match[header];
            if (value === null || value === undefined) {
                return "";
            }
            return `"${String(value).replace(/"/g, '""')}"`;
        }).join(',');
        csv += row + '\n';
    });

    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `schedule_tkd_export_${new Date().toISOString().slice(0, 10)}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    showModal('Export L·ªãch', 'ƒê√£ xu·∫•t l·ªãch thi ƒë·∫•u hi·ªán t·∫°i ra file CSV.');
}

// --- Automated Schedule Generation Logic ---

/**
 * T·∫£i l·ªãch c·ªë ƒë·ªãnh m·∫´u (CalendarTKD30)
 */
function taoLichCoDinh() {
    if (!confirm("B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën t·∫£i L·ªãch m·∫´u (CalendarTKD30)? L·ªãch v√† k·∫øt qu·∫£ hi·ªán t·∫°i s·∫Ω b·ªã ghi ƒë√®.")) return;
    
    try {
        const matches = parseCSV(FIXED_SCHEDULE_CSV);
        state.matchesA = matches.filter(m => m.bang === 'A');
        state.matchesB = matches.filter(m => m.bang === 'B');
        
        // Reset v√≤ng chung k·∫øt
        state.semifinals = [ DEFAULT_SF1, DEFAULT_SF2 ];
        state.final = DEFAULT_FINAL;
        
        stateChanged = true;
        tinhVaCapNhatXepHang();
        renderMatchesView();
        renderFinals();
        renderOverview();
        saveToGitHub();
        
        updateStatus('configStatus', 'success', `ƒê√£ t·∫£i l·ªãch m·∫´u (CalendarTKD30) th√†nh c√¥ng.`);
        
    } catch (error) {
         updateStatus('configStatus', 'danger', `L·ªói t·∫£i l·ªãch m·∫´u: ${error.message}`);
         console.error(error);
    }
}

/**
 * T·ª± ƒë·ªông ƒëi·ªÅn ƒëi·ªÉm 11-X cho c√°c tr·∫≠n ch∆∞a ƒë·∫•u (d√πng cho testing/simulating)
 */
function autoFillScores() {
    if (!confirm("B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën T·ª± ƒë·ªông ƒëi·ªÅn k·∫øt qu·∫£ (11 - X) cho c√°c tr·∫≠n ch∆∞a ƒë·∫•u?")) return;
    
    let filledCount = 0;
    const allMatches = [...state.matchesA, ...state.matchesB, ...state.semifinals, state.final];

    allMatches.forEach(match => {
        if (!match.winner && match.teamA && match.teamB && !match.teamA.includes('Nh·∫•t') && !match.teamA.includes('Th·∫Øng')) {
            
            // Random ng∆∞·ªùi th·∫Øng
            const isTeamAWinning = Math.random() < 0.5;
            
            // Random ƒëi·ªÉm cho ng∆∞·ªùi thua (0-9)
            const loserScore = Math.floor(Math.random() * 10);
            
            let scoreA, scoreB;
            if (isTeamAWinning) {
                scoreA = 11;
                scoreB = loserScore;
                match.winner = match.teamA;
            } else {
                scoreA = loserScore;
                scoreB = 11;
                match.winner = match.teamB;
            }

            match.scoreA = scoreA;
            match.scoreB = scoreB;
            
            if (match.id === 'F') {
                 match.runnerUp = isTeamAWinning ? match.teamB : match.teamA;
            } else {
                 match.loser = isTeamAWinning ? match.teamB : match.teamA;
            }

            filledCount++;
        }
    });

    if (filledCount > 0) {
        stateChanged = true;
        tinhVaCapNhatXepHang();
        renderMatchesView();
        renderFinals();
        renderOverview();
        saveToGitHub();
        updateStatus('configStatus', 'success', `ƒê√£ ƒëi·ªÅn ${filledCount} k·∫øt qu·∫£ t·ª± ƒë·ªông.`);
    } else {
        updateStatus('configStatus', 'info', `Kh√¥ng c√≥ tr·∫≠n n√†o c·∫ßn ƒëi·ªÅn k·∫øt qu·∫£.`);
    }
}


/**
 * T·ª± ƒë·ªông t·∫°o l·ªãch thi ƒë·∫•u v√≤ng tr√≤n 1 l∆∞·ª£t t·ªëi ∆∞u theo s√¢n (ƒë√£ t·ªëi ∆∞u h√≥a).
 */
function taoLichThiDauCungGio() {
    if (state.mixedTeams.length === 0 && state.maleTeams.length === 0) {
         showModal('L·ªói', 'Kh√¥ng th·ªÉ t·∫°o l·ªãch. Vui l√≤ng ƒë·∫£m b·∫£o ƒë√£ t·∫£i danh s√°ch ƒë·ªôi t·ª´ file players.json.');
         return;
    }

    if (state.matchesA.length > 0 || state.matchesB.length > 0) {
        if (!confirm("L·ªãch ƒë√£ t·ªìn t·∫°i. B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën T·∫†O L·∫†I l·ªãch? M·ªçi k·∫øt qu·∫£ hi·ªán t·∫°i s·∫Ω b·ªã x√≥a.")) return;
    }
    
    // Logic t·∫°o l·ªãch t·ªëi ∆∞u (ƒë∆∞·ª£c ƒë∆°n gi·∫£n h√≥a ·ªü ƒë√¢y, trong th·ª±c t·∫ø s·∫Ω ph·ª©c t·∫°p h∆°n)
    const matchesA = generateRoundRobinSchedule(state.mixedTeams, 'A');
    const matchesB = generateRoundRobinSchedule(state.maleTeams, 'B');
    
    const allMatches = assignCourtsToMatches(matchesA, matchesB, state.courts, state.config.preferredCourtType);
    
    // C·∫≠p nh·∫≠t state
    state.matchesA = allMatches.filter(m => m.bang === 'A');
    state.matchesB = allMatches.filter(m => m.bang === 'B');
    
    // Reset v√≤ng chung k·∫øt
    state.semifinals = [ DEFAULT_SF1, DEFAULT_SF2 ];
    state.final = DEFAULT_FINAL;

    stateChanged = true;
    tinhVaCapNhatXepHang();
    renderMatchesView();
    renderFinals();
    renderOverview();
    saveToGitHub();
    
    updateStatus('configStatus', 'success', `ƒê√£ t·∫°o l·ªãch thi ƒë·∫•u v√≤ng tr√≤n t·ªëi ∆∞u: ${matchesA.length} tr·∫≠n B·∫£ng A v√† ${matchesB.length} tr·∫≠n B·∫£ng B.`);
}

/**
 * Thu·∫≠t to√°n t·∫°o l·ªãch v√≤ng tr√≤n 1 l∆∞·ª£t (Round Robin).
 */
function generateRoundRobinSchedule(teams, bang) {
    if (teams.length < 2) return [];

    const schedule = [];
    const n = teams.length;
    const teamNames = teams.map(t => t.name);
    
    // Thu·∫≠t to√°n Circle Method
    const fixedTeam = teamNames[0];
    let rotatingTeams = teamNames.slice(1);
    
    const rounds = n % 2 === 0 ? n - 1 : n;
    
    for (let r = 0; r < rounds; r++) {
        let currentRound = [];
        
        // Tr·∫≠n ƒë·∫•u c·ªßa ƒë·ªôi c·ªë ƒë·ªãnh (n·∫øu s·ªë ƒë·ªôi l√† ch·∫µn)
        if (n % 2 === 0) {
            const opponent = rotatingTeams[rotatingTeams.length - 1];
            currentRound.push({ teamA: fixedTeam, teamB: opponent, bang: bang });
        }
        
        // C√°c tr·∫≠n ƒë·∫•u c√≤n l·∫°i (xoay v√≤ng)
        const half = rotatingTeams.length / 2;
        for (let i = 0; i < half; i++) {
            currentRound.push({ 
                teamA: rotatingTeams[i], 
                teamB: rotatingTeams[rotatingTeams.length - 1 - i], 
                bang: bang 
            });
        }
        
        schedule.push(...currentRound);
        
        // Xoay v√≤ng c√°c ƒë·ªôi (Circle Method)
        if (rotatingTeams.length > 0) {
            const last = rotatingTeams.pop();
            rotatingTeams.unshift(last);
        }
    }
    
    return schedule.map(match => ({
        ...match,
        time: null, // S·∫Ω ƒë∆∞·ª£c g√°n sau
        court: null, // S·∫Ω ƒë∆∞·ª£c g√°n sau
        scoreA: null,
        scoreB: null,
        winner: null,
        loser: null
    }));
}

/**
 * Thu·∫≠t to√°n g√°n s√¢n v√† gi·ªù thi ƒë·∫•u t·ªëi ∆∞u (T·ªëi ∆∞u h√≥a theo th·ªùi gian v√† s√¢n).
 */
function assignCourtsToMatches(matchesA, matchesB, courts, preferredCourtType) {
    const allMatches = [...matchesA, ...matchesB];
    
    // Kh·ªüi t·∫°o tr·∫°ng th√°i s√¢n
    const courtStates = courts.map(court => ({
        ...court,
        currentTime: parseTime(court.startTime),
        available: true
    }));
    
    // ∆Øu ti√™n s√¢n cho b·∫£ng A/B
    const preferredCourt = preferredCourtType === 'mixed' ? 'A' : 'B';
    
    // Sort matches: ∆Øu ti√™n b·∫£ng ∆∞u ti√™n
    allMatches.sort((a, b) => {
        if (a.bang === preferredCourt && b.bang !== preferredCourt) return -1;
        if (a.bang !== preferredCourt && b.bang === preferredCourt) return 1;
        return 0;
    });

    let assignedMatches = [];
    let matchIndex = 0;
    const matchDuration = 20; // Ph√∫t/tr·∫≠n (bao g·ªìm c·∫£ th·ªùi gian ngh·ªâ)

    while (matchIndex < allMatches.length) {
        let match = allMatches[matchIndex];
        let bestCourt = null;
        let earliestTime = Infinity;

        // T√¨m s√¢n ph√π h·ª£p v√† tr·ªëng
        courtStates.forEach(court => {
            const courtType = court.isMixed ? 'A' : 'B';
            
            if (courtType === match.bang) {
                const availableTime = court.currentTime;
                
                // Ki·ªÉm tra th·ªùi l∆∞·ª£ng t·ªëi ƒëa
                const maxTime = addMinutes(parseTime(court.startTime), court.maxDurationMinutes);
                if (availableTime < maxTime) {
                    if (availableTime < earliestTime) {
                        earliestTime = availableTime;
                        bestCourt = court;
                    }
                }
            }
        });

        if (bestCourt) {
            // G√°n gi·ªù v√† s√¢n
            match.time = formatTime(earliestTime);
            match.court = bestCourt.name;
            
            // C·∫≠p nh·∫≠t tr·∫°ng th√°i s√¢n: Th·ªùi gian tr·∫≠n ti·∫øp theo
            bestCourt.currentTime = addMinutes(earliestTime, matchDuration);
            
            assignedMatches.push(match);
            matchIndex++;
        } else {
             // Kh√¥ng t√¨m th·∫•y s√¢n tr·ªëng ph√π h·ª£p n√†o trong th·ªùi gian c√≤n l·∫°i.
             // (X·∫£y ra khi t·∫•t c·∫£ s√¢n ƒë·ªÅu ƒë√£ ƒë·∫ßy ho·∫∑c v∆∞·ª£t qu√° th·ªùi l∆∞·ª£ng t·ªëi ƒëa)
             // TƒÉng th·ªùi gian l√™n 5 ph√∫t v√† th·ª≠ l·∫°i (n·∫øu c·∫ßn)
             break; // Tho√°t v√≤ng l·∫∑p n·∫øu kh√¥ng th·ªÉ g√°n n·ªØa
        }
    }
    
    // S·∫Øp x·∫øp l·∫°i theo Gi·ªù/S√¢n
    assignedMatches.sort((a, b) => {
         if (a.time && b.time && a.time.localeCompare(b.time) !== 0) {
            return a.time.localeCompare(b.time);
        }
        return a.court.localeCompare(b.court);
    });

    return assignedMatches;
}

/**
 * Helper: Chuy·ªÉn HH:mm th√†nh s·ªë ph√∫t t·ª´ 00:00.
 */
function parseTime(timeStr) {
    const [h, m] = timeStr.split(':').map(Number);
    return h * 60 + m;
}

/**
 * Helper: Chuy·ªÉn s·ªë ph√∫t th√†nh HH:mm.
 */
function formatTime(minutes) {
    const h = Math.floor(minutes / 60);
    const m = minutes % 60;
    return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
}

/**
 * Helper: C·ªông th√™m ph√∫t.
 */
function addMinutes(minutes, add) {
    return minutes + add;
}


// Kh·ªüi t·∫°o l·ªãch V√≤ng Chung k·∫øt t·ª± ƒë·ªông
function scheduleFinalsAuto() {
     if (state.matchesA.length === 0 || state.matchesB.length === 0) {
         showModal('L·ªói', 'Vui l√≤ng t·∫°o l·ªãch V√≤ng B·∫£ng tr∆∞·ªõc.');
         return;
     }
     if (confirm("B·∫°n c√≥ mu·ªën T·ª± ƒë·ªông ƒë·∫∑t l·∫°i gi·ªù/s√¢n cho V√≤ng Chung k·∫øt kh√¥ng?")) {
          // L·∫•y c·∫•u h√¨nh s√¢n 3 (ho·∫∑c s√¢n b·∫•t k·ª≥ m√† isMixed=true)
          const court3 = state.courts.find(c => c.name === 'S√¢n 3') || state.courts.find(c => c.isMixed) || { name: 'S√¢n CK', startTime: '16:40' };
          
          state.semifinals[0].time = '16:40';
          state.semifinals[0].court = court3.name;
          state.semifinals[1].time = '17:05';
          state.semifinals[1].court = court3.name;
          state.final.time = '17:30';
          state.final.court = court3.name;
          
          stateChanged = true;
          renderFinals();
          showModal('Th√¥ng b√°o', `ƒê√£ ƒë·∫∑t l·ªãch V√≤ng Chung k·∫øt: SF1 l√∫c 16:40, SF2 l√∫c 17:05, Chung k·∫øt l√∫c 17:30 t·∫°i ${court3.name}.`);
     }
}


</script>
</body>
</html>
