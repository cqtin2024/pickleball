<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TKD Championship 2025 — Quản lý giải Pickleball V28 GitHub (Logic Auto-seed Bán kết 100%)</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body { background:#f7f9fc; font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial; color:#222; padding:18px; }
    .tab-content { margin-top: 18px; }
    .logo { 
      width:64px; 
      height:64px; 
      object-fit:contain; 
      border-radius:8px; 
      border:1px solid #e6eefc; 
      padding:6px; 
      background:#fff; 
    }
    table th { background:#0d6efd; color:#fff; position:sticky; top:0; }
    .status { font-size:0.95rem; color:#555; }
    /* Responsive adjustment for match inputs */
    .match-score-cell input {
      width: 45px;
      text-align: center;
      padding: 0.1rem;
    }
    @media (max-width: 576px) {
      .match-score-cell input {
        width: 35px;
      }
    }
    .winner { font-weight: bold; color: green; }
    .loser { color: red; }
    .ranking-container { display: flex; flex-direction: column; gap: 20px; }
    @media (min-width: 768px) {
        .ranking-container > div { flex: 1; }
    }
  </style>
</head>
<body onload="initApp()">
<div class="container">
  <div class="d-flex justify-content-between align-items-center mb-3">
    <div class="d-flex align-items-center gap-2">
      <img class="logo" src="data/logoTKD.png" alt="Logo TKD">
      <div>
        <h3 class="mb-0">TKD Championship 2025</h3>
        <div>Ngày thi đấu: 18/10/2025 (**V28**)</div>
      </div>
    </div>
    <div>
      <div id="autoSaveStatus" class="text-end status">Auto-save (30s): <span id="autoState" class="text-danger">Tắt</span></div>
      <div id="lastSaved" class="text-end status">Chưa lưu</div>
    </div>
  </div>

  <ul class="nav nav-tabs" id="mainTabs">
    <li class="nav-item"><button class="nav-link active" data-bs-toggle="tab" data-bs-target="#overview" onclick="renderOverview()">Tổng quan</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#matches" id="matchesTabButton" onclick="renderMatchesView()">Vòng Bảng</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#finals" onclick="renderFinals()">Vòng Chung Kết</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#results" onclick="tinhVaCapNhatXepHang(); renderFinalResults();">Kết quả Chung cuộc</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#config" id="configTabButton" onclick="renderConfig()">Cấu hình</button></li>
  </ul>

  <div class="tab-content">
    <div class="tab-pane fade show active p-3" id="overview">
        <div id="overviewContent">Đang tải dữ liệu...</div>
    </div>
    
    <div class="tab-pane fade p-3" id="matches">
      <div class="d-flex gap-2 mb-3 flex-wrap">
        <label for="viewMode" class="form-label mb-0 align-self-center text-nowrap">Chế độ xem:</label>
        <select id="viewMode" class="form-select form-select-sm w-auto" onchange="renderMatchesView()">
            <option value="table">Theo Bảng đấu</option>
            <option value="court" selected>Theo Sân thi đấu</option>
        </select>
        
        <button class="btn btn-sm btn-info ms-auto" onclick="document.getElementById('fileInput').click()">Import Lịch (CSV)</button>
        <input type="file" id="fileInput" accept=".csv" style="display: none;" onchange="handleFileSelect(event)">
        
        <button class="btn btn-sm btn-warning" onclick="exportSchedule()">Export Lịch (CSV)</button>
      </div>
      
      <div id="matchesViewContent">
        <h6 id="scheduleAHeader" class="mt-4">Bảng A (Nam - Nữ)</h6><div id="tableMatchesA">Chưa có lịch thi đấu.</div>
        
        <h6 class="mt-4">Bảng B (Nam)</h6><div id="tableMatchesB">Chưa có lịch thi đấu.</div>
      </div>

      <button class="btn btn-warning mt-4" onclick="scheduleFinalsAuto()">Lên lịch Vòng Chung kết (Tự động hóa)</button>
    </div>

    <div class="tab-pane fade p-3" id="finals">
        <div id="finalsContent">
            <h6 class="mt-4">Vòng Bán kết (SF1: 16:40, SF2: 17:05, Sân 3)</h6>
            <div id="semifinalMatches">Chưa có lịch thi đấu bán kết. Kết quả Vòng Bảng sẽ tự động cập nhật lịch.</div>

            <h6 class="mt-4">Trận Chung kết (17:30, Sân 3)</h6>
            <div id="finalMatch">Chưa có lịch thi đấu chung kết.</div>
        </div>
    </div>

    <div class="tab-pane fade p-3" id="results">
        <h5 class="mb-3">Bảng xếp hạng Vòng Bảng (Ưu tiên: W > Đối đầu > Hiệu số > Tổng điểm)</h5>
        <div id="rankingTables" class="ranking-container">
            </div>

        <hr class="my-4">

        <h5 class="mb-3">Danh hiệu Chung cuộc</h5>
        <p id="champion">Vô địch: Đang chờ kết quả...</p>
        <p id="runnerUp">Á quân: Đang chờ kết quả...</p>
        <p id="thirdPlace">Hạng Ba Đồng Hạng: Đang chờ kết quả...</p>
    </div>

    <div class="tab-pane fade p-3" id="config">
      <h5 class="mb-3">Công cụ Lập & Điền Lịch Thi đấu</h5>
      <div class="d-flex gap-2 mb-4 flex-wrap">
        <button class="btn btn-sm btn-primary" onclick="taoLichThiDauCungGio()">Tạo lịch thi đấu Tối ưu (Tự động)</button>
        <button class="btn btn-sm btn-secondary" onclick="taoLichCoDinh()">Tải lịch Mẫu (**CalendarTKD30**)</button>
        <button class="btn btn-sm btn-success" onclick="autoFillScores()">Điền kết quả Tự động (11 - X)</button>
        <button class="btn btn-sm btn-danger" onclick="clearAllSchedules()">Xóa Toàn bộ Lịch</button>
      </div>
      
      <hr>
      
      <h5 class="mt-4">🧹 Công cụ Xóa Kết quả Vòng Bảng</h5>
      <div class="d-flex gap-2 mb-4 flex-wrap">
          <button class="btn btn-sm btn-outline-danger" onclick="clearGroupScores('A')">Xóa Kết quả Bảng A</button>
          <button class="btn btn-sm btn-outline-danger" onclick="clearGroupScores('B')">Xóa Kết quả Bảng B</button>
          <button class="btn btn-sm btn-danger ms-auto" onclick="clearGroupScores('ALL')">Xóa Toàn bộ Vòng Bảng</button>
      </div>
      <div id="clearScoreStatus"></div>
      <hr>
      <h5 class="mt-4">⚙️ Cấu hình Sân thi đấu & Lịch Tối ưu</h5>
      <p class="text-muted small">Quản lý danh sách sân thi đấu. Sân được gán loại bảng đấu (A/B) để phục vụ chức năng tạo lịch Tối ưu.</p>
      <div class="d-flex gap-2 mb-3 flex-wrap">
          <button class="btn btn-sm btn-primary" onclick="openCourtModal()">+ Thêm Sân Mới</button>
          <button class="btn btn-sm btn-outline-info" onclick="loadDefaultCourtConfig()">Tải cấu hình Mặc định</button>
      </div>
      <div id="courtListContainer">
          </div>
      <div id="courtConfigStatus"></div>
      <hr>
      
      <h5 class="mt-4">🛠️ Cấu hình Tối ưu Lịch thi đấu</h5>
      <div class="row g-2 mb-4">
        <div class="col-md-6">
          <label for="preferredCourtType" class="form-label">Ưu tiên Sân nào cho trận đầu tiên (Chức năng Tạo lịch Tối ưu)?</label>
          <select id="preferredCourtType" class="form-select" onchange="updatePreferredCourtType()">
            <option value="mixed">Bảng A (Nam - Nữ) - Mặc định</option>
            <option value="male">Bảng B (Nam)</option>
          </select>
          <div class="form-text">Xác định loại sân sẽ được ưu tiên gán trận đấu đầu tiên trong thuật toán tạo lịch.</div>
        </div>
        <div class="col-md-6">
            <label class="form-label">Công cụ Xuất/Lưu Dữ liệu</label>
            <div class="d-flex gap-2">
                 <button class="btn btn-success" onclick="saveToGitHub(true)">Cập nhật lên GitHub ngay</button>
                 <button class="btn btn-secondary" onclick="exportDataToJson()">Xuất tất cả ra JSON</button>
            </div>
            <div class="form-text">Lưu trạng thái hiện tại (state.json) lên GitHub hoặc tải về máy.</div>
        </div>
      </div>
      <hr>
      <h5 class="mt-4">💾 Cấu hình Kết nối GitHub</h5>
      <p class="text-muted">Nhập thông tin kho lưu trữ GitHub để tự động lưu trữ dữ liệu giải đấu (Auto-save: 30s).</p>
      <div class="row g-2 mb-2">
        <div class="col-md-3"><input id="cfgOwner" class="form-control" placeholder="Owner (Ví dụ: user_name)"></div>
        <div class="col-md-3"><input id="cfgRepo" class="form-control" placeholder="Repo (Ví dụ: my-data-repo)"></div>
        <div class="col-md-3"><input id="cfgFolder" class="form-control" value="data"></div>
        <div class="col-md-3"><input id="cfgFile" class="form-control" value="state.json"></div>
      </div>
      <input id="cfgToken" type="password" class="form-control mb-2" placeholder="Dán GitHub Personal Access Token (PAT) tại đây">
      <div class="d-flex gap-2">
        <button class="btn btn-primary" onclick="saveConfig()">Lưu cấu hình Local</button>
        <button class="btn btn-success" onclick="checkConnection()">Kiểm tra & Tải Dữ liệu</button>
      </div>
      <div class="mt-2" id="configStatus"></div>
      
      <div class="card bg-light mt-4 shadow-sm">
        <div class="card-body">
            <h5 class="card-title text-info">🔑 Hướng dẫn lấy GitHub Token (PAT)</h5>
            <ol class="small mb-0">
                <li>Truy cập <a href="https://github.com/settings/tokens" target="_blank" class="text-info">GitHub Tokens Settings</a> (Bạn cần đăng nhập).</li>
                <li>Chọn **Generate new token** (hoặc **Generate new token (classic)** nếu bạn dùng tài khoản cũ).</li>
                <li>**Tên Token:** Đặt tên dễ nhớ (ví dụ: `TKDManager_AutoSave`).</li>
                <li>**Thời hạn:** Chọn tùy ý (nên chọn 90 ngày hoặc Tùy chỉnh).</li>
                <li>**Phạm vi (Scopes):** **BẮT BUỘC** tích chọn ô **`repo`** (cho phép truy cập vào kho lưu trữ).</li>
                <li>Nhấn **Generate token** và **SAO CHÉP** chuỗi Token vừa được tạo.</li>
                <li>Dán chuỗi Token đó vào ô "Dán GitHub Personal Access Token (PAT) tại đây" bên trên.</li>
            </ol>
            <p class="mt-2 mb-0 text-danger small">⚠️ **Lưu ý:** Token chỉ hiển thị **MỘT LẦN**. Hãy sao chép ngay lập tức và giữ bí mật. Nếu mất, bạn phải tạo lại Token mới.</p>
        </div>
      </div>
      </div>
  </div>
</div>

<div class="modal fade" id="courtModal" tabindex="-1" aria-labelledby="courtModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="courtModalLabel">Thêm/Sửa Cấu hình Sân</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="courtForm">
          <input type="hidden" id="courtIndex" value="">
          <div class="mb-3">
            <label for="courtName" class="form-label">Tên Sân</label>
            <input type="text" class="form-control" id="courtName" required>
          </div>
          <div class="mb-3">
            <label for="courtStartTime" class="form-label">Giờ Bắt Đầu (HH:mm)</label>
            <input type="time" class="form-control" id="courtStartTime" required>
          </div>
          <div class="mb-3">
            <label for="courtMaxDuration" class="form-label">Thời Lượng Tối Đa (Phút)</label>
            <input type="number" class="form-control" id="courtMaxDuration" min="1" required>
          </div>
          <div class="form-check mb-3">
            <input class="form-check-input" type="checkbox" id="courtIsMixed">
            <label class="form-check-label" for="courtIsMixed">
              Dành cho Bảng A (Nam - Nữ)
            </label>
            <div class="form-text">Nếu không chọn, sân sẽ dành cho Bảng B (Nam).</div>
          </div>
          <div id="courtFormStatus" class="mt-2"></div>
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Hủy</button>
        <button type="button" class="btn btn-primary" onclick="saveCourtChanges()">Lưu Thay Đổi</button>
      </div>
    </div>
  </div>
</div>
<div class="modal fade" id="customAlertModal" tabindex="-1" aria-labelledby="customAlertModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="customAlertModalLabel">Thông báo</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="customAlertModalBody">
        Nội dung thông báo
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Đóng</button>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script> 

<script>
// Dữ liệu lịch cố định từ file CalendarTKD30.csv (ĐÃ CẬP NHẬT theo yêu cầu)
const FIXED_SCHEDULE_CSV = `teamA,teamB,time,court,bang,scoreA,scoreB
Triều/Minh,Hiển/P.Hùng,14:00,Sân 1,B,,
Giang/Long,Hường/Đạt,14:00,Sân 2,A,,
Hậu/Dũng,Hạnh/Tiến,14:00,Sân 3,A,,
Huyền/Luân,Linh/M.Hùng,14:00,Sân 7,A,,
Tiệp/Thủy,Phương/Thanh,14:15,Sân 1,B,,
Tín/Khiêm,Ánh/Toàn,14:15,Sân 2,B,,
Hậu/Dũng,Hường/Đạt,14:15,Sân 3,A,,
Giang/Long,Huyền/Luân,14:15,Sân 7,A,,
Triều/Minh,Tín/Khiêm,14:30,Sân 1,B,,
Tiệp/Thủy,Hiển/P.Hùng,14:30,Sân 2,B,,
Hạnh/Tiến,Linh/M.Hùng,14:30,Sân 3,A,,
Phương/Thanh,Ánh/Toàn,14:30,Sân 7,B,,
Huyền/Luân,Hường/Đạt,14:45,Sân 2,A,,
Hạnh/Tiến,Giang/Long,14:45,Sân 3,A,,
Hậu/Dũng,Linh/M.Hùng,14:45,Sân 7,A,,
Tiệp/Thủy,Ánh/Toàn,15:00,Sân 2,B,,
Tín/Khiêm,Hiển/P.Hùng,15:00,Sân 3,B,,
Phương/Thanh,Triều/Minh,15:15,Sân 2,B,,
Giang/Long,Linh/M.Hùng,15:15,Sân 3,A,,
Hạnh/Tiến,Hường/Đạt,15:30,Sân 2,A,,
Hậu/Dũng,Huyền/Luân,15:30,Sân 3,A,,
Tiệp/Thủy,Tín/Khiêm,15:45,Sân 2,B,,
Phương/Thanh,Hiển/P.Hùng,15:45,Sân 3,B,,
Triều/Minh,Ánh/Toàn,16:00,Sân 2,B,,
Hậu/Dũng,Giang/Long,16:00,Sân 3,A,,
Hạnh/Tiến,Huyền/Luân,16:15,Sân 2,A,,
Linh/M.Hùng,Hường/Đạt,16:15,Sân 3,A,,
Tiệp/Thủy,Triều/Minh,16:30,Sân 2,B,,
Ánh/Toàn,Hiển/P.Hùng,16:30,Sân 3,B,,
Phương/Thanh,Tín/Khiêm,16:45,Sân 2,B,`;

// Biến state lưu trữ dữ liệu chính của ứng dụng.
let state = { 
  mixedTeams: [], // Sẽ được tải từ players.json
  maleTeams: [],  // Sẽ được tải từ players.json
  matchesA: [], 
  matchesB: [],
  tableA: [], // Bảng xếp hạng A (Sẽ được lưu và tải)
  tableB: [], // Bảng xếp hạng B (Sẽ được lưu và tải)
  
  // Court Configuration
  courts: [
    { name: 'Sân 1', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, 
    { name: 'Sân 2', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, 
    { name: 'Sân 3', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, 
    { name: 'Sân 4', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, 
    { name: 'Sân 5', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }, 
    { name: 'Sân 6', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }, 
    { name: 'Sân 7', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }, 
    { name: 'Sân 8', startTime: '14:00', maxDurationMinutes: 180, isMixed: false } 
  ],
  
  // LOGIC BÁN KẾT 
  semifinals: [
    { id: 'SF1', teamA: 'Nhất A', teamB: 'Nhì B', scoreA: null, scoreB: null, time: '16:40', court: 'Sân 3', winner: null, loser: null }, 
    { id: 'SF2', teamA: 'Nhất B', teamB: 'Nhì A', scoreA: null, scoreB: null, time: '17:05', court: 'Sân 3', winner: null, loser: null }  
  ],
  final: { id: 'F', teamA: 'Thắng SF1', teamB: 'Thắng SF2', scoreA: null, scoreB: null, time: '17:30', court: 'Sân 3', winner: null, runnerUp: null }, 
  config: { 
    preferredCourtType: 'mixed',
    owner: '', 
    repo: '', 
    folder: 'data', 
    file: 'state.json', 
    token: ''
  }
};

// ===============================================
// V26/V28 FIX: Định nghĩa các Constants cho Reset
// ===============================================
const DEFAULT_SF1 = { id: 'SF1', teamA: 'Nhất A', teamB: 'Nhì B', scoreA: null, scoreB: null, time: '16:40', court: 'Sân 3', winner: null, loser: null };
const DEFAULT_SF2 = { id: 'SF2', teamA: 'Nhất B', teamB: 'Nhì A', scoreA: null, scoreB: null, time: '17:05', court: 'Sân 3', winner: null, loser: null };
const DEFAULT_FINAL = { id: 'F', teamA: 'Thắng SF1', teamB: 'Thắng SF2', scoreA: null, scoreB: null, time: '17:30', court: 'Sân 3', winner: null, runnerUp: null };
// ===============================================

let stateChanged = false; // Biến cờ theo dõi thay đổi dữ liệu
let currentSha = null; // Biến lưu trữ SHA của file trên GitHub
let autoSaveInterval = null; // Biến lưu trữ ID của interval

// --- Khởi tạo ứng dụng ---
function initApp() {
    loadConfig();
    checkConnection(); // Tải config xong là check connection và load data luôn
}

// --- Custom Modal Function ---
function showModal(title, body) {
    document.getElementById('customAlertModalLabel').textContent = title;
    document.getElementById('customAlertModalBody').innerHTML = body;
    const modal = new bootstrap.Modal(document.getElementById('customAlertModal'));
    modal.show();
}

/**
 * Hàm hiển thị thông báo trạng thái tạm thời
 * @param {string} id - ID của div chứa status
 * @param {string} type - loại alert (success, danger, info, warning)
 * @param {string} message - nội dung thông báo
 */
function updateStatus(id, type, message) {
    const statusDiv = document.getElementById(id);
    if (statusDiv) {
        statusDiv.innerHTML = `<div class="alert alert-${type} alert-dismissible fade show p-2 small" role="alert">
            ${message}
            <button type="button" class="btn-close p-2" data-bs-dismiss="alert" aria-label="Close"></button>
        </div>`;
    }
}

// --- Helper Functions cho Base64 ---
function b64EncodeUnicode(str) {
  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g,
    function(match, p1) {
      return String.fromCharCode('0x' + p1);
    }));
}

function b64DecodeUnicode(str) {
  return decodeURIComponent(atob(str).split('').map(function(c) {
    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
  }).join(''));
}

// --- GitHub API Functions ---

/**
 * Lấy SHA mới nhất và nội dung (Base64) của file trên GitHub.
 * **V27 FIX:** Tăng cường xử lý 404 (file không tồn tại)
 * @param {object} cfg - Cấu hình GitHub (owner, repo, folder, file, token)
 * @param {string} fileName - Tên file cần lấy SHA (mặc định là cfg.file)
 * @returns {Promise<{sha: string|null, content: string|null}>}
 */
async function fetchFileSha(cfg, fileName = cfg.file) {
    const filePath = `${cfg.folder}/${fileName}`;
    const apiUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}/contents/${filePath}`;
    
    try {
        const response = await fetch(apiUrl, {
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });
        
        if (response.ok) {
            const data = await response.json();
            if (fileName === cfg.file) {
                 currentSha = data.sha; // Chỉ lưu SHA của state.json
            }
            return { sha: data.sha, content: data.content };
        } else if (response.status === 404) {
            // Trường hợp file không tồn tại: trả về null mà không báo lỗi
            if (fileName === cfg.file) {
                 currentSha = null; 
            }
            return { sha: null, content: null };
        } else {
            // Lỗi khác (401, 403, 500...)
            const errorData = await response.json();
            throw new Error(`Lỗi HTTP ${response.status}: ${errorData.message || response.statusText}`);
        }
    } catch (error) {
        console.error(`Lỗi Fetch SHA (${fileName}):`, error);
        throw new Error(`Lỗi kết nối hoặc API: ${error.message}`);
    }
}

/**
 * Tải danh sách đội từ players.json
 * **V27 FIX:** Đảm bảo luôn trả về true/false và không bị lỗi nếu players.json không tồn tại.
 */
async function loadPlayersFromGitHub(cfg) {
    const fileName = 'players.json';
    
    try {
        updateStatus('configStatus', 'info', 'Đang tải danh sách đội từ GitHub (players.json)...');
        // fetchFileSha sẽ trả về {sha: null, content: null} nếu 404
        const result = await fetchFileSha(cfg, fileName); 
        
        if (result.content) {
            const jsonString = b64DecodeUnicode(result.content);
            const loadedTeams = JSON.parse(jsonString);

            if (Array.isArray(loadedTeams.mixedTeams) && Array.isArray(loadedTeams.maleTeams)) {
                state.mixedTeams = loadedTeams.mixedTeams;
                state.maleTeams = loadedTeams.maleTeams;
                updateStatus('configStatus', 'success', `Tải danh sách đội thành công (${state.mixedTeams.length + state.maleTeams.length} đội).`);
                return true;
            } else {
                throw new Error("File players.json không đúng định dạng (thiếu mixedTeams/maleTeams).");
            }
        } else {
            // File không tồn tại (404) hoặc trống
            updateStatus('configStatus', 'warning', 'Không tìm thấy file players.json. Dùng danh sách đội khởi tạo (trống).');
            return false;
        }
    } catch (error) {
        // Xử lý lỗi JSON Parse hoặc lỗi kết nối. Vẫn trả về true để cho phép state.json load.
        console.error("Lỗi khi tải players.json:", error);
        updateStatus('configStatus', 'danger', `Lỗi tải danh sách đội: ${error.message}. Sử dụng dữ liệu trống.`);
        return true; 
    }
}

/**
 * Tải trạng thái giải đấu (state.json) từ GitHub.
 */
async function loadFromGitHub() {
    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) {
         updateStatus('configStatus', 'warning', 'Thiếu thông tin kết nối GitHub. Vui lòng nhập Token/Repo.');
         return;
    }

    // 1. Load Teams (danh sách đội) - Dù lỗi cũng cố gắng load state.json
    await loadPlayersFromGitHub(cfg); 

    // 2. Load App State (state.json)
    try {
        updateStatus('configStatus', 'info', 'Đang tải trạng thái giải đấu từ GitHub (state.json)...');
        // fetchFileSha sẽ tự động cập nhật currentSha, và trả về null nếu 404
        const result = await fetchFileSha(cfg, cfg.file); 
        
        if (result.content) {
            const jsonString = b64DecodeUnicode(result.content);
            const loadedState = JSON.parse(jsonString);

            // Ghi đè các giá trị khác ngoài teams (teams đã được load từ players.json)
            state.matchesA = loadedState.matchesA || [];
            state.matchesB = loadedState.matchesB || [];
            
            // NEW: Tải bảng xếp hạng nếu có 
            state.tableA = loadedState.tableA || []; 
            state.tableB = loadedState.tableB || [];
            
            if (loadedState.courts) {
                state.courts = loadedState.courts;
            }
            
            // Cấu trúc mặc định mới cho bán kết/chung kết
            const defaultSF1Info = { teamA: 'Nhất A', teamB: 'Nhì B', court: 'Sân 3', time: '16:40' };
            const defaultSF2Info = { teamA: 'Nhất B', teamB: 'Nhì A', court: 'Sân 3', time: '17:05' };
            const defaultFinalInfo = { teamA: 'Thắng SF1', teamB: 'Thắng SF2', court: 'Sân 3', time: '17:30' };

            // Logic tải cho semifinals/final (giữ lại kết quả nếu đã có, reset đội nếu đội vòng bảng thay đổi)
            if (loadedState.semifinals && loadedState.semifinals.length === 2) {
                 // Nếu đã có đội thực tế được gán (ví dụ: Team X), giữ nguyên 
                state.semifinals = loadedState.semifinals;
                // Nếu là trạng thái rỗng default (Nhất A vs Nhì A), cập nhật lại thời gian và sân theo V24
                state.semifinals.forEach((sf, index) => {
                     if (sf.teamA === 'Nhất A' || sf.teamA === 'Nhất B') {
                        sf.court = defaultSF1Info.court;
                        sf.time = index === 0 ? defaultSF1Info.time : defaultSF2Info.time;
                    }
                });
            } else {
                 // Dùng default V24/V28
                 state.semifinals = [ DEFAULT_SF1, DEFAULT_SF2 ];
            }
            
            state.final = loadedState.final || state.final;
            if (!state.final.winner) {
                state.final.court = defaultFinalInfo.court;
                state.final.time = defaultFinalInfo.time;
            }
            
            updateStatus('configStatus', 'success', `Tải trạng thái giải đấu thành công từ: ${cfg.owner}/${cfg.repo}/${cfg.folder}/${cfg.file}`);
            document.getElementById('lastSaved').textContent = `Lần tải: ${new Date().toLocaleTimeString('vi-VN')}`;
        } else {
             // File state.json không tồn tại (404)
            updateStatus('configStatus', 'warning', 'File trạng thái (state.json) chưa tồn tại. Dùng dữ liệu trống khởi tạo. Vui lòng nhấn Lưu hoặc Tự động lưu để tạo file.');
        }
        
        // Luôn cập nhật giao diện sau khi tải xong teams/state (hoặc dùng mặc định)
        tinhVaCapNhatXepHang(); 
        renderMatchesView(); 
        renderFinals();
        renderFinalResults();
        renderOverview();
        startAutoSave();

    } catch (error) {
        updateStatus('configStatus', 'danger', `Lỗi tải trạng thái giải đấu: ${error.message}. Vui lòng kiểm tra lại Token/Repo.`);
        console.error("Lỗi khi tải trạng thái giải đấu từ GitHub:", error);
    }
}

/**
 * Lưu trạng thái giải đấu (state.json) lên GitHub.
 * @param {boolean} force - Bắt buộc lưu ngay cả khi stateChanged là false.
 */
async function saveToGitHub(force = false) {
    // Bỏ qua nếu không có thay đổi và không ép buộc lưu
    if (!stateChanged && !force) return;
    
    // **CHECKPOINT:** Tính lại bảng xếp hạng trước khi lưu (đảm bảo dữ liệu ranking là mới nhất)
    tinhVaCapNhatXepHang();

    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) {
        console.warn("Không thể tự động lưu: Thiếu cấu hình GitHub.");
        document.getElementById('autoState').className = 'text-warning';
        document.getElementById('autoState').textContent = 'Tạm dừng (Thiếu Config)';
        return;
    }

    document.getElementById('autoState').className = 'text-info';
    document.getElementById('autoState').textContent = 'Đang lưu...';
    if (force) {
         updateStatus('configStatus', 'info', 'Đang cập nhật dữ liệu lên GitHub...');
    }


    const apiUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}/contents/${cfg.folder}/${cfg.file}`;
    
    // Chỉ lưu các trường cần thiết, bao gồm cả bảng xếp hạng (tableA, tableB)
    const stateToSave = {
        mixedTeams: state.mixedTeams,
        maleTeams: state.maleTeams,
        matchesA: state.matchesA,
        matchesB: state.matchesB,
        courts: state.courts,
        semifinals: state.semifinals,
        final: state.final,
        // **BẢNG XẾP HẠNG VÒNG BẢNG ĐÃ TÍNH TOÁN**
        tableA: state.tableA,
        tableB: state.tableB 
    };
    const content = b64EncodeUnicode(JSON.stringify(stateToSave));
    
    try {
        // Luôn fetch SHA mới nhất trước khi cố gắng lưu
        const result = await fetchFileSha(cfg, cfg.file); // Lấy SHA của state.json
        const sha = result.sha; 
        
        const payload = {
            message: `${force ? '[Manual-save]' : '[Auto-save]'} Cập nhật trạng thái giải đấu TKD lúc ${new Date().toLocaleString('vi-VN')}`,
            content: content
        };
        
        // Thêm SHA để cập nhật, nếu không có SHA sẽ tạo mới (vì fetchFileSha đã cập nhật currentSha)
        if (sha) {
             payload.sha = sha;
        }

        const response = await fetch(apiUrl, {
            method: 'PUT',
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Content-Type': 'application/json',
                'Accept': 'application/vnd.github.v3+json'
            },
            body: JSON.stringify(payload)
        });

        if (response.ok) {
            const data = await response.json();
            currentSha = data.content.sha;
            stateChanged = false;
            document.getElementById('lastSaved').textContent = `Lần lưu: ${new Date().toLocaleTimeString('vi-VN')}`;
            document.getElementById('autoState').className = 'text-success';
            document.getElementById('autoState').textContent = 'Đã Lưu';
            if (force) {
                 updateStatus('configStatus', 'success', `Cập nhật dữ liệu lên GitHub thành công lúc ${new Date().toLocaleTimeString('vi-VN')}.`);
            }
        } else {
            // Xử lý lỗi 409 Conflict hoặc lỗi khác
             const errorData = await response.json();
            // Xử lý lỗi 409 Conflict
            if (response.status === 409) {
                console.warn("Lỗi 409 Conflict: Dữ liệu đã thay đổi trên GitHub. Đang cố gắng lấy SHA mới.");
                
                await fetchFileSha(cfg, cfg.file); // Lấy lại SHA mới
                
                document.getElementById('autoState').className = 'text-warning';
                document.getElementById('autoState').textContent = 'Conflict. Sẽ thử lưu lại sau 30s.';
                if (force) {
                     updateStatus('configStatus', 'warning', `Lỗi Conflict (Dữ liệu đã thay đổi trên GitHub). Vui lòng thử lại sau 30s.`);
                }
            } else {
                throw new Error(`Lỗi HTTP: ${response.status} - ${errorData.message || response.statusText}`);
            }
        }
    } catch (error) {
        console.error("Lỗi khi lưu lên GitHub:", error);
        document.getElementById('autoState').className = 'text-danger';
        document.getElementById('autoState').textContent = 'Lỗi Lưu';
        if (force) {
             updateStatus('configStatus', 'danger', `Lỗi cập nhật lên GitHub: ${error.message}.`);
        }
    }
}

/**
 * Bắt đầu cơ chế tự động lưu sau mỗi 30 giây.
 */
function startAutoSave() {
    stopAutoSave(); // Đảm bảo không có interval nào đang chạy
    
    // Chỉ khởi động auto-save nếu có đủ config
    if (state.config.owner && state.config.repo && state.config.token) {
        document.getElementById('autoState').className = 'text-info';
        document.getElementById('autoState').textContent = 'Hoạt động';
        autoSaveInterval = setInterval(() => {
            saveToGitHub(false); // Lưu không bắt buộc
        }, 30000); // 30 giây
    } else {
        document.getElementById('autoState').className = 'text-danger';
        document.getElementById('autoState').textContent = 'Tắt (Thiếu Config)';
    }
}

/**
 * Dừng cơ chế tự động lưu.
 */
function stopAutoSave() {
    if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
        autoSaveInterval = null;
    }
}


/**
 * Kiểm tra kết nối và Tải dữ liệu
 */
async function checkConnection() {
    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) {
        updateStatus('configStatus', 'warning', 'Vui lòng nhập đầy đủ Owner, Repo và Token.');
        return;
    }

    try {
        updateStatus('configStatus', 'info', 'Đang kiểm tra kết nối tới kho lưu trữ...');
        
        const repoCheckUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}`;
        const repoResponse = await fetch(repoCheckUrl, {
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });

        if (!repoResponse.ok) {
            const errorData = await repoResponse.json();
            throw new Error(`Lỗi truy cập kho lưu trữ. Mã: ${repoResponse.status}. ${errorData.message || ''} (Kiểm tra Token/Repo/Owner)`);
        }
        
        updateStatus('configStatus', 'success', '✅ Kết nối GitHub thành công! Đang tiến hành tải dữ liệu...');
        await loadFromGitHub();

    } catch (error) {
        updateStatus('configStatus', 'danger', `❌ Kiểm tra kết nối thất bại: ${error.message}.`);
        console.error("Lỗi kiểm tra kết nối:", error);
    }
}

// --- Local Storage Configuration Functions ---

/**
 * Lưu cấu hình GitHub vào Local Storage.
 */
function saveConfig() {
    const owner = document.getElementById('cfgOwner').value.trim();
    const repo = document.getElementById('cfgRepo').value.trim();
    const token = document.getElementById('cfgToken').value.trim();
    const folder = document.getElementById('cfgFolder').value.trim();
    const file = document.getElementById('cfgFile').value.trim();
    
    state.config.owner = owner;
    state.config.repo = repo;
    state.config.token = token;
    state.config.folder = folder;
    state.config.file = file;

    // Lưu config vào localStorage (Không lưu Token)
    const configToSave = { ...state.config, token: '' };
    localStorage.setItem('tkd_app_config', JSON.stringify(configToSave));
    
    // Lưu token riêng (để tránh hiển thị trong UI sau khi load)
    if (token) {
        localStorage.setItem('tkd_pat_token', token);
    }
    
    // Cập nhật lại UI sau khi save (nếu đang ở tab config)
    if (document.getElementById('config').classList.contains('active')) {
         updateStatus('configStatus', 'success', 'Đã lưu cấu hình GitHub vào Local.');
    }
    
    // Khởi động lại auto-save
    startAutoSave();
}

/**
 * Tải cấu hình GitHub từ Local Storage.
 */
function loadConfig() {
    const storedConfig = localStorage.getItem('tkd_app_config');
    const storedToken = localStorage.getItem('tkd_pat_token');

    if (storedConfig) {
        const loadedConfig = JSON.parse(storedConfig);
        // Gán lại các giá trị đã lưu
        state.config = { ...state.config, ...loadedConfig };
    }
    
    if (storedToken) {
        state.config.token = storedToken;
    }
    
    // Cập nhật UI
    document.getElementById('cfgOwner').value = state.config.owner;
    document.getElementById('cfgRepo').value = state.config.repo;
    document.getElementById('cfgFolder').value = state.config.folder;
    document.getElementById('cfgFile').value = state.config.file;
    document.getElementById('cfgToken').value = state.config.token;
    
    const select = document.getElementById('preferredCourtType');
    if (select) {
        select.value = state.config.preferredCourtType || 'mixed';
    }
}

// --- Match and Ranking Core Logic ---

/**
 * Cập nhật điểm số của một trận đấu.
 */
function updateScore(group, index) {
    const match = group === 'A' ? state.matchesA[index] : state.matchesB[index];
    const scoreA = document.getElementById(`score-${group}-${index}-A`).value;
    const scoreB = document.getElementById(`score-${group}-${index}-B`).value;
    
    // Chỉ lấy giá trị hợp lệ (số nguyên >= 0)
    const newScoreA = scoreA === '' ? null : parseInt(scoreA, 10);
    const newScoreB = scoreB === '' ? null : parseInt(scoreB, 10);

    // Xác định thắng thua
    if (newScoreA !== null && newScoreB !== null) {
        if (newScoreA >= 11 && newScoreA > newScoreB + 1) {
            match.winner = match.teamA;
            match.loser = match.teamB;
        } else if (newScoreB >= 11 && newScoreB > newScoreA + 1) {
            match.winner = match.teamB;
            match.loser = match.teamA;
        } else {
             // Chưa kết thúc hoặc không hợp lệ theo luật (chưa đến 11, hoặc cách biệt 1 điểm)
            match.winner = null;
            match.loser = null;
        }
        
        match.scoreA = newScoreA;
        match.scoreB = newScoreB;
    } else {
        match.scoreA = newScoreA;
        match.scoreB = newScoreB;
        match.winner = null;
        match.loser = null;
    }
    
    stateChanged = true;
    
    // Tái tính và cập nhật
    tinhVaCapNhatXepHang();
    renderMatchesView(); // Để cập nhật màu sắc đội thắng/thua ngay lập tức
    renderFinals(); // Cập nhật đội vào bán kết nếu đủ
    renderOverview(); // Cập nhật overview
}

/**
 * Tính toán và cập nhật bảng xếp hạng Vòng Bảng.
 */
function tinhVaCapNhatXepHang() {
    state.tableA = tinhXepHang(state.mixedTeams, state.matchesA, 'A');
    state.tableB = tinhXepHang(state.maleTeams, state.matchesB, 'B');
    
    renderRankingTables();
    
    // Tự động lên lịch bán kết sau khi có xếp hạng
    capNhatDoiVaoVongChungKet(state.tableA, state.tableB);
}

/**
 * Hàm core tính toán xếp hạng cho một bảng đấu.
 * @param {Array} teams - Danh sách đội
 * @param {Array} matches - Danh sách trận đấu
 * @param {string} group - Tên bảng (A/B)
 */
function tinhXepHang(teams, matches, group) {
    // 1. Khởi tạo thống kê
    const stats = {};
    teams.forEach(team => {
        stats[team.name] = { 
            team: team.name, 
            P: 0, // Played
            W: 0, // Win
            L: 0, // Loss
            GF: 0, // Goals For (Điểm thắng)
            GA: 0, // Goals Against (Điểm thua)
            GD: 0, // Goal Difference (Hiệu số)
            Pts: 0 // Points (Điểm)
        };
    });

    // 2. Cập nhật thống kê từ kết quả trận đấu
    matches.forEach(match => {
        if (match.winner) {
            const statA = stats[match.teamA];
            const statB = stats[match.teamB];

            // Cập nhật số trận
            statA.P += 1;
            statB.P += 1;
            
            // Cập nhật điểm thắng/thua
            const scoreA = match.scoreA || 0;
            const scoreB = match.scoreB || 0;
            
            statA.GF += scoreA;
            statA.GA += scoreB;
            statB.GF += scoreB;
            statB.GA += scoreA;
            
            // Cập nhật thắng/thua/điểm
            if (match.winner === match.teamA) {
                statA.W += 1;
                statA.Pts += 3; // Thắng được 3 điểm
                statB.L += 1;
            } else if (match.winner === match.teamB) {
                statB.W += 1;
                statB.Pts += 3;
                statA.L += 1;
            } 
            // Không có hòa trong pickleball, nếu không có winner thì trận đấu chưa hoàn thành hoặc điểm không hợp lệ
        } else if (match.scoreA !== null && match.scoreB !== null) {
            // Trận đấu chưa hoàn thành (chưa đủ 11 điểm và cách biệt 2), vẫn tính P, GF, GA
            const statA = stats[match.teamA];
            const statB = stats[match.teamB];
            statA.P += 1;
            statB.P += 1;

            const scoreA = match.scoreA || 0;
            const scoreB = match.scoreB || 0;
            
            statA.GF += scoreA;
            statA.GA += scoreB;
            statB.GF += scoreB;
            statB.GA += scoreA;
        }
    });

    // 3. Tính hiệu số
    Object.values(stats).forEach(stat => {
        stat.GD = stat.GF - stat.GA;
    });

    // 4. Sắp xếp (Tie-breaker logic)
    const ranking = Object.values(stats).filter(stat => stat.P > 0);
    
    ranking.sort((a, b) => {
        // 1. Điểm số (Pts)
        if (b.Pts !== a.Pts) return b.Pts - a.Pts;

        // 2. Đối đầu (Head-to-head) - Chỉ áp dụng nếu chỉ có 2 đội hòa điểm
        const h2h = checkHeadToHead(a.team, b.team, matches);
        if (h2h !== 0) return h2h;

        // 3. Hiệu số bàn thắng (GD)
        if (b.GD !== a.GD) return b.GD - a.GD;

        // 4. Tổng điểm thắng (GF)
        return b.GF - a.GF;
    });
    
    // Gán lại Rank
    ranking.forEach((stat, index) => {
        stat.Rank = index + 1;
    });

    // Trả về cả đội có chơi và đội chưa chơi (cho UI)
    const allTeams = Object.values(stats);
    allTeams.sort((a, b) => {
        // Ưu tiên đội đã chơi lên trên
        if (a.P > 0 && b.P === 0) return -1;
        if (a.P === 0 && b.P > 0) return 1;
        
        // Sau đó áp dụng xếp hạng cho đội đã chơi
        const rankA = ranking.find(r => r.team === a.team);
        const rankB = ranking.find(r => r.team === b.team);
        
        if (rankA && rankB) {
            return rankA.Rank - rankB.Rank;
        }
        
        return a.team.localeCompare(b.team); // Sắp xếp theo tên nếu chưa chơi
    });

    return allTeams;
}

/**
 * Kiểm tra kết quả đối đầu giữa hai đội.
 * @param {string} teamA - Tên đội A
 * @param {string} teamB - Tên đội B
 * @param {Array} matches - Danh sách trận đấu
 * @returns {number} - 1 nếu B thắng A (B xếp trên), -1 nếu A thắng B (A xếp trên), 0 nếu hòa hoặc chưa đấu
 */
function checkHeadToHead(teamA, teamB, matches) {
    let winsA = 0;
    let winsB = 0;

    matches.forEach(match => {
        if (match.winner) {
            if (match.teamA === teamA && match.teamB === teamB) {
                if (match.winner === teamA) winsA++;
                else winsB++;
            } else if (match.teamA === teamB && match.teamB === teamA) {
                if (match.winner === teamB) winsB++;
                else winsA++;
            }
        }
    });

    if (winsA > winsB) return -1; // A thắng B
    if (winsB > winsA) return 1;  // B thắng A
    return 0; // Hòa hoặc chưa đấu
}

// ===============================================
// START V28 FIX: Logic Tự động điền đội Bán kết 100%
// ===============================================

/**
 * Tính số trận đấu cần thiết cho vòng tròn 1 lượt (N * (N-1) / 2)
 * @param {number} N - Số đội
 * @returns {number}
 */
function requiredMatches(N) {
    if (N < 2) return 0;
    return N * (N - 1) / 2;
}

/**
 * Cập nhật đội Nhất/Nhì Vòng Bảng vào Vòng Bán kết.
 */
function capNhatDoiVaoVongChungKet(tableA, tableB) {
    // Chỉ cập nhật nếu Vòng Chung kết chưa có kết quả
    const finalsCompleted = state.semifinals.some(sf => sf.winner !== null) || state.final.winner !== null;
    if (finalsCompleted) return;
    
    // V28 Logic: KIỂM TRA TẤT CẢ TRẬN VÒNG BẢNG ĐÃ HOÀN THÀNH
    const requiredA = requiredMatches(state.mixedTeams.length);
    const completedA = state.matchesA.filter(m => m.winner).length;
    const isGroupACompleted = completedA >= requiredA;

    const requiredB = requiredMatches(state.maleTeams.length);
    const completedB = state.matchesB.filter(m => m.winner).length;
    const isGroupBCompleted = completedB >= requiredB;
    
    const team1A = tableA.find(t => t.Rank === 1);
    const team2A = tableA.find(t => t.Rank === 2);
    const team1B = tableB.find(t => t.Rank === 1);
    const team2B = tableB.find(t => t.Rank === 2);
    
    let changed = false;

    // Cập nhật Bán kết 1 (SF1: Nhất A vs Nhì B)
    if (state.semifinals[0].scoreA === null && state.semifinals[0].scoreB === null) {
        // V28 Logic: Chỉ điền tên đội nếu bảng đấu tương ứng đã hoàn thành
        const newTeamA = (isGroupACompleted && team1A) ? team1A.team : 'Nhất A'; 
        const newTeamB = (isGroupBCompleted && team2B) ? team2B.team : 'Nhì B';
        
        if (state.semifinals[0].teamA !== newTeamA || state.semifinals[0].teamB !== newTeamB) {
            state.semifinals[0].teamA = newTeamA;
            state.semifinals[0].teamB = newTeamB;
            changed = true;
        }
    }

    // Cập nhật Bán kết 2 (SF2: Nhất B vs Nhì A)
    if (state.semifinals[1].scoreA === null && state.semifinals[1].scoreB === null) {
        // V28 Logic: Chỉ điền tên đội nếu bảng đấu tương ứng đã hoàn thành
        const newTeamA = (isGroupBCompleted && team1B) ? team1B.team : 'Nhất B';
        const newTeamB = (isGroupACompleted && team2A) ? team2A.team : 'Nhì A';
        
        if (state.semifinals[1].teamA !== newTeamA || state.semifinals[1].teamB !== newTeamB) {
            state.semifinals[1].teamA = newTeamA;
            state.semifinals[1].teamB = newTeamB;
            changed = true;
        }
    }

    // Cập nhật Chung kết (F: Thắng SF1 vs Thắng SF2)
    if (state.final.scoreA === null && state.final.scoreB === null) {
        const winnerSF1 = state.semifinals[0].winner || 'Thắng SF1';
        const winnerSF2 = state.semifinals[1].winner || 'Thắng SF2';
        
        if (state.final.teamA !== winnerSF1 || state.final.teamB !== winnerSF2) {
            state.final.teamA = winnerSF1;
            state.final.teamB = winnerSF2;
            changed = true;
        }
    }
    
    if (changed) {
        stateChanged = true;
        // renderFinals() sẽ được gọi sau hàm gọi capNhatDoiVaoVongChungKet
    }
}
// ===============================================
// END V28 FIX: Logic Tự động điền đội Bán kết 100%
// ===============================================


// --- Rendering Functions ---

/**
 * Hiển thị bảng xếp hạng Vòng Bảng.
 */
function renderRankingTables() {
    const container = document.getElementById('rankingTables');
    let html = '';

    const renderTable = (table, title) => {
        if (table.length === 0) return '';
        
        let tableHtml = `<div class="ranking-table"><h5>${title}</h5><div class='table-responsive'><table class='table table-bordered table-sm'>
            <thead class="table-primary">
                <tr><th>#</th><th>Đội</th><th>P</th><th>W</th><th>L</th><th>HS</th><th>Điểm</th></tr>
            </thead>
            <tbody>`;
        
        table.forEach((stat, index) => {
            const rank = stat.Rank || '-';
            const rowClass = (stat.Rank === 1 || stat.Rank === 2) && stat.P > 0 ? 'table-success' : '';
            tableHtml += `<tr class="${rowClass}">
                <td>${rank}</td>
                <td class="text-truncate" style="max-width:150px;">${stat.team}</td>
                <td>${stat.P}</td>
                <td>${stat.W}</td>
                <td>${stat.L}</td>
                <td>${stat.GD}</td>
                <td>${stat.Pts}</td>
            </tr>`;
        });
        
        tableHtml += `</tbody></table></div></div>`;
        return tableHtml;
    };

    html += renderTable(state.tableA, 'Bảng A (Nam - Nữ)');
    html += renderTable(state.tableB, 'Bảng B (Nam)');

    container.innerHTML = html || `<p class="text-muted">Chưa có kết quả hoặc lịch thi đấu.</p>`;
}

/**
 * Hiển thị kết quả Vòng Chung cuộc.
 */
function renderFinalResults() {
    const tableA = state.tableA;
    const tableB = state.tableB;
    const final = state.final;
    const sf1 = state.semifinals[0];
    const sf2 = state.semifinals[1];

    let champion = 'Đang chờ kết quả...';
    let runnerUp = 'Đang chờ kết quả...';
    let thirdPlaces = ['Đang chờ kết quả...'];

    if (final.winner) {
        champion = `<span class="badge bg-success">${final.winner}</span>`;
        runnerUp = `<span class="badge bg-warning">${final.runnerUp}</span>`;
        
        // Hạng Ba: Đội thua ở Bán kết 1 và Bán kết 2
        let loserSF1 = sf1.loser || 'Đội thua SF1';
        let loserSF2 = sf2.loser || 'Đội thua SF2';
        
        // Chỉ hiện tên đội nếu trận bán kết đã có kết quả
        if (sf1.winner && sf2.winner) {
             thirdPlaces = [`<span class="badge bg-info">${loserSF1}</span>`, `<span class="badge bg-info">${loserSF2}</span>`];
        } else {
             thirdPlaces = ['Đang chờ kết quả...'];
        }
    } else if (sf1.winner && sf2.winner) {
        // Chung kết chưa xong
        champion = 'Đang chờ kết quả Chung kết...';
        runnerUp = 'Đang chờ kết quả Chung kết...';
        thirdPlaces = [`<span class="badge bg-info">${sf1.loser}</span>`, `<span class="badge bg-info">${sf2.loser}</span>`];
    }

    document.getElementById('champion').innerHTML = `Vô địch: ${champion}`;
    document.getElementById('runnerUp').innerHTML = `Á quân: ${runnerUp}`;
    document.getElementById('thirdPlace').innerHTML = `Hạng Ba Đồng Hạng: ${thirdPlaces.join(' và ')}`;
}

/**
 * Hiển thị Vòng Chung Kết (Bán kết & Chung kết).
 */
function renderFinals() {
    const sfContainer = document.getElementById('semifinalMatches');
    const fContainer = document.getElementById('finalMatch');
    
    // --- Render Bán kết ---
    let sfHtml = `<div class='table-responsive'><table class='table table-striped table-bordered table-sm'>
        <thead class="table-dark"><tr><th>Trận</th><th>Giờ/Sân</th><th>Đội A</th><th>Đội B</th><th colspan="2">Điểm</th></tr></thead>
        <tbody>`;
        
    state.semifinals.forEach((match, index) => {
        const teamA_Class = match.winner === match.teamA ? 'winner' : (match.loser === match.teamA ? 'loser' : '');
        const teamB_Class = match.winner === match.teamB ? 'winner' : (match.loser === match.teamB ? 'loser' : '');
        const matchRowClass = match.winner ? 'table-success' : (match.teamA.includes('Nhất') ? 'table-light' : ''); // Nhất A/B chưa đá
        
        sfHtml += `
            <tr class="${matchRowClass}">
                <td>${match.id}</td>
                <td>${match.time || '-'} / ${match.court || '-'}</td>
                <td class="text-truncate ${teamA_Class}">${match.teamA}</td>
                <td class="text-truncate ${teamB_Class}">${match.teamB}</td>
                <td class="match-score-cell">
                    <input type="number" id="sf-score-${index}-A" 
                        value="${match.scoreA !== null ? match.scoreA : ''}" 
                        min="0" onchange="updateFinalScore('SF', ${index})">
                </td>
                <td class="match-score-cell">
                    <input type="number" id="sf-score-${index}-B" 
                        value="${match.scoreB !== null ? match.scoreB : ''}" 
                        min="0" onchange="updateFinalScore('SF', ${index})">
                </td>
            </tr>
        `;
    });
    
    sfHtml += `</tbody></table></div>`;
    sfContainer.innerHTML = sfHtml;

    // --- Render Chung kết ---
    const match = state.final;
    const teamA_Class = match.winner === match.teamA ? 'winner' : (match.runnerUp === match.teamA ? 'loser' : '');
    const teamB_Class = match.winner === match.teamB ? 'winner' : (match.runnerUp === match.teamB ? 'loser' : '');
    const matchRowClass = match.winner ? 'table-danger' : (match.teamA.includes('Thắng') ? 'table-light' : '');
    
    let fHtml = `<div class='table-responsive'><table class='table table-striped table-bordered table-sm'>
        <thead class="table-dark"><tr><th>Trận</th><th>Giờ/Sân</th><th>Đội A</th><th>Đội B</th><th colspan="2">Điểm</th></tr></thead>
        <tbody>
            <tr class="${matchRowClass}">
                <td>${match.id}</td>
                <td>${match.time || '-'} / ${match.court || '-'}</td>
                <td class="text-truncate ${teamA_Class}">${match.teamA}</td>
                <td class="text-truncate ${teamB_Class}">${match.teamB}</td>
                <td class="match-score-cell">
                    <input type="number" id="sf-score-F-A" 
                        value="${match.scoreA !== null ? match.scoreA : ''}" 
                        min="0" onchange="updateFinalScore('F', 0)">
                </td>
                <td class="match-score-cell">
                    <input type="number" id="sf-score-F-B" 
                        value="${match.scoreB !== null ? match.scoreB : ''}" 
                        min="0" onchange="updateFinalScore('F', 0)">
                </td>
            </tr>
        </tbody>
        </table></div>`;
        
    fContainer.innerHTML = fHtml;
    
    // Cập nhật kết quả chung cuộc ngay
    renderFinalResults();
}

/**
 * Cập nhật điểm Vòng Chung Kết (SF1, SF2, F).
 */
function updateFinalScore(matchType, index) {
    let match;
    let scoreA_id;
    let scoreB_id;
    
    if (matchType === 'SF') {
        match = state.semifinals[index];
        scoreA_id = `sf-score-${index}-A`;
        scoreB_id = `sf-score-${index}-B`;
    } else { // 'F'
        match = state.final;
        scoreA_id = `sf-score-F-A`;
        scoreB_id = `sf-score-F-B`;
    }
    
    if (match.teamA.includes('Nhất') || match.teamA.includes('Thắng')) {
        alert("Chưa đủ đội vào Vòng Chung kết. Vui lòng hoàn thành Vòng Bảng/Bán kết trước.");
        document.getElementById(scoreA_id).value = match.scoreA !== null ? match.scoreA : '';
        document.getElementById(scoreB_id).value = match.scoreB !== null ? match.scoreB : '';
        return;
    }

    const scoreA = document.getElementById(scoreA_id).value;
    const scoreB = document.getElementById(scoreB_id).value;
    
    const newScoreA = scoreA === '' ? null : parseInt(scoreA, 10);
    const newScoreB = scoreB === '' ? null : parseInt(scoreB, 10);
    
    // Logic thắng thua (giống updateScore)
    let winner = null;
    let loser = null;

    if (newScoreA !== null && newScoreB !== null) {
        if (newScoreA >= 11 && newScoreA > newScoreB + 1) {
            winner = match.teamA;
            loser = match.teamB;
        } else if (newScoreB >= 11 && newScoreB > newScoreA + 1) {
            winner = match.teamB;
            loser = match.teamA;
        }
    }
    
    match.scoreA = newScoreA;
    match.scoreB = newScoreB;
    match.winner = winner;
    
    if (matchType === 'SF') {
        match.loser = loser;
    } else { // 'F'
        match.runnerUp = loser;
    }

    stateChanged = true;
    
    capNhatDoiVaoVongChungKet(state.tableA, state.tableB);
    renderFinals();
    renderOverview();
}


/**
 * Hiển thị lịch thi đấu theo chế độ xem (Bảng đấu hoặc Sân).
 */
function renderMatchesView() {
    const viewMode = document.getElementById('viewMode').value;
    const container = document.getElementById('matchesViewContent');
    
    // 1. Lấy dữ liệu theo chế độ xem
    let dataA = state.matchesA;
    let dataB = state.matchesB;
    
    if (viewMode === 'court') {
        // Gom nhóm theo sân và sắp xếp theo thời gian
        const allMatches = [...state.matchesA, ...state.matchesB];
        const groupedByCourt = allMatches.reduce((acc, match) => {
            if (!acc[match.court]) {
                acc[match.court] = [];
            }
            acc[match.court].push(match);
            return acc;
        }, {});
        
        // Sắp xếp các trận đấu trong mỗi sân theo thời gian
        Object.values(groupedByCourt).forEach(matches => {
            matches.sort((a, b) => a.time.localeCompare(b.time));
        });
        
        // Sắp xếp các sân theo tên
        const sortedCourts = Object.keys(groupedByCourt).sort((a, b) => a.localeCompare(b));
        
        // Tạo HTML theo sân
        let courtHtml = '';
        sortedCourts.forEach(courtName => {
            courtHtml += `<h6 class="mt-4">Sân: ${courtName}</h6>`;
            courtHtml += renderMatchesTable(groupedByCourt[courtName], courtName);
        });
        
        container.innerHTML = courtHtml || `<p class="text-muted">Chưa có lịch thi đấu.</p>`;

    } else { // viewMode === 'table'
        
        let tableHtml = `<h6 class="mt-4">Bảng A (Nam - Nữ)</h6>`;
        tableHtml += renderMatchesTable(dataA, 'A');
        
        tableHtml += `<h6 class="mt-4">Bảng B (Nam)</h6>`;
        tableHtml += renderMatchesTable(dataB, 'B');
        
        container.innerHTML = tableHtml;
    }
}

/**
 * Tạo bảng HTML cho một nhóm trận đấu.
 */
function renderMatchesTable(matches, groupOrCourt) {
    if (matches.length === 0) return `<div class="alert alert-light">Chưa có trận đấu nào.</div>`;
    
    let tableHtml = `<div class='table-responsive'><table class='table table-striped table-bordered table-sm'>
        <thead class="table-primary">
            <tr>
                <th>Giờ</th>
                <th>Sân</th>
                <th>Đội A</th>
                <th>Đội B</th>
                <th colspan="2">Điểm</th>
            </tr>
        </thead>
        <tbody>`;
        
    matches.forEach(match => {
        // Tìm index trong state để updateScore
        let group, index;
        if (state.matchesA.includes(match)) {
             group = 'A';
             index = state.matchesA.indexOf(match);
        } else if (state.matchesB.includes(match)) {
             group = 'B';
             index = state.matchesB.indexOf(match);
        } else {
            // Không tìm thấy trong state, chỉ hiển thị (chỉ xảy ra khi viewMode=court)
            group = match.bang;
            index = -1; 
        }

        const teamA_Class = match.winner === match.teamA ? 'winner' : (match.loser === match.teamA ? 'loser' : '');
        const teamB_Class = match.winner === match.teamB ? 'winner' : (match.loser === match.teamB ? 'loser' : '');
        const matchRowClass = match.winner ? 'table-success' : '';
        
        tableHtml += `
            <tr class="${matchRowClass}">
                <td>${match.time || '-'}</td>
                <td>${match.court || '-'}</td>
                <td class="text-truncate ${teamA_Class}">${match.teamA}</td>
                <td class="text-truncate ${teamB_Class}">${match.teamB}</td>
                <td class="match-score-cell">
                    ${index !== -1 ? `
                    <input type="number" id="score-${group}-${index}-A" 
                        value="${match.scoreA !== null ? match.scoreA : ''}" 
                        min="0" onchange="updateScore('${group}', ${index})">` : (match.scoreA !== null ? match.scoreA : '')}
                </td>
                <td class="match-score-cell">
                    ${index !== -1 ? `
                    <input type="number" id="score-${group}-${index}-B" 
                        value="${match.scoreB !== null ? match.scoreB : ''}" 
                        min="0" onchange="updateScore('${group}', ${index})">` : (match.scoreB !== null ? match.scoreB : '')}
                </td>
            </tr>
        `;
    });
    
    tableHtml += `</tbody></table></div>`;
    return tableHtml;
}


/**
 * Hiển thị tổng quan các đội và trận đấu còn lại.
 */
function renderOverview() {
    const container = document.getElementById('overviewContent');
    const totalTeams = state.mixedTeams.length + state.maleTeams.length;
    const allMatches = [...state.matchesA, ...state.matchesB];
    const matchesPlayed = allMatches.filter(m => m.winner).length;
    const totalMatches = allMatches.length;
    const matchesRemaining = totalMatches - matchesPlayed;
    
    const finalMatches = [...state.semifinals, state.final];
    const finalMatchesPlayed = finalMatches.filter(m => m.winner).length;
    const finalMatchesRemaining = finalMatches.length - finalMatchesPlayed;
    
    let html = `
        <div class="row g-3">
            <div class="col-md-4">
                <div class="card shadow-sm">
                    <div class="card-body">
                        <h5 class="card-title text-primary">Đội Tham Gia</h5>
                        <p class="card-text fs-4">${totalTeams}</p>
                        <ul class="list-unstyled small">
                            <li>Bảng A (Nam - Nữ): ${state.mixedTeams.length} đội</li>
                            <li>Bảng B (Nam): ${state.maleTeams.length} đội</li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="card shadow-sm">
                    <div class="card-body">
                        <h5 class="card-title text-success">Vòng Bảng</h5>
                        <p class="card-text fs-4">${matchesPlayed}/${totalMatches} trận</p>
                        <ul class="list-unstyled small">
                            <li>**Đã hoàn thành:** ${matchesPlayed} trận</li>
                            <li>**Còn lại:** ${matchesRemaining} trận</li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="card shadow-sm">
                    <div class="card-body">
                        <h5 class="card-title text-danger">Vòng Chung Kết</h5>
                        <p class="card-text fs-4">${finalMatchesPlayed}/3 trận</p>
                        <ul class="list-unstyled small">
                            <li>**Đã hoàn thành:** ${finalMatchesPlayed} trận</li>
                            <li>**Còn lại:** ${finalMatchesRemaining} trận (SF1, SF2, F)</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        
        <h5 class="mt-4">Trận Đấu Sắp Tới (Còn Lại ${matchesRemaining} trận Vòng Bảng)</h5>
        `;
        
        const remainingMatches = allMatches
            .filter(m => !m.winner)
            .sort((a, b) => {
                // Sắp xếp theo giờ, sau đó theo sân
                if (a.time && b.time && a.time.localeCompare(b.time) !== 0) {
                    return a.time.localeCompare(b.time);
                }
                return a.court.localeCompare(b.court);
            });
            
        if (remainingMatches.length > 0) {
            html += `<div class='table-responsive'><table class='table table-striped table-sm mt-3'>
                <thead><tr><th>Giờ</th><th>Sân</th><th>Bảng</th><th>Đội A</th><th>Đội B</th></tr></thead>
                <tbody>`;
            
            remainingMatches.slice(0, 10).forEach(match => { // Chỉ hiển thị 10 trận đầu
                html += `<tr>
                    <td>${match.time}</td>
                    <td>${match.court}</td>
                    <td>${match.bang}</td>
                    <td>${match.teamA}</td>
                    <td>${match.teamB}</td>
                </tr>`;
            });
            html += `</tbody></table></div>`;
            if (remainingMatches.length > 10) {
                html += `<p class="small text-muted">Và ${remainingMatches.length - 10} trận đấu khác...</p>`;
            }
        } else {
            html += `<div class="alert alert-info mt-3">✅ Vòng Bảng đã hoàn thành! Vui lòng kiểm tra tab Vòng Chung Kết.</div>`;
        }
    
    container.innerHTML = html;
}

// --- Configuration Tab Functions (đã có ở trên) ---

function updatePreferredCourtType() {
    const select = document.getElementById('preferredCourtType');
    if (select) {
        state.config.preferredCourtType = select.value;
        saveConfig();
        updateStatus('configStatus', 'success', `Đã cập nhật ưu tiên sân thành: ${select.options[select.selectedIndex].text}.`);
    }
}

function exportDataToJson() {
    tinhVaCapNhatXepHang();
    const stateToSave = {
        mixedTeams: state.mixedTeams,
        maleTeams: state.maleTeams,
        matchesA: state.matchesA,
        matchesB: state.matchesB,
        courts: state.courts,
        semifinals: state.semifinals,
        final: state.final,
        tableA: state.tableA,
        tableB: state.tableB
    };
    const jsonString = JSON.stringify(stateToSave, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `data_tkd_export_${new Date().toISOString().slice(0, 10)}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    showModal('Export Dữ liệu', 'Đã xuất toàn bộ dữ liệu giải đấu hiện tại ra file JSON.');
}

function renderConfig() {
    renderCourtList();
    document.getElementById('courtConfigStatus').innerHTML = '';
    document.getElementById('clearScoreStatus').innerHTML = '';

    const select = document.getElementById('preferredCourtType');
    if (select) {
        select.value = state.config.preferredCourtType || 'mixed';
    }
}

function renderCourtList() {
    const container = document.getElementById('courtListContainer');
    if (!container) return;
    
    if (state.courts.length === 0) {
        container.innerHTML = `<div class="alert alert-warning">Chưa có sân nào được cấu hình.</div>`;
        return;
    }

    let html = `<div class='table-responsive'><table class='table table-striped table-sm'>
        <thead>
            <tr>
                <th>Tên Sân</th>
                <th>Giờ Bắt Đầu</th>
                <th>Thời Lượng Max (Phút)</th>
                <th>Phân Loại</th>
                <th class="text-center">Hành động</th>
            </tr>
        </thead>
        <tbody>`;
    
    state.courts.forEach((court, index) => {
        const type = court.isMixed ? 'Bảng A (Nam - Nữ)' : 'Bảng B (Nam)';
        const typeClass = court.isMixed ? 'badge bg-primary' : 'badge bg-info';
        html += `<tr>
            <td>${court.name}</td>
            <td>${court.startTime}</td>
            <td>${court.maxDurationMinutes}</td>
            <td><span class="${typeClass}">${type}</span></td>
            <td class="text-center">
                <button class="btn btn-sm btn-outline-secondary me-1" onclick="openCourtModal(${index})">Sửa</button>
                <button class="btn btn-sm btn-outline-danger" onclick="deleteCourt(${index})">Xóa</button>
            </td>
        </tr>`;
    });

    html += `</tbody></table></div>`;
    container.innerHTML = html;
}

function openCourtModal(index = null) {
    const modal = new bootstrap.Modal(document.getElementById('courtModal'));
    document.getElementById('courtFormStatus').innerHTML = '';
    document.getElementById('courtIndex').value = index !== null ? index : '';
    document.getElementById('courtModalLabel').textContent = index !== null ? 'Sửa Cấu hình Sân' : 'Thêm Sân Mới';

    if (index !== null) {
        const court = state.courts[index];
        document.getElementById('courtName').value = court.name || '';
        document.getElementById('courtStartTime').value = court.startTime || '14:00';
        document.getElementById('courtMaxDuration').value = court.maxDurationMinutes || 180;
        document.getElementById('courtIsMixed').checked = court.isMixed || false;
    } else {
        document.getElementById('courtName').value = '';
        document.getElementById('courtStartTime').value = '14:00';
        document.getElementById('courtMaxDuration').value = 180;
        document.getElementById('courtIsMixed').checked = true;
    }
    modal.show();
}

function saveCourtChanges() {
    const index = document.getElementById('courtIndex').value;
    const name = document.getElementById('courtName').value.trim();
    const startTime = document.getElementById('courtStartTime').value;
    const maxDurationMinutes = parseInt(document.getElementById('courtMaxDuration').value);
    const isMixed = document.getElementById('courtIsMixed').checked;
    
    if (!name || !startTime || isNaN(maxDurationMinutes) || maxDurationMinutes <= 0) {
        document.getElementById('courtFormStatus').innerHTML = '<div class="alert alert-danger">Vui lòng nhập đầy đủ thông tin hợp lệ.</div>';
        return;
    }

    const newCourt = { name, startTime, maxDurationMinutes, isMixed };

    if (index !== '') {
        state.courts[parseInt(index)] = newCourt;
        updateStatus('courtConfigStatus', 'success', `Đã cập nhật cấu hình sân ${name} thành công.`);
    } else {
        state.courts.push(newCourt);
        updateStatus('courtConfigStatus', 'success', `Đã thêm sân ${name} mới thành công.`);
    }
    
    stateChanged = true;
    saveConfig(); 
    renderCourtList();
    bootstrap.Modal.getInstance(document.getElementById('courtModal')).hide();
}

function deleteCourt(index) {
    if (confirm(`Bạn có chắc chắn muốn xóa sân "${state.courts[index].name}"? Hành động này không thể hoàn tác.`)) {
        const deletedName = state.courts[index].name;
        state.courts.splice(index, 1);
        stateChanged = true;
        saveConfig();
        renderCourtList();
        updateStatus('courtConfigStatus', 'success', `Đã xóa sân ${deletedName} thành công.`);
    }
}

function loadDefaultCourtConfig() {
    if (confirm('Bạn có chắc chắn muốn Tải lại cấu hình sân Mặc định? Mọi thay đổi hiện tại sẽ bị ghi đè.')) {
        state.courts = [
            { name: 'Sân 1', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, 
            { name: 'Sân 2', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, 
            { name: 'Sân 3', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, 
            { name: 'Sân 4', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, 
            { name: 'Sân 5', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }, 
            { name: 'Sân 6', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }, 
            { name: 'Sân 7', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }, 
            { name: 'Sân 8', startTime: '14:00', maxDurationMinutes: 180, isMixed: false } 
        ];
        stateChanged = true;
        saveConfig();
        renderCourtList();
        updateStatus('courtConfigStatus', 'success', 'Đã tải cấu hình sân mặc định thành công.');
    }
}

function clearAllSchedules() {
    if (confirm("⚠️ CẢNH BÁO: Bạn có chắc chắn muốn XÓA TOÀN BỘ LỊCH THI ĐẤU (cả kết quả, lịch, vòng chung kết)? Hành động này không thể hoàn tác.")) {
        state.matchesA = [];
        state.matchesB = [];
        state.tableA = [];
        state.tableB = [];
        
        // Reset Vòng Chung kết về mặc định (V26 Fix)
        state.semifinals = [ DEFAULT_SF1, DEFAULT_SF2 ];
        state.final = DEFAULT_FINAL;

        stateChanged = true;
        saveToGitHub();
        tinhVaCapNhatXepHang();
        renderMatchesView();
        renderFinals();
        renderOverview();
        showModal('Xóa thành công', 'Đã xóa toàn bộ lịch thi đấu và kết quả. Vui lòng tạo lịch mới.');
    }
}

/**
 * Xóa điểm số các trận đấu Vòng Bảng.
 * V26 FIX: Thêm logic reset Vòng Chung kết
 */
function clearGroupScores(group) {
    // Kiểm tra Vòng Chung kết chưa hoàn thành
    const finalsCompleted = state.semifinals.some(sf => sf.winner !== null) || state.final.winner !== null;
    
    if (finalsCompleted) {
        showModal('Lỗi Xóa Kết Quả', 'Không thể xóa kết quả Vòng Bảng. Vui lòng **Xóa toàn bộ lịch** (ở tab Cấu hình) nếu muốn reset Vòng Chung kết, hoặc xóa kết quả Vòng CK thủ công.');
        return;
    }
    
    const message = group === 'ALL' 
        ? "Bạn có chắc chắn muốn XÓA TOÀN BỘ kết quả Vòng Bảng (Bảng A & B)? Hành động này không thể hoàn tác."
        : `Bạn có chắc chắn muốn XÓA TOÀN BỘ kết quả của Bảng ${group}? Hành động này không thể hoàn tác.`;
    
    if (!confirm(message)) return;

    let clearedCount = 0;
    
    const matchesToClear = [];
    if (group === 'A' || group === 'ALL') matchesToClear.push(...state.matchesA);
    if (group === 'B' || group === 'ALL') matchesToClear.push(...state.matchesB);
    
    matchesToClear.forEach(match => {
        if (match.scoreA !== null || match.scoreB !== null) {
            match.scoreA = null;
            match.scoreB = null;
            match.winner = null;
            match.loser = null;
            clearedCount++;
        }
    });

    if (clearedCount > 0) {
        
        // ===============================================
        // START V26 FIX: Reset Vòng Chung Kết
        // ===============================================
        state.semifinals = [ DEFAULT_SF1, DEFAULT_SF2 ];
        state.final = DEFAULT_FINAL;
        // ===============================================
        // END V26 FIX: Reset Vòng Chung Kết
        // ===============================================
        
        tinhVaCapNhatXepHang();
        renderMatchesView();
        renderFinals(); // Cập nhật giao diện tab Chung kết
        renderOverview();
        
        stateChanged = true;
        saveToGitHub();
        updateStatus('clearScoreStatus', 'success', `Đã xóa ${clearedCount} kết quả trận đấu thành công. Vòng Chung Kết đã được Reset.`);
    } else {
        updateStatus('clearScoreStatus', 'info', `Không có kết quả nào của Bảng ${group} cần xóa.`);
    }
}

// --- Import/Export CSV Logic ---

function handleFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const csvText = e.target.result;
            const matches = parseCSV(csvText);
            
            state.matchesA = matches.filter(m => m.bang === 'A');
            state.matchesB = matches.filter(m => m.bang === 'B');
            
            // Xóa điểm vòng chung kết khi import lịch mới
            state.semifinals = [ DEFAULT_SF1, DEFAULT_SF2 ];
            state.final = DEFAULT_FINAL;

            stateChanged = true;
            tinhVaCapNhatXepHang();
            renderMatchesView();
            renderFinals();
            renderOverview();
            showModal('Import thành công', `Đã tải ${state.matchesA.length} trận Bảng A và ${state.matchesB.length} trận Bảng B.`);
        } catch (error) {
            showModal('Lỗi Import', `Đã xảy ra lỗi khi xử lý file: ${error.message}`);
            console.error(error);
        }
    };
    reader.readAsText(file);
}

function parseCSV(csvText) {
    const lines = csvText.trim().split('\n');
    if (lines.length < 2) throw new Error("File CSV không có dữ liệu.");
    
    const headers = lines[0].split(',').map(h => h.trim());
    const dataLines = lines.slice(1);
    
    if (!headers.includes('teamA') || !headers.includes('teamB')) {
        throw new Error("CSV thiếu cột bắt buộc (teamA, teamB).");
    }

    return dataLines.map(line => {
        const values = line.split(',');
        let match = {};
        headers.forEach((header, index) => {
            let value = values[index] ? values[index].trim() : '';
            if (header.startsWith('score')) {
                match[header] = value === '' ? null : parseInt(value, 10);
            } else {
                match[header] = value;
            }
        });
        
        // Ensure winner/loser are reset on import
        if (match.scoreA !== null && match.scoreB !== null) {
            if (match.scoreA >= 11 && match.scoreA > match.scoreB + 1) {
                match.winner = match.teamA;
                match.loser = match.teamB;
            } else if (match.scoreB >= 11 && match.scoreB > match.scoreA + 1) {
                match.winner = match.teamB;
                match.loser = match.teamA;
            } else {
                match.winner = null;
                match.loser = null;
            }
        } else {
            match.winner = null;
            match.loser = null;
        }

        return match;
    });
}

function exportSchedule() {
    const allMatches = [...state.matchesA, ...state.matchesB];
    const headers = ["teamA", "teamB", "time", "court", "bang", "scoreA", "scoreB", "winner", "loser"];
    let csv = headers.join(',') + '\n';

    allMatches.forEach(match => {
        const row = headers.map(header => {
            let value = match[header];
            if (value === null || value === undefined) {
                return "";
            }
            return `"${String(value).replace(/"/g, '""')}"`;
        }).join(',');
        csv += row + '\n';
    });

    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `schedule_tkd_export_${new Date().toISOString().slice(0, 10)}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    showModal('Export Lịch', 'Đã xuất lịch thi đấu hiện tại ra file CSV.');
}

// --- Automated Schedule Generation Logic ---

/**
 * Tải lịch cố định mẫu (CalendarTKD30)
 */
function taoLichCoDinh() {
    if (!confirm("Bạn có chắc chắn muốn tải Lịch mẫu (CalendarTKD30)? Lịch và kết quả hiện tại sẽ bị ghi đè.")) return;
    
    try {
        const matches = parseCSV(FIXED_SCHEDULE_CSV);
        state.matchesA = matches.filter(m => m.bang === 'A');
        state.matchesB = matches.filter(m => m.bang === 'B');
        
        // Reset vòng chung kết
        state.semifinals = [ DEFAULT_SF1, DEFAULT_SF2 ];
        state.final = DEFAULT_FINAL;
        
        stateChanged = true;
        tinhVaCapNhatXepHang();
        renderMatchesView();
        renderFinals();
        renderOverview();
        saveToGitHub();
        
        updateStatus('configStatus', 'success', `Đã tải lịch mẫu (CalendarTKD30) thành công.`);
        
    } catch (error) {
         updateStatus('configStatus', 'danger', `Lỗi tải lịch mẫu: ${error.message}`);
         console.error(error);
    }
}

/**
 * Tự động điền điểm 11-X cho các trận chưa đấu (dùng cho testing/simulating)
 */
function autoFillScores() {
    if (!confirm("Bạn có chắc chắn muốn Tự động điền kết quả (11 - X) cho các trận chưa đấu?")) return;
    
    let filledCount = 0;
    const allMatches = [...state.matchesA, ...state.matchesB, ...state.semifinals, state.final];

    allMatches.forEach(match => {
        if (!match.winner && match.teamA && match.teamB && !match.teamA.includes('Nhất') && !match.teamA.includes('Thắng')) {
            
            // Random người thắng
            const isTeamAWinning = Math.random() < 0.5;
            
            // Random điểm cho người thua (0-9)
            const loserScore = Math.floor(Math.random() * 10);
            
            let scoreA, scoreB;
            if (isTeamAWinning) {
                scoreA = 11;
                scoreB = loserScore;
                match.winner = match.teamA;
            } else {
                scoreA = loserScore;
                scoreB = 11;
                match.winner = match.teamB;
            }

            match.scoreA = scoreA;
            match.scoreB = scoreB;
            
            if (match.id === 'F') {
                 match.runnerUp = isTeamAWinning ? match.teamB : match.teamA;
            } else {
                 match.loser = isTeamAWinning ? match.teamB : match.teamA;
            }

            filledCount++;
        }
    });

    if (filledCount > 0) {
        stateChanged = true;
        tinhVaCapNhatXepHang();
        renderMatchesView();
        renderFinals();
        renderOverview();
        saveToGitHub();
        updateStatus('configStatus', 'success', `Đã điền ${filledCount} kết quả tự động.`);
    } else {
        updateStatus('configStatus', 'info', `Không có trận nào cần điền kết quả.`);
    }
}


/**
 * Tự động tạo lịch thi đấu vòng tròn 1 lượt tối ưu theo sân (đã tối ưu hóa).
 */
function taoLichThiDauCungGio() {
    if (state.mixedTeams.length === 0 && state.maleTeams.length === 0) {
         showModal('Lỗi', 'Không thể tạo lịch. Vui lòng đảm bảo đã tải danh sách đội từ file players.json.');
         return;
    }

    if (state.matchesA.length > 0 || state.matchesB.length > 0) {
        if (!confirm("Lịch đã tồn tại. Bạn có chắc chắn muốn TẠO LẠI lịch? Mọi kết quả hiện tại sẽ bị xóa.")) return;
    }
    
    // Logic tạo lịch tối ưu (được đơn giản hóa ở đây, trong thực tế sẽ phức tạp hơn)
    const matchesA = generateRoundRobinSchedule(state.mixedTeams, 'A');
    const matchesB = generateRoundRobinSchedule(state.maleTeams, 'B');
    
    const allMatches = assignCourtsToMatches(matchesA, matchesB, state.courts, state.config.preferredCourtType);
    
    // Cập nhật state
    state.matchesA = allMatches.filter(m => m.bang === 'A');
    state.matchesB = allMatches.filter(m => m.bang === 'B');
    
    // Reset vòng chung kết
    state.semifinals = [ DEFAULT_SF1, DEFAULT_SF2 ];
    state.final = DEFAULT_FINAL;

    stateChanged = true;
    tinhVaCapNhatXepHang();
    renderMatchesView();
    renderFinals();
    renderOverview();
    saveToGitHub();
    
    updateStatus('configStatus', 'success', `Đã tạo lịch thi đấu vòng tròn tối ưu: ${matchesA.length} trận Bảng A và ${matchesB.length} trận Bảng B.`);
}

/**
 * Thuật toán tạo lịch vòng tròn 1 lượt (Round Robin).
 */
function generateRoundRobinSchedule(teams, bang) {
    if (teams.length < 2) return [];

    const schedule = [];
    const n = teams.length;
    const teamNames = teams.map(t => t.name);
    
    // Thuật toán Circle Method
    const fixedTeam = teamNames[0];
    let rotatingTeams = teamNames.slice(1);
    
    const rounds = n % 2 === 0 ? n - 1 : n;
    
    for (let r = 0; r < rounds; r++) {
        let currentRound = [];
        
        // Trận đấu của đội cố định (nếu số đội là chẵn)
        if (n % 2 === 0) {
            const opponent = rotatingTeams[rotatingTeams.length - 1];
            currentRound.push({ teamA: fixedTeam, teamB: opponent, bang: bang });
        }
        
        // Các trận đấu còn lại (xoay vòng)
        const half = rotatingTeams.length / 2;
        for (let i = 0; i < half; i++) {
            currentRound.push({ 
                teamA: rotatingTeams[i], 
                teamB: rotatingTeams[rotatingTeams.length - 1 - i], 
                bang: bang 
            });
        }
        
        schedule.push(...currentRound);
        
        // Xoay vòng các đội (Circle Method)
        if (rotatingTeams.length > 0) {
            const last = rotatingTeams.pop();
            rotatingTeams.unshift(last);
        }
    }
    
    return schedule.map(match => ({
        ...match,
        time: null, // Sẽ được gán sau
        court: null, // Sẽ được gán sau
        scoreA: null,
        scoreB: null,
        winner: null,
        loser: null
    }));
}

/**
 * Thuật toán gán sân và giờ thi đấu tối ưu (Tối ưu hóa theo thời gian và sân).
 */
function assignCourtsToMatches(matchesA, matchesB, courts, preferredCourtType) {
    const allMatches = [...matchesA, ...matchesB];
    
    // Khởi tạo trạng thái sân
    const courtStates = courts.map(court => ({
        ...court,
        currentTime: parseTime(court.startTime),
        available: true
    }));
    
    // Ưu tiên sân cho bảng A/B
    const preferredCourt = preferredCourtType === 'mixed' ? 'A' : 'B';
    
    // Sort matches: Ưu tiên bảng ưu tiên
    allMatches.sort((a, b) => {
        if (a.bang === preferredCourt && b.bang !== preferredCourt) return -1;
        if (a.bang !== preferredCourt && b.bang === preferredCourt) return 1;
        return 0;
    });

    let assignedMatches = [];
    let matchIndex = 0;
    const matchDuration = 20; // Phút/trận (bao gồm cả thời gian nghỉ)

    while (matchIndex < allMatches.length) {
        let match = allMatches[matchIndex];
        let bestCourt = null;
        let earliestTime = Infinity;

        // Tìm sân phù hợp và trống
        courtStates.forEach(court => {
            const courtType = court.isMixed ? 'A' : 'B';
            
            if (courtType === match.bang) {
                const availableTime = court.currentTime;
                
                // Kiểm tra thời lượng tối đa
                const maxTime = addMinutes(parseTime(court.startTime), court.maxDurationMinutes);
                if (availableTime < maxTime) {
                    if (availableTime < earliestTime) {
                        earliestTime = availableTime;
                        bestCourt = court;
                    }
                }
            }
        });

        if (bestCourt) {
            // Gán giờ và sân
            match.time = formatTime(earliestTime);
            match.court = bestCourt.name;
            
            // Cập nhật trạng thái sân: Thời gian trận tiếp theo
            bestCourt.currentTime = addMinutes(earliestTime, matchDuration);
            
            assignedMatches.push(match);
            matchIndex++;
        } else {
             // Không tìm thấy sân trống phù hợp nào trong thời gian còn lại.
             // (Xảy ra khi tất cả sân đều đã đầy hoặc vượt quá thời lượng tối đa)
             // Tăng thời gian lên 5 phút và thử lại (nếu cần)
             break; // Thoát vòng lặp nếu không thể gán nữa
        }
    }
    
    // Sắp xếp lại theo Giờ/Sân
    assignedMatches.sort((a, b) => {
         if (a.time && b.time && a.time.localeCompare(b.time) !== 0) {
            return a.time.localeCompare(b.time);
        }
        return a.court.localeCompare(b.court);
    });

    return assignedMatches;
}

/**
 * Helper: Chuyển HH:mm thành số phút từ 00:00.
 */
function parseTime(timeStr) {
    const [h, m] = timeStr.split(':').map(Number);
    return h * 60 + m;
}

/**
 * Helper: Chuyển số phút thành HH:mm.
 */
function formatTime(minutes) {
    const h = Math.floor(minutes / 60);
    const m = minutes % 60;
    return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
}

/**
 * Helper: Cộng thêm phút.
 */
function addMinutes(minutes, add) {
    return minutes + add;
}


// Khởi tạo lịch Vòng Chung kết tự động
function scheduleFinalsAuto() {
     if (state.matchesA.length === 0 || state.matchesB.length === 0) {
         showModal('Lỗi', 'Vui lòng tạo lịch Vòng Bảng trước.');
         return;
     }
     if (confirm("Bạn có muốn Tự động đặt lại giờ/sân cho Vòng Chung kết không?")) {
          // Lấy cấu hình sân 3 (hoặc sân bất kỳ mà isMixed=true)
          const court3 = state.courts.find(c => c.name === 'Sân 3') || state.courts.find(c => c.isMixed) || { name: 'Sân CK', startTime: '16:40' };
          
          state.semifinals[0].time = '16:40';
          state.semifinals[0].court = court3.name;
          state.semifinals[1].time = '17:05';
          state.semifinals[1].court = court3.name;
          state.final.time = '17:30';
          state.final.court = court3.name;
          
          stateChanged = true;
          renderFinals();
          showModal('Thông báo', `Đã đặt lịch Vòng Chung kết: SF1 lúc 16:40, SF2 lúc 17:05, Chung kết lúc 17:30 tại ${court3.name}.`);
     }
}


</script>
</body>
</html>
