<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TKD Championship 2025 — Quản lý giải Pickleball V19 GitHub (Sửa lỗi Tải lịch & Hiển thị Danh sách đội)</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body { background:#f7f9fc; font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial; color:#222; padding:18px; }
    .tab-content { margin-top: 18px; }
    .logo { 
      width:64px; 
      height:64px; 
      object-fit:contain; 
      border-radius:8px; 
      border:1px solid #e6eefc; 
      padding:6px; 
      background:#fff; 
    }
    table th { background:#0d6efd; color:#fff; position:sticky; top:0; }
    .status { font-size:0.95rem; color:#555; }
    /* Responsive adjustment for match inputs */
    .match-score-cell input {
      width: 45px;
      text-align: center;
      padding: 0.1rem;
    }
    @media (max-width: 576px) {
      .match-score-cell input {
        width: 35px;
      }
    }
    .winner { font-weight: bold; color: green; }
    .loser { color: red; }
    .ranking-container { display: flex; flex-direction: column; gap: 20px; }
    @media (min-width: 768px) {
        .ranking-container { flex-direction: row; }
        .ranking-container > div { flex: 1; }
    }
  </style>
</head>
<body>
<div class="container">
  <div class="d-flex justify-content-between align-items-center mb-3">
    <div class="d-flex align-items-center gap-2">
      <img class="logo" src="data/logoTKD.png" alt="Logo TKD">
      <div>
        <h3 class="mb-0">TKD Championship 2025</h3>
        <div>Ngày thi đấu: 18/10/2025 (**V19**)</div>
      </div>
    </div>
    <div>
      <div id="autoSaveStatus" class="text-end status">Auto-save: <span id="autoState" class="text-danger">Tắt</span></div>
      <div id="lastSaved" class="text-end status">Chưa lưu</div>
    </div>
  </div>

  <ul class="nav nav-tabs" id="mainTabs">
    <li class="nav-item"><button class="nav-link active" data-bs-toggle="tab" data-bs-target="#overview" onclick="renderOverview()">Tổng quan</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#matches" id="matchesTabButton" onclick="renderMatchesView()">Vòng Bảng</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#finals" onclick="renderFinals()">Vòng Chung Kết</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#results" onclick="tinhVaCapNhatXepHang(); renderFinalResults();">Kết quả Chung cuộc</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#config" id="configTabButton" onclick="renderConfig()">Cấu hình</button></li>
  </ul>

  <div class="tab-content">
    <div class="tab-pane fade show active p-3" id="overview">
        <div id="overviewContent">Đang tải dữ liệu...</div>
    </div>
    
    <div class="tab-pane fade p-3" id="matches">
      <div class="d-flex gap-2 mb-3 flex-wrap">
        <label for="viewMode" class="form-label mb-0 align-self-center text-nowrap">Chế độ xem:</label>
        <select id="viewMode" class="form-select form-select-sm w-auto" onchange="renderMatchesView()">
            <option value="table">Theo Bảng đấu</option>
            <option value="court" selected>Theo Sân thi đấu</option>
        </select>
        
        <button class="btn btn-sm btn-info ms-auto" onclick="document.getElementById('fileInput').click()">Import Lịch (CSV)</button>
        <input type="file" id="fileInput" accept=".csv" style="display: none;" onchange="handleFileSelect(event)">
        
        <button class="btn btn-sm btn-warning" onclick="exportSchedule()">Export Lịch (CSV)</button>
      </div>
      
      <div id="matchesViewContent">
        <h6 id="scheduleAHeader" class="mt-4">Bảng A (Nam - Nữ)</h6><div id="tableMatchesA">Chưa có lịch thi đấu.</div>
        
        <h6 class="mt-4">Bảng B (Nam)</h6><div id="tableMatchesB">Chưa có lịch thi đấu.</div>
      </div>

      <button class="btn btn-warning mt-4" onclick="scheduleFinalsAuto()">Lên lịch Vòng Chung kết (Tự động hóa)</button>
    </div>

    <div class="tab-pane fade p-3" id="finals">
        <div id="finalsContent">
            <h6 class="mt-4">Vòng Bán kết (16:30, Sân 1-2)</h6>
            <div id="semifinalMatches">Chưa có lịch thi đấu bán kết. Kết quả Vòng Bảng sẽ tự động cập nhật lịch.</div>

            <h6 class="mt-4">Trận Chung kết (17:00, Sân 1)</h6>
            <div id="finalMatch">Chưa có lịch thi đấu chung kết.</div>
        </div>
    </div>

    <div class="tab-pane fade p-3" id="results">
        <h5 class="mb-3">Bảng xếp hạng Vòng Bảng (Ưu tiên: W > Đối đầu > Hiệu số > Tổng điểm)</h5>
        <div id="rankingTables" class="ranking-container">
            </div>

        <hr class="my-4">

        <h5 class="mb-3">Danh hiệu Chung cuộc</h5>
        <p id="champion">Vô địch: Đang chờ kết quả...</p>
        <p id="runnerUp">Á quân: Đang chờ kết quả...</p>
        <p id="thirdPlace">Hạng Ba Đồng Hạng: Đang chờ kết quả...</p>
    </div>

    <div class="tab-pane fade p-3" id="config">
      <h5 class="mb-3">Công cụ Lập & Điền Lịch Thi đấu</h5>
      <div class="d-flex gap-2 mb-4 flex-wrap">
        <button class="btn btn-sm btn-primary" onclick="taoLichThiDauCungGio()">Tạo lịch thi đấu Tối ưu (Tự động)</button>
        <button class="btn btn-sm btn-secondary" onclick="taoLichCoDinh()">Tải lịch Mẫu (**CalendarTKD36**)</button>
        <button class="btn btn-sm btn-success" onclick="autoFillScores()">Điền kết quả Tự động (11 - X)</button>
        <button class="btn btn-sm btn-danger" onclick="clearAllSchedules()">Xóa Toàn bộ Lịch</button>
      </div>
      
      <hr>

      <h5 class="mt-4">⚙️ Cấu hình Sân thi đấu & Lịch Tối ưu</h5>
      <p class="text-muted small">Quản lý danh sách sân thi đấu. Sân được gán loại bảng đấu (A/B) để phục vụ chức năng tạo lịch Tối ưu.</p>
      <div class="d-flex gap-2 mb-3 flex-wrap">
          <button class="btn btn-sm btn-primary" onclick="openCourtModal()">+ Thêm Sân Mới</button>
          <button class="btn btn-sm btn-outline-info" onclick="loadDefaultCourtConfig()">Tải cấu hình Mặc định</button>
      </div>
      <div id="courtListContainer">
          </div>
      <div id="courtConfigStatus"></div>
      <hr>

      <h5 class="mt-4">💾 Cấu hình Kết nối GitHub</h5>
      <p class="text-muted">Nhập thông tin kho lưu trữ GitHub để tự động lưu trữ dữ liệu giải đấu.</p>
      <div class="row g-2 mb-2">
        <div class="col-md-3"><input id="cfgOwner" class="form-control" placeholder="Owner (Ví dụ: user_name)"></div>
        <div class="col-md-3"><input id="cfgRepo" class="form-control" placeholder="Repo (Ví dụ: my-data-repo)"></div>
        <div class="col-md-3"><input id="cfgFolder" class="form-control" value="data"></div>
        <div class="col-md-3"><input id="cfgFile" class="form-control" value="state.json"></div>
      </div>
      <input id="cfgToken" type="password" class="form-control mb-2" placeholder="Dán GitHub Personal Access Token (PAT) tại đây">
      <div class="d-flex gap-2">
        <button class="btn btn-primary" onclick="saveConfig()">Lưu cấu hình Local</button>
        <button class="btn btn-success" onclick="checkConnection()">Kiểm tra & Tải Dữ liệu</button>
      </div>
      <div class="mt-2" id="configStatus"></div>
      
      <div class="card bg-light mt-4 shadow-sm">
        <div class="card-body">
            <h5 class="card-title text-info">🔑 Hướng dẫn lấy GitHub Token (PAT)</h5>
            <ol class="small mb-0">
                <li>Truy cập <a href="https://github.com/settings/tokens" target="_blank" class="text-info">GitHub Tokens Settings</a> (Bạn cần đăng nhập).</li>
                <li>Chọn **Generate new token** (hoặc **Generate new token (classic)** nếu bạn dùng tài khoản cũ).</li>
                <li>**Tên Token:** Đặt tên dễ nhớ (ví dụ: `TKDManager_AutoSave`).</li>
                <li>**Thời hạn:** Chọn tùy ý (nên chọn 90 ngày hoặc Tùy chỉnh).</li>
                <li>**Phạm vi (Scopes):** **BẮT BUỘC** tích chọn ô **`repo`** (cho phép truy cập vào kho lưu trữ).</li>
                <li>Nhấn **Generate token** và **SAO CHÉP** chuỗi Token vừa được tạo.</li>
                <li>Dán chuỗi Token đó vào ô "Dán GitHub Personal Access Token (PAT) tại đây" bên trên.</li>
            </ol>
            <p class="mt-2 mb-0 text-danger small">⚠️ **Lưu ý:** Token chỉ hiển thị **MỘT LẦN**. Hãy sao chép ngay lập tức và giữ bí mật. Nếu mất, bạn phải tạo lại Token mới.</p>
        </div>
      </div>
      </div>
  </div>
</div>

<div class="modal fade" id="courtModal" tabindex="-1" aria-labelledby="courtModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="courtModalLabel">Thêm/Sửa Cấu hình Sân</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="courtForm">
          <input type="hidden" id="courtIndex" value="">
          <div class="mb-3">
            <label for="courtName" class="form-label">Tên Sân</label>
            <input type="text" class="form-control" id="courtName" required>
          </div>
          <div class="mb-3">
            <label for="courtStartTime" class="form-label">Giờ Bắt Đầu (HH:mm)</label>
            <input type="time" class="form-control" id="courtStartTime" required>
          </div>
          <div class="mb-3">
            <label for="courtMaxDuration" class="form-label">Thời Lượng Tối Đa (Phút)</label>
            <input type="number" class="form-control" id="courtMaxDuration" min="1" required>
          </div>
          <div class="form-check mb-3">
            <input class="form-check-input" type="checkbox" id="courtIsMixed">
            <label class="form-check-label" for="courtIsMixed">
              Dành cho Bảng A (Nam - Nữ)
            </label>
            <div class="form-text">Nếu không chọn, sân sẽ dành cho Bảng B (Nam).</div>
          </div>
          <div id="courtFormStatus" class="mt-2"></div>
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Hủy</button>
        <button type="button" class="btn btn-primary" onclick="saveCourtChanges()">Lưu Thay Đổi</button>
      </div>
    </div>
  </div>
</div>
<div class="modal fade" id="customAlertModal" tabindex="-1" aria-labelledby="customAlertModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="customAlertModalLabel">Thông báo</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="customAlertModalBody">
        Nội dung thông báo
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Đóng</button>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script> 

<script>
// Dữ liệu lịch cố định từ file CalendarTKD36.csv (MỚI)
const FIXED_SCHEDULE_CSV = `teamA,teamB,time,court,bang,scoreA,scoreB
Triều/Minh,Hiển/P.Hùng,14:00,Sân 1,B,,
Giang/Long,Hường/Đạt,14:00,Sân 2,A,,
Hậu/Dũng,Hạnh/Tiến,14:00,Sân 3,A,,
Huyền/Luân,Linh/M.Hùng,14:00,Sân7,A,,
Tiệp/Thủy,Phương/Thanh,14:15,Sân 1,B,,
Tín/Khiêm,Ánh/Toàn,14:15,Sân 2,B,,
Hậu/Dũng,Hường/Đạt,14:15,Sân 3,A,,
Giang/Long,Huyền/Luân,14:15,Sân7,A,,
Triều/Minh,Tín/Khiêm,14:30,Sân 1,B,,
Tiệp/Thủy,Hiển/P.Hùng,14:30,Sân 2,B,,
Hạnh/Tiến,Linh/M.Hùng,14:30,Sân 3,A,,
Phương/Thanh,Ánh/Toàn,14:30,Sân7,B,,
Huyền/Luân,Hường/Đạt,14:45,Sân 2,A,,
Hạnh/Tiến,Giang/Long,14:45,Sân 3,A,,
Hậu/Dũng,Linh/M.Hùng,14:45,Sân7,A,,
Tiệp/Thủy,Tín/Khiêm,15:00,Sân 1,B,,
Triều/Minh,Phương/Thanh,15:00,Sân 2,B,,
Giang/Long,Hậu/Dũng,15:00,Sân 3,A,,
Hường/Đạt,Linh/M.Hùng,15:00,Sân7,A,,
Ánh/Toàn,Hiển/P.Hùng,15:15,Sân 1,B,,
Huyền/Luân,Hậu/Dũng,15:15,Sân 2,A,,
Linh/M.Hùng,Giang/Long,15:15,Sân 3,A,,
Hạnh/Tiến,Hường/Đạt,15:15,Sân7,A,,
Triều/Minh,Ánh/Toàn,15:30,Sân 1,B,,
Tín/Khiêm,Hiển/P.Hùng,15:30,Sân 2,B,,
Tiệp/Thủy,Phương/Thanh,15:45,Sân 1,B,,
Phương/Thanh,Tín/Khiêm,15:45,Sân 2,B,,
Ánh/Toàn,Tiệp/Thủy,16:00,Sân 1,B,,
Hiển/P.Hùng,Triều/Minh,16:00,Sân 2,B,,
Hậu/Dũng,Giang/Long,16:15,Sân 3,A,,
Huyền/Luân,Hạnh/Tiến,16:15,Sân7,A,,
Hường/Đạt,Linh/M.Hùng,16:30,Sân 3,A,,
Hậu/Dũng,Huyền/Luân,16:30,Sân7,A,,
Giang/Long,Linh/M.Hùng,16:45,Sân 3,A,,
Hạnh/Tiến,Hường/Đạt,16:45,Sân7,A,,
Hậu/Dũng,Hạnh/Tiến,17:00,Sân 3,A,,
Giang/Long,Hường/Đạt,17:00,Sân7,A,,
Huyền/Luân,Linh/M.Hùng,17:15,Sân 3,A,,
Hậu/Dũng,Linh/M.Hùng,17:15,Sân7,A,,
Giang/Long,Huyền/Luân,17:30,Sân 3,A,,
Hậu/Dũng,Hường/Đạt,17:30,Sân7,A,,
Hạnh/Tiến,Linh/M.Hùng,17:45,Sân 3,A,,
Huyền/Luân,Hường/Đạt,17:45,Sân7,A,,
Hạnh/Tiến,Giang/Long,18:00,Sân 3,A,,
Hậu/Dũng,Huyền/Luân,18:00,Sân7,A,,
Linh/M.Hùng,Hường/Đạt,18:15,Sân 3,A,,
Hạnh/Tiến,Hậu/Dũng,18:15,Sân7,A,,
Giang/Long,Linh/M.Hùng,18:30,Sân 3,A,,
Huyền/Luân,Hường/Đạt,18:30,Sân7,A,`;

// Biến state lưu trữ dữ liệu chính của ứng dụng.
let state = { 
  mixedTeams: [], // Sẽ được tải từ players.json
  maleTeams: [],  // Sẽ được tải từ players.json
  matchesA: [], 
  matchesB: [],
  tableA: [], // Bảng xếp hạng A
  tableB: [], // Bảng xếp hạng B
  
  // NEW: Court Configuration
  courts: [
    { name: 'Sân 1', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, // Bảng A (Mixed)
    { name: 'Sân 2', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, // Bảng A (Mixed)
    { name: 'Sân 3', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }, // Bảng B (Male)
    { name: 'Sân 4', startTime: '14:00', maxDurationMinutes: 180, isMixed: false } // Bảng B (Male)
  ],
  
  // LOGIC BÁN KẾT (ĐÃ ĐIỀU CHỈNH: Nhất A vs Nhì A, Nhất B vs Nhì B)
  semifinals: [
    { id: 'SF1', teamA: 'Nhất A', teamB: 'Nhì A', scoreA: null, scoreB: null, time: '16:30', court: 'Sân 1', winner: null, loser: null },
    { id: 'SF2', teamA: 'Nhất B', teamB: 'Nhì B', scoreA: null, scoreB: null, time: '16:30', court: 'Sân 2', winner: null, loser: null }
  ],
  final: { id: 'F', teamA: 'Thắng SF1', teamB: 'Thắng SF2', scoreA: null, scoreB: null, time: '17:00', court: 'Sân 1', winner: null, runnerUp: null },
  config: {}
};

let stateChanged = false; // Biến cờ theo dõi thay đổi dữ liệu
let currentSha = null; // Biến lưu trữ SHA của file trên GitHub
let autoSaveInterval = null; // Biến lưu trữ ID của interval

// --- Custom Modal Function ---
function showModal(title, body) {
    document.getElementById('customAlertModalLabel').textContent = title;
    document.getElementById('customAlertModalBody').innerHTML = body;
    const modal = new bootstrap.Modal(document.getElementById('customAlertModal'));
    modal.show();
}

/**
 * Hàm chuyển đổi tab
 * @param {string} tabId - ID của tab cần chuyển (ví dụ: 'matches', 'overview')
 */
function switchTab(tabId) {
    const tabElement = document.querySelector(`#mainTabs button[data-bs-target="#${tabId}"]`);
    if (tabElement) {
        // Tắt tab đang active
        document.querySelectorAll('#mainTabs .nav-link').forEach(btn => btn.classList.remove('active'));
        document.querySelectorAll('.tab-content .tab-pane').forEach(pane => pane.classList.remove('show', 'active'));

        // Bật tab mới
        tabElement.classList.add('active');
        document.getElementById(tabId).classList.add('show', 'active');
        
        // Cập nhật view cho tab matches nếu chuyển đến
        if (tabId === 'matches') {
            renderMatchesView();
        }
    }
}

// --- Helper Functions cho Base64 ---
function b64EncodeUnicode(str) {
  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g,
    function(match, p1) {
      return String.fromCharCode('0x' + p1);
    }));
}

function b64DecodeUnicode(str) {
  return decodeURIComponent(atob(str).split('').map(function(c) {
    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
  }).join(''));
}

// --- GitHub API Functions ---

/**
 * Lấy SHA mới nhất của file state.json trên GitHub.
 * @param {object} cfg - Cấu hình GitHub (owner, repo, folder, file, token)
 * @returns {Promise<{sha: string|null, content: string|null}>}
 */
async function fetchFileSha(cfg, fileName = cfg.file) {
    const filePath = `${cfg.folder}/${fileName}`;
    const apiUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}/contents/${filePath}`;
    
    try {
        const response = await fetch(apiUrl, {
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });
        
        if (response.ok) {
            const data = await response.json();
            if (fileName === cfg.file) {
                 currentSha = data.sha; // Chỉ lưu SHA của state.json
            }
            return { sha: data.sha, content: data.content };
        } else if (response.status === 404) {
            if (fileName === cfg.file) {
                 currentSha = null; 
            }
            return { sha: null, content: null };
        } else {
            throw new Error(`Lỗi khi lấy SHA: ${response.statusText}`);
        }
    } catch (error) {
        console.error(`Lỗi Fetch SHA (${fileName}):`, error);
        throw new Error(`Lỗi kết nối hoặc API: ${error.message}`);
    }
}

/**
 * Tải danh sách đội từ players.json
 */
async function loadPlayersFromGitHub(cfg) {
    // players.json phải nằm cùng thư mục với state.json
    const fileName = 'players.json';
    
    try {
        updateStatus('configStatus', 'info', 'Đang tải danh sách đội từ GitHub (players.json)...');
        const result = await fetchFileSha(cfg, fileName); 
        
        if (result.content) {
            const jsonString = b64DecodeUnicode(result.content);
            const loadedTeams = JSON.parse(jsonString);

            if (Array.isArray(loadedTeams.mixedTeams) && Array.isArray(loadedTeams.maleTeams)) {
                state.mixedTeams = loadedTeams.mixedTeams;
                state.maleTeams = loadedTeams.maleTeams;
                updateStatus('configStatus', 'success', `Tải danh sách đội thành công (${state.mixedTeams.length + state.maleTeams.length} đội).`);
                return true;
            } else {
                throw new Error("File players.json không đúng định dạng (thiếu mixedTeams/maleTeams).");
            }
        } else {
             // 404 hoặc không có content
            updateStatus('configStatus', 'warning', 'Không tìm thấy file players.json. Dùng danh sách đội khởi tạo (trống).');
            return false;
        }
    } catch (error) {
        console.error("Lỗi khi tải players.json:", error);
        updateStatus('configStatus', 'danger', `Lỗi tải danh sách đội: ${error.message}`);
        return false;
    }
}

/**
 * Tải trạng thái giải đấu (state.json) từ GitHub.
 */
async function loadFromGitHub() {
    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) return;

    // 1. Load Teams (danh sách đội)
    await loadPlayersFromGitHub(cfg); 

    // 2. Load App State (state.json)
    try {
        updateStatus('configStatus', 'info', 'Đang tải trạng thái giải đấu từ GitHub (state.json)...');
        // fetchFileSha sẽ tự động cập nhật currentSha
        const result = await fetchFileSha(cfg, cfg.file); 
        
        if (result.content) {
            const jsonString = b64DecodeUnicode(result.content);
            const loadedState = JSON.parse(jsonString);

            // Ghi đè các giá trị khác ngoài teams (teams đã được load từ players.json)
            state.matchesA = loadedState.matchesA || [];
            state.matchesB = loadedState.matchesB || [];
            
            // Tải cấu hình sân (NEW) - nếu không có, giữ nguyên mặc định
            if (loadedState.courts) {
                state.courts = loadedState.courts;
            }
            
            // Xử lý logic tải cho semifinals và final (đảm bảo không ghi đè lịch tự động)
            const loadedSemifinals = loadedState.semifinals;
            
            // Cấu trúc mặc định mới: Nhất A vs Nhì A, Nhất B vs Nhì B
            const defaultSF1 = { teamA: 'Nhất A', teamB: 'Nhì A' };
            const defaultSF2 = { teamA: 'Nhất B', teamB: 'Nhì B' };
            
            if (loadedSemifinals && loadedSemifinals.length === 2 && 
                (loadedSemifinals[0].teamA !== defaultSF1.teamA || loadedSemifinals[0].teamB !== defaultSF1.teamB ||
                 loadedSemifinals[1].teamA !== defaultSF2.teamA || loadedSemifinals[1].teamB !== defaultSF2.teamB)
            ) {
                // Nếu đã có đội thực tế được gán, giữ nguyên (đã tính từ data vòng bảng)
                state.semifinals = loadedSemifinals;
            } else if (loadedSemifinals && loadedSemifinals.length === 2) {
                // Nếu là trạng thái rỗng, vẫn load
                state.semifinals = loadedSemifinals;
            }

            state.final = loadedState.final || state.final;
            
            // Cập nhật giao diện
            renderMatchesView(); // <--- FIX: Sửa từ renderMatches()
            tinhVaCapNhatXepHang();
            renderFinals();
            renderFinalResults();
            renderOverview();
            
            updateStatus('configStatus', 'success', `Tải trạng thái giải đấu thành công từ: ${cfg.owner}/${cfg.repo}/${cfg.folder}/${cfg.file}`);
            document.getElementById('lastSaved').textContent = `Lần tải: ${new Date().toLocaleTimeString('vi-VN')}`;
        } else {
            updateStatus('configStatus', 'warning', 'File trạng thái (state.json) chưa tồn tại. Vui lòng nhấn Lưu hoặc Tự động lưu để tạo file.');
        }

        startAutoSave();

    } catch (error) {
        updateStatus('configStatus', 'danger', `Lỗi tải trạng thái giải đấu: ${error.message}. Vui lòng kiểm tra lại Token/Repo.`);
        console.error("Lỗi khi tải trạng thái giải đấu từ GitHub:", error);
    }
}

async function saveToGitHub() {
    // Bỏ qua nếu không có thay đổi
    if (!stateChanged) return;

    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) {
        console.warn("Không thể tự động lưu: Thiếu cấu hình GitHub.");
        document.getElementById('autoState').className = 'text-warning';
        document.getElementById('autoState').textContent = 'Tạm dừng (Thiếu Config)';
        return;
    }

    document.getElementById('autoState').className = 'text-info';
    document.getElementById('autoState').textContent = 'Đang lưu...';

    const apiUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}/contents/${cfg.folder}/${cfg.file}`;
    
    // Chỉ lưu các trường cần thiết, loại bỏ config và table (vì chúng được tính lại)
    const stateToSave = {
        mixedTeams: state.mixedTeams,
        maleTeams: state.maleTeams,
        matchesA: state.matchesA,
        matchesB: state.matchesB,
        courts: state.courts,
        semifinals: state.semifinals,
        final: state.final
    };
    const content = b64EncodeUnicode(JSON.stringify(stateToSave));
    
    try {
        // Luôn fetch SHA mới nhất trước khi cố gắng lưu
        const result = await fetchFileSha(cfg, cfg.file); // Lấy SHA của state.json
        const sha = result.sha; 
        
        const payload = {
            message: `[Auto-save] Cập nhật trạng thái giải đấu TKD lúc ${new Date().toLocaleString('vi-VN')}`,
            content: content
        };
        
        // Chỉ thêm SHA vào payload nếu nó đã tồn tại (để cập nhật), 
        if (sha) {
             payload.sha = sha;
        }

        const response = await fetch(apiUrl, {
            method: 'PUT',
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Content-Type': 'application/json',
                'Accept': 'application/vnd.github.v3+json'
            },
            body: JSON.stringify(payload)
        });

        if (response.ok) {
            const data = await response.json();
            currentSha = data.content.sha;
            stateChanged = false;
            document.getElementById('lastSaved').textContent = `Lần lưu: ${new Date().toLocaleTimeString('vi-VN')}`;
            document.getElementById('autoState').className = 'text-success';
            document.getElementById('autoState').textContent = 'Đã Lưu';
        } else {
            // Trường hợp lỗi 409 Conflict (SHA cũ)
            if (response.status === 409) {
                console.warn("Lỗi 409 Conflict: Dữ liệu đã thay đổi trên GitHub. Đang cố gắng lấy SHA mới.");
                
                // Lấy lại SHA mới nhất. stateChanged vẫn là true, 
                // để AutoSave interval sẽ thử lại với SHA mới trong lần tiếp theo.
                await fetchFileSha(cfg, cfg.file); 
                
                document.getElementById('autoState').className = 'text-warning';
                document.getElementById('autoState').textContent = 'Conflict. Sẽ thử lưu lại sau 1 phút.';
            } else {
                throw new Error(`Lỗi HTTP: ${response.status} - ${response.statusText}`);
            }
        }
    } catch (error) {
        console.error("Lỗi khi lưu lên GitHub:", error);
        document.getElementById('autoState').className = 'text-danger';
        document.getElementById('autoState').textContent = 'Lỗi Lưu';
    }
}

async function checkConnection() {
    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) {
        updateStatus('configStatus', 'warning', 'Vui lòng nhập đầy đủ Owner, Repo và Token.');
        return;
    }

    try {
        updateStatus('configStatus', 'info', 'Đang kiểm tra kết nối...');
        
        const repoCheckUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}`;
        const repoResponse = await fetch(repoCheckUrl, {
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });

        if (!repoResponse.ok) {
            throw new Error(`Lỗi truy cập kho lưu trữ. Mã: ${repoResponse.status}. (Kiểm tra Token/Repo/Owner)`);
        }
        
        updateStatus('configStatus', 'success', 'Kết nối GitHub thành công! Đang tải dữ liệu...');
        await loadFromGitHub();

    } catch (error) {
        updateStatus('configStatus', 'danger', `Kiểm tra kết nối thất bại: ${error.message}.`);
        console.error("Lỗi kiểm tra kết nối:", error);
    }
}

// --- Cấu hình & Khởi tạo ---

function renderConfig() {
    // Chỉ cần hiển thị cấu hình sân hiện tại
    renderCourtList();
    document.getElementById('courtConfigStatus').innerHTML = '';
}

/**
 * Hiển thị danh sách sân dưới dạng bảng với nút Sửa/Xóa.
 */
function renderCourtList() {
    const container = document.getElementById('courtListContainer');
    if (!container) return;
    
    if (state.courts.length === 0) {
        container.innerHTML = `<div class="alert alert-warning">Chưa có sân nào được cấu hình.</div>`;
        return;
    }
    
    let html = `<div class='table-responsive'><table class='table table-striped table-sm'>
        <thead>
            <tr>
                <th>Tên Sân</th>
                <th>Giờ Bắt Đầu</th>
                <th>Thời Lượng Max (Phút)</th>
                <th>Phân Loại</th>
                <th class="text-center">Hành động</th>
            </tr>
        </thead>
        <tbody>`;
        
    state.courts.forEach((court, index) => {
        const type = court.isMixed ? 'Bảng A (Nam - Nữ)' : 'Bảng B (Nam)';
        const typeClass = court.isMixed ? 'badge bg-primary' : 'badge bg-info';
        
        html += `<tr>
            <td>${court.name}</td>
            <td>${court.startTime}</td>
            <td>${court.maxDurationMinutes}</td>
            <td><span class="${typeClass}">${type}</span></td>
            <td class="text-center">
                <button class="btn btn-sm btn-outline-secondary me-1" onclick="openCourtModal(${index})">Sửa</button>
                <button class="btn btn-sm btn-outline-danger" onclick="deleteCourt(${index})">Xóa</button>
            </td>
        </tr>`;
    });
    
    html += `</tbody></table></div>`;
    container.innerHTML = html;
}

/**
 * Mở modal thêm/sửa sân và điền dữ liệu nếu là chế độ sửa.
 * @param {number | null} index - Chỉ số của sân cần sửa, hoặc null nếu thêm mới.
 */
function openCourtModal(index = null) {
    const modal = new bootstrap.Modal(document.getElementById('courtModal'));
    document.getElementById('courtFormStatus').innerHTML = '';

    document.getElementById('courtIndex').value = index !== null ? index : '';
    document.getElementById('courtModalLabel').textContent = index !== null ? 'Sửa Cấu hình Sân' : 'Thêm Sân Mới';

    if (index !== null) {
        const court = state.courts[index];
        document.getElementById('courtName').value = court.name || '';
        document.getElementById('courtStartTime').value = court.startTime || '14:00';
        document.getElementById('courtMaxDuration').value = court.maxDurationMinutes || 180;
        document.getElementById('courtIsMixed').checked = court.isMixed || false;
    } else {
        // Chế độ thêm mới: Reset form
        document.getElementById('courtName').value = '';
        document.getElementById('courtStartTime').value = '14:00';
        document.getElementById('courtMaxDuration').value = '180';
        document.getElementById('courtIsMixed').checked = true; // Default to Mixed (Bảng A)
    }

    modal.show();
}

/**
 * Lưu thay đổi từ modal vào state.courts
 */
function saveCourtChanges() {
    const indexStr = document.getElementById('courtIndex').value;
    const index = indexStr === '' ? null : parseInt(indexStr);
    
    const name = document.getElementById('courtName').value.trim();
    const startTime = document.getElementById('courtStartTime').value;
    const maxDurationMinutes = parseInt(document.getElementById('courtMaxDuration').value);
    const isMixed = document.getElementById('courtIsMixed').checked;

    const statusDiv = document.getElementById('courtFormStatus');

    // Validation
    if (!name || !startTime || isNaN(maxDurationMinutes) || maxDurationMinutes <= 0) {
        statusDiv.innerHTML = `<div class="alert alert-danger p-2">Vui lòng nhập đầy đủ và hợp lệ các trường (Tên, Giờ, Thời lượng > 0).</div>`;
        return;
    }
    
    // Check for duplicate name (excluding the current edited court)
    const isDuplicate = state.courts.some((c, i) => i !== index && c.name.toLowerCase() === name.toLowerCase()
    );
    if (isDuplicate) {
        statusDiv.innerHTML = `<div class="alert alert-danger p-2">Tên sân "${name}" đã tồn tại.</div>`;
        return;
    }

    const newCourt = { name, startTime, maxDurationMinutes, isMixed };

    if (index !== null) {
        // Edit mode
        state.courts[index] = newCourt;
    } else {
        // Add mode
        state.courts.push(newCourt);
    }

    // Close modal
    bootstrap.Modal.getInstance(document.getElementById('courtModal')).hide();

    // Update UI and save
    renderCourtList();
    stateChanged = true;
    updateStatus('courtConfigStatus', 'success', `Đã ${index !== null ? 'cập nhật' : 'thêm'} sân "${name}". Dữ liệu sẽ được tự động lưu lên GitHub.`);
    saveToGitHub();
}

/**
 * Xóa sân khỏi danh sách.
 * @param {number} index - Chỉ số của sân cần xóa.
 */
function deleteCourt(index) {
    if (confirm(`Bạn có chắc chắn muốn xóa sân "${state.courts[index].name}"?`)) {
        const deletedCourtName = state.courts[index].name;
        state.courts.splice(index, 1);
        renderCourtList();
        stateChanged = true;
        updateStatus('courtConfigStatus', 'success', `Đã xóa sân "${deletedCourtName}". Dữ liệu sẽ được tự động lưu lên GitHub.`);
        saveToGitHub();
    }
}

/**
 * Tải cấu hình mặc định (phải được cập nhật để dùng logic mới)
 */
function loadDefaultCourtConfig() {
    state.courts = [
      { name: 'Sân 1', startTime: '14:00', maxDurationMinutes: 180, isMixed: true },
      { name: 'Sân 2', startTime: '14:00', maxDurationMinutes: 180, isMixed: true },
      { name: 'Sân 3', startTime: '14:00', maxDurationMinutes: 180, isMixed: false },
      { name: 'Sân 4', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }
    ];
    renderCourtList();
    stateChanged = true;
    updateStatus('courtConfigStatus', 'success', 'Đã tải cấu hình sân Mặc định. Dữ liệu sẽ được tự động lưu lên GitHub.');
    saveToGitHub();
}

function loadConfig() {
    const savedConfig = localStorage.getItem('pkb_config');
    if (savedConfig) {
        state.config = JSON.parse(savedConfig);
        document.getElementById('cfgOwner').value = state.config.owner || '';
        document.getElementById('cfgRepo').value = state.config.repo || '';
        document.getElementById('cfgFolder').value = state.config.folder || 'data';
        document.getElementById('cfgFile').value = state.config.file || 'state.json';
        document.getElementById('cfgToken').value = state.config.token || '';
    }
}

function saveConfig(){
    const cfg = {
        owner: document.getElementById('cfgOwner').value,
        repo: document.getElementById('cfgRepo').value,
        folder: document.getElementById('cfgFolder').value,
        file: document.getElementById('cfgFile').value,
        token: document.getElementById('cfgToken').value
    };
    state.config = cfg;
    localStorage.setItem('pkb_config', JSON.stringify(cfg));
    updateStatus('configStatus', 'success', 'Đã lưu cấu hình GitHub vào trình duyệt. Vui lòng Kiểm tra & Tải Dữ liệu.');
}

function updateStatus(id, type, message) {
    const statusDiv = document.getElementById(id);
    statusDiv.innerHTML = `<div class="alert alert-${type} p-2 mt-2">${message}</div>`;
}

function startAutoSave() {
    if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
    }
    if (state.config.token && state.config.owner && state.config.repo) {
        autoSaveInterval = setInterval(saveToGitHub, 60000);
        document.getElementById('autoState').className = 'text-warning';
        document.getElementById('autoState').textContent = 'Hoạt động...';
    } else {
        document.getElementById('autoState').className = 'text-danger';
        document.getElementById('autoState').textContent = 'Tắt';
    }
}

window.onload = function() {
    loadConfig();
    // Đặt mặc định cho select box thành 'court' khi load trang (dù đã có 'selected' trong HTML)
    const viewModeSelect = document.getElementById('viewMode');
    if (viewModeSelect && viewModeSelect.value !== 'court') {
        viewModeSelect.value = 'court';
    }

    if (state.config.token) {
        // Bắt đầu quy trình tải Teams và App State từ GitHub
        loadFromGitHub();
    } else {
        // Tải cấu hình sân mặc định nếu không có kết nối GitHub
        renderConfig();
        renderMatchesView(); // <--- FIX: Sửa từ renderMatches()
        tinhVaCapNhatXepHang();
        renderFinals();
        renderFinalResults();
        renderOverview();
        startAutoSave();
    }
};

// --- Tab Tổng quan ---

/**
 * Render danh sách đội đầy đủ cho Overview
 */
function renderTeamList(teams, title) {
    if (!teams || teams.length === 0) {
        return `<p class="small text-muted text-center">Chưa có danh sách đội cho ${title}.</p>`;
    }
    
    let html = `
        <div class="card mt-3 mb-3 shadow-sm">
            <div class="card-header bg-secondary text-white p-2">
                <h6 class="mb-0 small">${title} (${teams.length} đội)</h6>
            </div>
            <div class="card-body p-2">
                <ul class="list-unstyled mb-0 d-flex flex-wrap gap-3">`;
    
    teams.forEach(team => {
        html += `<li class="small text-nowrap"><strong>${team}</strong></li>`;
    });
    
    html += `   </ul>
            </div>
        </div>
    `;
    return html;
}

function renderOverview() {
    const totalMatches = state.matchesA.length + state.matchesB.length;
    const completedMatches = [...state.matchesA, ...state.matchesB].filter(m => m.winner).length;
    
    // Đếm số trận đã hoàn thành và sắp xếp theo sân
    const matchesByCourt = {};
    const allMatches = [...state.matchesA, ...state.matchesB];
    
    // Lấy danh sách sân từ cấu hình
    const courtNames = state.courts.map(c => c.name);
    courtNames.forEach(name => {
        matchesByCourt[name] = { total: 0, completed: 0, matches: [] };
    });
    
    allMatches.forEach(match => {
        if (match.court) {
            if (!matchesByCourt[match.court]) {
                matchesByCourt[match.court] = { total: 0, completed: 0, matches: [] };
            }
            matchesByCourt[match.court].total += 1;
            if (match.winner) {
                matchesByCourt[match.court].completed += 1;
            }
            matchesByCourt[match.court].matches.push(match);
        }
    });

    let courtSummaryHTML = `<ul class="list-group">`;
    Object.entries(matchesByCourt).forEach(([courtName, data]) => {
        if (data.total > 0) {
            const progress = data.total > 0 ? ((data.completed / data.total) * 100).toFixed(0) : 0;
            const progressClass = progress == 100 ? 'bg-success' : (progress > 50 ? 'bg-warning' : 'bg-info');
            courtSummaryHTML += `
                <li class="list-group-item">
                    <div class="d-flex w-100 justify-content-between">
                        <h6 class="mb-1">${courtName}</h6>
                        <small>${data.completed}/${data.total} trận (${progress}%)</small>
                    </div>
                    <div class="progress mt-1" role="progressbar" style="height: 5px;">
                        <div class="progress-bar ${progressClass}" style="width: ${progress}%"></div>
                    </div>
                </li>
            `;
        }
    });
    courtSummaryHTML += `</ul>`;

    // Tổng quan
    let html = `
        ${renderTeamList(state.mixedTeams, 'Danh sách Đội Bảng A (Nam - Nữ)')}
        ${renderTeamList(state.maleTeams, 'Danh sách Đội Bảng B (Nam)')}

        <div class="card mb-4 shadow-sm">
            <div class="card-header bg-primary text-white">
                <h6>Tình hình Vòng Bảng</h6>
            </div>
            <div class="card-body">
                <p class="card-text">Tổng số trận đấu: <strong>${totalMatches}</strong></p>
                <p class="card-text">Số trận đã hoàn thành: <strong>${completedMatches}</strong></p>
                <p class="card-text">Tỉ lệ hoàn thành: <strong>${totalMatches > 0 ? ((completedMatches / totalMatches) * 100).toFixed(2) : 0}%</strong></p>
                <button class="btn btn-sm btn-outline-primary" onclick="switchTab('matches')">Xem chi tiết lịch thi đấu</button>
            </div>
        </div>

        <div class="card mb-4 shadow-sm">
            <div class="card-header bg-info text-white">
                <h6>Tiến độ theo Sân thi đấu</h6>
            </div>
            <div class="card-body p-0">
                ${courtSummaryHTML}
            </div>
        </div>
        
        <div class="row">
            <div class="col-md-6">
                <div class="card shadow-sm">
                    <div class="card-header bg-success text-white">
                        <h6>Bảng A (Nam - Nữ)</h6>
                    </div>
                    <div class="card-body p-2">
                        ${renderSimpleRanking(state.tableA)}
                    </div>
                </div>
            </div>
            <div class="col-md-6 mt-3 mt-md-0">
                <div class="card shadow-sm">
                    <div class="card-header bg-success text-white">
                        <h6>Bảng B (Nam)</h6>
                    </div>
                    <div class="card-body p-2">
                        ${renderSimpleRanking(state.tableB)}
                    </div>
                </div>
            </div>
        </div>
    `;

    document.getElementById('overviewContent').innerHTML = html;
}

/**
 * Render bảng xếp hạng đơn giản (Top 4) cho Overview
 */
function renderSimpleRanking(table) {
    if (!table || table.length === 0) {
        return `<p class="text-center p-3 m-0">Chưa có dữ liệu xếp hạng.</p>`;
    }
    
    let html = `<ol class="list-group list-group-numbered">`;
    table.slice(0, 4).forEach((team, index) => {
        const bgClass = (index === 0) ? 'list-group-item-success' : (index === 1 ? 'list-group-item-info' : '');
        html += `<li class="list-group-item d-flex justify-content-between align-items-start ${bgClass}">
            <div class="ms-2 me-auto">
                <div class="fw-bold">${team.team}</div>
                ${team.W} Thắng - ${team.L} Thua, Hiệu số: ${team.PF - team.PA}
            </div>
        </li>`;
    });
    html += `</ol>`;
    return html;
}


// --- Lập lịch Thi đấu ---

/**
 * Xóa toàn bộ lịch thi đấu Vòng Bảng và Chung kết.
 */
function clearAllSchedules() {
    if (confirm('Bạn có chắc chắn muốn XÓA TẤT CẢ LỊCH THI ĐẤU (Vòng Bảng và Chung Kết) và KẾT QUẢ ĐÃ NHẬP? Hành động này không thể hoàn tác.')) {
        state.matchesA = [];
        state.matchesB = [];
        // Reset lịch chung kết về mặc định
        state.semifinals = [
            { id: 'SF1', teamA: 'Nhất A', teamB: 'Nhì A', scoreA: null, scoreB: null, time: '16:30', court: 'Sân 1', winner: null, loser: null },
            { id: 'SF2', teamA: 'Nhất B', teamB: 'Nhì B', scoreA: null, scoreB: null, time: '16:30', court: 'Sân 2', winner: null, loser: null }
        ];
        state.final = { id: 'F', teamA: 'Thắng SF1', teamB: 'Thắng SF2', scoreA: null, scoreB: null, time: '17:00', court: 'Sân 1', winner: null, runnerUp: null };

        // Cập nhật lại giao diện và lưu
        renderMatchesView();
        renderFinals();
        tinhVaCapNhatXepHang();
        renderOverview();
        
        stateChanged = true;
        saveToGitHub();
        showModal('Thành công', 'Đã xóa toàn bộ lịch thi đấu và kết quả.');
    }
}

/**
 * Chuyển đổi chuỗi thời gian HH:mm sang số phút (tính từ 00:00)
 * @param {string} timeString - Chuỗi thời gian HH:mm
 * @returns {number} - Số phút
 */
function timeToMinutes(timeString) {
    const [hours, minutes] = timeString.split(':').map(Number);
    return hours * 60 + minutes;
}

/**
 * Chuyển đổi số phút (tính từ 00:00) sang chuỗi thời gian HH:mm
 * @param {number} minutes - Số phút
 * @returns {string} - Chuỗi thời gian HH:mm
 */
function minutesToTime(minutes) {
    const hours = Math.floor(minutes / 60);
    const mins = minutes % 60;
    return `${String(hours).padStart(2, '0')}:${String(mins).padStart(2, '0')}`;
}

/**
 * Tạo tất cả các cặp đấu (All-play-all) cho một nhóm
 * @param {Array<string>} teams - Danh sách tên đội
 * @param {string} groupName - Tên bảng (A hoặc B)
 * @returns {Array<object>} - Danh sách các trận đấu chưa được lên lịch
 */
function generateAllMatches(teams, groupName) {
    const matches = [];
    let matchIdCounter = 1;
    for (let i = 0; i < teams.length; i++) {
        for (let j = i + 1; j < teams.length; j++) {
            matches.push({
                id: `${groupName}${String(matchIdCounter++).padStart(2, '0')}`,
                teamA: teams[i],
                teamB: teams[j],
                time: null,
                court: null,
                bang: groupName, // <--- Đã thêm trường 'bang' theo yêu cầu
                scoreA: null,
                scoreB: null,
                winner: null,
                loser: null
            });
        }
    }
    return matches;
}

/**
 * NEW: Tạo lịch thi đấu tự động tối ưu theo cấu hình sân (Court Config)
 */
function taoLichThiDauCungGio() {
    if (state.mixedTeams.length < 2 && state.maleTeams.length < 2) {
         showModal('Lỗi', 'Không đủ số đội để tạo lịch thi đấu. Vui lòng tải file players.json.');
         return;
    }

    if (state.courts.length === 0) {
        showModal('Lỗi', 'Chưa có cấu hình sân. Vui lòng thêm sân trong tab "Cấu hình".');
         return;
    }
    
    // 1. Tạo tất cả các trận đấu chưa được lên lịch
    let allMatchesA = generateAllMatches(state.mixedTeams, 'A');
    let allMatchesB = generateAllMatches(state.maleTeams, 'B');

    // 2. Phân loại sân theo bảng đấu (A: Mixed, B: Male)
    const courtsA = state.courts.filter(c => c.isMixed).map(c => ({
        ...c,
        currentTime: timeToMinutes(c.startTime),
        endTime: timeToMinutes(c.startTime) + c.maxDurationMinutes
    }));
    const courtsB = state.courts.filter(c => !c.isMixed).map(c => ({
        ...c,
        currentTime: timeToMinutes(c.startTime),
        endTime: timeToMinutes(c.startTime) + c.maxDurationMinutes
    }));

    if (courtsA.length === 0 && allMatchesA.length > 0) {
        showModal('Cảnh báo', 'Thiếu sân cho **Bảng A (Nam - Nữ)**. Vui lòng cấu hình ít nhất 1 sân trong tab "Cấu hình" cho Bảng A.');
        return;
    }
    if (courtsB.length === 0 && allMatchesB.length > 0) {
        showModal('Cảnh báo', 'Thiếu sân cho **Bảng B (Nam)**. Vui lòng cấu hình ít nhất 1 sân trong tab "Cấu hình" cho Bảng B.');
        return;
    }

    // Gộp tất cả các sân
    const allCourts = [...courtsA, ...courtsB];
    const initialStartTime = Math.min(...allCourts.map(c => c.currentTime));
    const maxEndTime = Math.max(...allCourts.map(c => c.endTime));

    // Thời lượng mặc định cho mỗi trận đấu (15 phút)
    const matchDuration = 15;
    
    let scheduledMatchesA = [];
    let scheduledMatchesB = [];
    
    let currentMatchIndexA = 0;
    let currentMatchIndexB = 0;
    
    // 3. Lên lịch vòng lặp theo từng khoảng thời gian (15 phút)
    let currentTime = initialStartTime;
    while (currentTime < maxEndTime && (currentMatchIndexA < allMatchesA.length || currentMatchIndexB < allMatchesB.length)) {
        
        const nextTime = currentTime + matchDuration;

        // Xử lý các sân Bảng A
        courtsA.forEach(court => {
            if (court.currentTime <= currentTime && court.endTime >= nextTime && currentMatchIndexA < allMatchesA.length) {
                const match = allMatchesA[currentMatchIndexA++];
                match.time = minutesToTime(currentTime);
                match.court = court.name;
                scheduledMatchesA.push(match);
                court.currentTime = nextTime; // Cập nhật thời gian kết thúc trận
            }
        });

        // Xử lý các sân Bảng B
        courtsB.forEach(court => {
            if (court.currentTime <= currentTime && court.endTime >= nextTime && currentMatchIndexB < allMatchesB.length) {
                const match = allMatchesB[currentMatchIndexB++];
                match.time = minutesToTime(currentTime);
                match.court = court.name;
                scheduledMatchesB.push(match);
                court.currentTime = nextTime; // Cập nhật thời gian kết thúc trận
            }
        });

        // Tăng thời gian lên 15 phút
        currentTime = nextTime;
    }

    // 4. Kiểm tra các trận còn sót lại (nếu thời gian sân quá ngắn)
    const remainingA = allMatchesA.length - scheduledMatchesA.length;
    const remainingB = allMatchesB.length - scheduledMatchesB.length;
    let warning = '';
    
    if (remainingA > 0) {
        warning += `⚠️ **Bảng A** còn ${remainingA} trận chưa được xếp lịch (hết thời gian hoặc thiếu sân).<br>`;
        // Đưa các trận còn lại vào danh sách nhưng không có Time/Court
        scheduledMatchesA = scheduledMatchesA.concat(allMatchesA.slice(scheduledMatchesA.length));
    }
    if (remainingB > 0) {
        warning += `⚠️ **Bảng B** còn ${remainingB} trận chưa được xếp lịch (hết thời gian hoặc thiếu sân).<br>`;
        scheduledMatchesB = scheduledMatchesB.concat(allMatchesB.slice(scheduledMatchesB.length));
    }

    // 5. Cập nhật state và render
    state.matchesA = scheduledMatchesA;
    state.matchesB = scheduledMatchesB;
    
    renderMatchesView();
    stateChanged = true;
    saveToGitHub();
    
    const totalScheduled = scheduledMatchesA.length + scheduledMatchesB.length - remainingA - remainingB;
    showModal('Tạo lịch Tối ưu Thành công', 
        `Đã tạo tổng cộng ${totalScheduled} trận đấu cho Vòng Bảng.<br> ${warning}`
    );
}

/**
 * Tải lịch thi đấu cố định từ chuỗi CSV (FIXED_SCHEDULE_CSV)
 */
function taoLichCoDinh() {
    if (state.mixedTeams.length < 2 && state.maleTeams.length < 2) {
         showModal('Lỗi', 'Không đủ số đội để tạo lịch thi đấu. Vui lòng tải file players.json.');
         return;
    }
    
    // Sử dụng hàm importScheduleFromCSV mới
    const importedMatches = importScheduleFromCSV(FIXED_SCHEDULE_CSV);
    
    if (importedMatches.length > 0) {
        // Cập nhật state.matchesA và state.matchesB
        state.matchesA = importedMatches.filter(m => m.bang === 'A');
        state.matchesB = importedMatches.filter(m => m.bang === 'B');
        
        renderMatchesView();
        stateChanged = true;
        saveToGitHub();
        // Cập nhật thông báo để người dùng biết lịch nào đã được tải
        showModal('Thành công', `Đã tải lịch thi đấu Mẫu **CalendarTKD36.csv** (${importedMatches.length} trận) và cập nhật thành công.`);
    } else {
        showModal('Cảnh báo', 'Lịch mẫu rỗng hoặc không hợp lệ.');
    }
}

/**
 * Xử lý file CSV được tải lên
 */
function handleFileSelect(event) {
    const file = event.target.files[0];
    if (!file) {
        return;
    }
    
    const reader = new FileReader();
    reader.onload = (e) => {
        const fileContent = e.target.result;
        try {
            const importedMatches = importScheduleFromCSV(fileContent);

            if (importedMatches.length > 0) {
                // Cập nhật state.matchesA và state.matchesB
                state.matchesA = importedMatches.filter(m => m.bang === 'A');
                state.matchesB = importedMatches.filter(m => m.bang === 'B');
                
                renderMatchesView();
                stateChanged = true;
                saveToGitHub();
                showModal('Thành công', `Đã nhập lịch thi đấu (${importedMatches.length} trận) từ file **${file.name}**.`);
            } else {
                showModal('Cảnh báo', 'File CSV rỗng hoặc không hợp lệ. Vui lòng kiểm tra định dạng: teamA,teamB,time,court,bang,scoreA,scoreB');
            }
        } catch (error) {
            console.error("Lỗi trong quá trình import và render:", error);
            showModal('Lỗi nghiêm trọng', `Đã xảy ra lỗi trong quá trình xử lý file: ${error.message}. Vui lòng kiểm tra console log.`);
        }
    };
    reader.readAsText(file);
}

/**
 * Hàm import lịch thi đấu từ nội dung CSV (CalendarTKD36 format)
 * Đã sửa lỗi:
 * 1. Dùng split(/\r?\n/) để xử lý chính xác ký tự xuống dòng (\n hoặc \r\n).
 * 2. Dùng slice(0, 7) để giới hạn số cột được xử lý, tránh lỗi treo khi CSV có quá nhiều dấu phẩy thừa.
 * * @param {string} csvContent - Nội dung file CSV
 * @returns {Array<object>} - Danh sách trận đấu đã được phân tích
 */
function importScheduleFromCSV(csvContent) {
    // 1. Tách các dòng (xử lý cả \n và \r\n) và lọc bỏ dòng trống
    const lines = csvContent.split(/\r?\n/).filter(line => line.trim() !== '');

    if (lines.length <= 1) {
        return [];
    }
    
    // Lấy header
    const headers = lines[0].split(',').map(h => h.trim());
    
    // Kiểm tra định dạng header cơ bản
    if (headers[0] !== 'teamA' || headers[4] !== 'bang') {
        console.error("Lỗi: Định dạng header CSV không khớp (teamA,teamB,time,court,bang,scoreA,scoreB)");
        return [];
    }
    
    const newMatches = [];
    let matchIdA = 1;
    let matchIdB = 1;

    // Lặp qua từng dòng dữ liệu (bỏ qua header)
    for (let i = 1; i < lines.length; i++) {
        // Tách dòng bằng dấu phẩy
        const originalValues = lines[i].split(',');
        
        // Cải tiến 2: Chỉ lấy 7 cột đầu tiên (teamA -> scoreB)
        const values = originalValues.slice(0, 7).map(v => v.trim());
        
        // Kiểm tra số lượng cột hợp lệ (ít nhất 5 cột chính)
        if (values.length < 5 || !values[0] || !values[1] || !values[4]) {
            console.warn(`Bỏ qua dòng ${i+1}: Không đủ dữ liệu (cần ít nhất 5 cột teamA, teamB, time, court, bang).`);
            continue;
        }

        const teamA = values[0];
        const teamB = values[1];
        const time = values[2] || null;
        const court = values[3] || null;
        const group = values[4].toUpperCase(); // 'A' hoặc 'B'
        
        let matchId = '';
        if (group === 'A') {
            matchId = `A${String(matchIdA++).padStart(2, '0')}`;
        } else if (group === 'B') {
            matchId = `B${String(matchIdB++).padStart(2, '0')}`;
        } else {
             console.warn(`Bỏ qua dòng ${i+1}: Bảng không hợp lệ (${group}).`);
            continue;
        }

        // scores: values[5] và values[6] sẽ là undefined nếu mảng < 6 hoặc 7, 
        // hoặc là "" nếu là giá trị rỗng. Logic cũ vẫn an toàn.
        const scoreA = values[5] ? parseInt(values[5], 10) : null;
        const scoreB = values[6] ? parseInt(values[6], 10) : null;
        
        const match = {
            id: matchId, 
            teamA: teamA,
            teamB: teamB,
            time: time,
            court: court,
            bang: group, // Đã có trường 'bang' khi import từ CSV
            scoreA: scoreA,
            scoreB: scoreB,
            winner: null,
            loser: null,
        };
        
        // Logic xác định winner/loser nếu đã có điểm
        if (match.scoreA !== null && match.scoreB !== null && !isNaN(match.scoreA) && !isNaN(match.scoreB)) {
            if (match.scoreA > match.scoreB) {
                match.winner = match.teamA;
                match.loser = match.teamB;
            } else if (match.scoreB > match.scoreA) {
                match.winner = match.teamB;
                match.loser = match.teamA;
            }
        }

        newMatches.push(match);
    }

    return newMatches;
}


/**
 * Xuất lịch thi đấu hiện tại sang CSV
 */
function exportSchedule() {
    const allMatches = [...state.matchesA, ...state.matchesB];
    
    // Header format: teamA,teamB,time,court,bang,scoreA,scoreB
    let csvContent = `teamA,teamB,time,court,bang,scoreA,scoreB\n`;

    allMatches.sort((a, b) => {
        if (!a.time) return 1;
        if (!b.time) return -1;
        return timeToMinutes(a.time) - timeToMinutes(b.time);
    });

    allMatches.forEach(match => {
        const row = [
            match.teamA,
            match.teamB,
            match.time || '',
            match.court || '',
            match.bang || (match.id.startsWith('A') ? 'A' : 'B'), // Đảm bảo trường 'bang' có giá trị
            match.scoreA !== null ? match.scoreA : '',
            match.scoreB !== null ? match.scoreB : ''
        ];
        
        // Escape dấu phẩy trong tên đội (nếu có) và join bằng dấu phẩy
        const escapedRow = row.map(cell => {
            if (typeof cell === 'string' && cell.includes(',')) {
                return `"${cell}"`; // Bọc trong dấu ngoặc kép
            }
            return cell;
        });
        
        csvContent += escapedRow.join(',') + '\n';
    });
    
    // 3. Tải file
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute("download", "lich_thi_dau_tkd_export.csv");
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    showModal('Xuất file CSV', 'Đã tạo và tải file **lich_thi_dau_tkd_export.csv** thành công (Định dạng: teamA,teamB,time,court,bang,scoreA,scoreB).');
}


/**
 * Hàm điền điểm ngẫu nhiên cho tất cả các trận chưa đấu.
 */
function autoFillScores() {
    let matchesUpdated = 0;

    // Điền điểm ngẫu nhiên cho Vòng Bảng
    [state.matchesA, state.matchesB].forEach(matches => {
        matches.forEach(match => {
            if (!match.winner) {
                if (Math.random() < 0.5) {
                    match.scoreA = 11;
                    match.scoreB = Math.floor(Math.random() * 11); 
                } else {
                    match.scoreB = 11;
                    match.scoreA = Math.floor(Math.random() * 11);
                }
                
                // Cập nhật winner/loser
                if (match.scoreA > match.scoreB) {
                    match.winner = match.teamA;
                    match.loser = match.teamB;
                } else {
                    match.winner = match.teamB;
                    match.loser = match.teamA;
                }
                matchesUpdated++;
            }
        });
    });

    // Random điểm cho Bán kết/Chung kết nếu chưa có
    [...state.semifinals, state.final].forEach(match => {
        if (match.scoreA === null && match.scoreB === null) {
             // Kiểm tra nếu cặp đấu đã được gán đội thực tế (không phải Nhất A/Nhì B, v.v.)
            const isAssigned = match.teamA !== 'Nhất A' && match.teamA !== 'Thắng SF1' && match.teamA !== 'Nhất B' && match.teamA !== 'Thắng SF2';
            
            if (isAssigned) {
                 if (Math.random() < 0.5) {
                    match.scoreA = 11;
                    match.scoreB = Math.floor(Math.random() * 11); 
                } else {
                    match.scoreB = 11;
                    match.scoreA = Math.floor(Math.random() * 11);
                }
                
                // Cập nhật winner/loser
                if (match.scoreA > match.scoreB) {
                    match.winner = match.teamA;
                    match.loser = match.teamB;
                } else {
                    match.winner = match.teamB;
                    match.loser = match.teamA;
                }
                
                if (match.id === 'F') {
                    match.runnerUp = match.loser;
                }
                matchesUpdated++;
            }
        }
    });


    renderMatchesView();
    renderFinals();
    renderOverview();
    
    stateChanged = true;
    saveToGitHub();
    showModal('Điền kết quả Tự động', `Đã điền điểm cho ${matchesUpdated} trận chưa đấu (Vòng Bảng & Chung kết).`);
}


// --- Logic Cập nhật Điểm và Xếp hạng ---

/**
 * Xử lý việc nhập điểm từ giao diện và cập nhật state
 * @param {string} group - 'A' hoặc 'B'
 * @param {number} matchIndex - Chỉ số của trận đấu trong state.matchesA/B
 */
function updateScore(group, matchIndex) {
    const matches = (group === 'A' ? state.matchesA : state.matchesB);
    const match = matches[matchIndex];
    
    const inputA = document.getElementById(`score-${group}-${matchIndex}-A`);
    const inputB = document.getElementById(`score-${group}-${matchIndex}-B`);
    
    let scoreA = parseInt(inputA.value) || null;
    let scoreB = parseInt(inputB.value) || null;

    if (scoreA === null || scoreB === null) {
        // Xóa điểm nếu một trong hai ô trống
        match.scoreA = null;
        match.scoreB = null;
        match.winner = null;
        match.loser = null;
    } else {
        // Ép buộc người chơi phải thắng bằng 11
        if (scoreA < 11 && scoreB < 11) {
            showModal('Lỗi nhập điểm', 'Điểm thắng phải là 11. Vui lòng kiểm tra lại.');
            inputA.value = match.scoreA || '';
            inputB.value = match.scoreB || '';
            return;
        }
        if (scoreA === scoreB) {
            showModal('Lỗi nhập điểm', 'Trận đấu không thể hòa (Trừ khi là 10-10, nhưng cần điểm 11 để thắng).');
            inputA.value = match.scoreA || '';
            inputB.value = match.scoreB || '';
            return;
        }
        
        // Chỉ chấp nhận 1 người thắng
        if (scoreA > scoreB && scoreA < 11) {
            showModal('Lỗi nhập điểm', `Đội ${match.teamA} chỉ có ${scoreA} điểm. Cần 11 điểm để thắng.`);
            inputA.value = match.scoreA || '';
            inputB.value = match.scoreB || '';
            return;
        }
        if (scoreB > scoreA && scoreB < 11) {
            showModal('Lỗi nhập điểm', `Đội ${match.teamB} chỉ có ${scoreB} điểm. Cần 11 điểm để thắng.`);
            inputA.value = match.scoreA || '';
            inputB.value = match.scoreB || '';
            return;
        }

        // Cập nhật điểm và người thắng/thua
        match.scoreA = scoreA;
        match.scoreB = scoreB;
        
        if (scoreA > scoreB) {
            match.winner = match.teamA;
            match.loser = match.teamB;
        } else {
            match.winner = match.teamB;
            match.loser = match.teamA;
        }
    }
    
    // Cập nhật lại giao diện, xếp hạng và lưu
    renderMatchesView(); // Để cập nhật trạng thái W/L trên giao diện
    tinhVaCapNhatXepHang();
    renderOverview();
    
    stateChanged = true;
    saveToGitHub();
}

// Hàm tương tự cho Chung kết
function updateFinalsScore(matchId) {
    let match;
    if (matchId === 'F') {
        match = state.final;
    } else {
        match = state.semifinals.find(m => m.id === matchId);
    }

    if (!match) return;

    const inputA = document.getElementById(`score-${matchId}-A`);
    const inputB = document.getElementById(`score-${matchId}-B`);

    let scoreA = parseInt(inputA.value) || null;
    let scoreB = parseInt(inputB.value) || null;
    
    match.scoreA = scoreA;
    match.scoreB = scoreB;
    match.winner = null;
    match.loser = null;
    match.runnerUp = null;

    if (scoreA !== null && scoreB !== null) {
        // Ép buộc người chơi phải thắng bằng 11
        if (scoreA < 11 && scoreB < 11) {
            showModal('Lỗi nhập điểm', 'Điểm thắng phải là 11. Vui lòng kiểm tra lại.');
            inputA.value = ''; inputB.value = '';
            match.scoreA = null; match.scoreB = null;
            renderFinals(); return;
        }
        if (scoreA === scoreB) {
            showModal('Lỗi nhập điểm', 'Trận đấu không thể hòa.');
            inputA.value = ''; inputB.value = '';
            match.scoreA = null; match.scoreB = null;
            renderFinals(); return;
        }
        
        if (scoreA > scoreB && scoreA < 11) {
             showModal('Lỗi nhập điểm', `Đội ${match.teamA} chỉ có ${scoreA} điểm. Cần 11 điểm để thắng.`);
             inputA.value = ''; inputB.value = '';
             match.scoreA = null; match.scoreB = null;
             renderFinals(); return;
        }
        if (scoreB > scoreA && scoreB < 11) {
             showModal('Lỗi nhập điểm', `Đội ${match.teamB} chỉ có ${scoreB} điểm. Cần 11 điểm để thắng.`);
             inputA.value = ''; inputB.value = '';
             match.scoreA = null; match.scoreB = null;
             renderFinals(); return;
        }


        // Cập nhật người thắng/thua
        if (scoreA > scoreB) {
            match.winner = match.teamA;
            match.loser = match.teamB;
        } else {
            match.winner = match.teamB;
            match.loser = match.teamA;
        }
        
        if (matchId === 'F') {
            match.runnerUp = match.loser;
        }
    }

    // Sau khi cập nhật Bán kết, cần kiểm tra và cập nhật Chung kết
    scheduleFinalsAuto(true); // Cập nhật lại lịch chung kết dựa trên Bán kết
    renderFinals();
    renderFinalResults();
    renderOverview();

    stateChanged = true;
    saveToGitHub();
}


/**
 * Tính toán và cập nhật bảng xếp hạng Vòng Bảng cho cả Bảng A và B.
 * Cập nhật lại state.tableA và state.tableB
 */
function tinhVaCapNhatXepHang() {
    state.tableA = tinhXepHang(state.mixedTeams, state.matchesA, 'A');
    state.tableB = tinhXepHang(state.maleTeams, state.matchesB, 'B');
    renderRankingTables();
}

/**
 * Hàm tính toán xếp hạng cho một nhóm
 * @param {Array<string>} teams - Danh sách tên đội
 * @param {Array<object>} matches - Danh sách trận đấu
 * @param {string} groupName - Tên bảng (A hoặc B)
 * @returns {Array<object>} - Bảng xếp hạng đã sắp xếp
 */
function tinhXepHang(teams, matches, groupName) {
    let stats = {};

    // 1. Khởi tạo thống kê
    teams.forEach(teamName => {
        stats[teamName] = { 
            team: teamName, 
            W: 0, L: 0, 
            PF: 0, PA: 0, // Points For (Score For), Points Against (Score Against)
            matchCount: 0 
        };
    });

    // 2. Tổng hợp kết quả trận đấu
    matches.forEach(match => {
        if (match.winner) { // Chỉ tính những trận đã hoàn thành
            const winnerStats = stats[match.winner];
            const loserStats = stats[match.loser];
            
            // Xử lý điểm của trận đấu
            let scoreW, scoreL;
            if (match.teamA === match.winner) {
                scoreW = match.scoreA;
                scoreL = match.scoreB;
            } else {
                scoreW = match.scoreB;
                scoreL = match.scoreA;
            }

            if (winnerStats && loserStats) {
                winnerStats.W += 1;
                winnerStats.PF += scoreW;
                winnerStats.PA += scoreL;
                winnerStats.matchCount += 1;

                loserStats.L += 1;
                loserStats.PF += scoreL;
                loserStats.PA += scoreW;
                loserStats.matchCount += 1;
            }
        }
    });

    // Chuyển đối tượng thống kê thành mảng
    let ranking = Object.values(stats);
    
    /**
     * HÀM SO SÁNH TIÊU CHUẨN MỚI: W > Đối đầu > Hiệu số điểm (PF-PA) > Tổng điểm ghi (PF) > Random
     * @param {object} a - Đội A
     * @param {object} b - Đội B
     */
    function compareTeams(a, b) {
        // Ưu tiên 1: Số trận thắng (W)
        if (a.W !== b.W) {
            return b.W - a.W; // Giảm dần (Đội nhiều thắng hơn xếp trên)
        }

        // Ưu tiên 2: Đối đầu trực tiếp (H2H) 
        const h2hMatch = matches.find(m => 
            (m.teamA === a.team && m.teamB === b.team) || 
            (m.teamB === a.team && m.teamA === b.team)
        );

        if (h2hMatch && h2hMatch.winner) {
            if (h2hMatch.winner === a.team) {
                return -1; // a thắng b, a xếp trên b
            } else if (h2hMatch.winner === b.team) {
                return 1; // b thắng a, b xếp trên a
            }
        }


        // Ưu tiên 3: Hiệu số điểm (PF - PA)
        const diffA = a.PF - a.PA;
        const diffB = b.PF - b.PA;
        if (diffA !== diffB) {
            return b.PF - b.PA - (a.PF - a.PA); // Giảm dần (Hiệu số cao hơn xếp trên)
        }

        // Ưu tiên 4: Tổng điểm ghi được (PF)
        if (a.PF !== b.PF) {
            return b.PF - a.PF; // Giảm dần (Điểm ghi cao hơn xếp trên)
        }
        
        // Ưu tiên 5: Bốc thăm (Random) - Nếu tất cả vẫn bằng nhau
        return Math.random() - 0.5; 
    }

    // 4. Sắp xếp
    ranking.sort((a, b) => compareTeams(a, b));

    // Thêm Rank và xử lý Tiebreaker Info
    ranking.forEach((team, index) => {
        team.rank = index + 1;
        team.tiebreakerInfo = ''; 
        
        // Chỉ cần so sánh với đội liền kề trước đó
        if (index > 0) {
            const prevTeam = ranking[index - 1];
            
            // Kiểm tra nếu các tiêu chí xếp hạng chính bằng nhau
            if (compareTeams(team, prevTeam) === 0) {
                team.tiebreakerInfo = 'Tie';
                if (!prevTeam.tiebreakerInfo) {
                    prevTeam.tiebreakerInfo = 'Tie';
                }
            }
        }
        
    });

    return ranking;
}

/**
 * Hiển thị bảng xếp hạng chi tiết (Tab Kết quả Chung cuộc)
 */
function renderRankingTables() {
    const container = document.getElementById('rankingTables');
    
    const tableHTML = (ranking, title) => {
        if (!ranking || ranking.length === 0) {
            return `<div>
                <h6>${title}</h6>
                <div class="alert alert-warning">Chưa có dữ liệu xếp hạng hoặc danh sách đội trống.</div>
            </div>`;
        }
        
        let html = `
            <div>
            <h6 class="mb-3">${title}</h6>
            <div class="table-responsive">
            <table class="table table-striped table-hover table-sm">
                <thead>
                    <tr>
                        <th style="width: 5%;">#</th>
                        <th>Đội</th>
                        <th class="text-center">W</th>
                        <th class="text-center">L</th>
                        <th class="text-center">HS</th>
                        <th class="text-center">PF</th>
                    </tr>
                </thead>
                <tbody>
        `;
        
        ranking.forEach((team, index) => {
            const diff = team.PF - team.PA;
            const rankClass = (index < 2) ? 'table-success' : ''; // Top 2 được vào bán kết
            const rankSymbol = team.rank; // Dùng rank đã tính
            
            html += `
                <tr class="${rankClass}">
                    <td class="fw-bold">${rankSymbol} ${team.tiebreakerInfo ? '*' : ''}</td>
                    <td>${team.team}</td>
                    <td class="text-center">${team.W}</td>
                    <td class="text-center">${team.L}</td>
                    <td class="text-center">${diff > 0 ? '+' : ''}${diff}</td>
                    <td class="text-center">${team.PF}</td>
                </tr>
            `;
        });
        
        html += `
                </tbody>
            </table>
            </div>
            ${ranking.some(t => t.tiebreakerInfo === 'Tie') ? '<p class="small text-muted">* Các đội đồng hạng được xếp bằng tiêu chí Đối đầu trực tiếp hoặc Bốc thăm.</p>' : ''}
            </div>
        `;
        return html;
    };
    
    container.innerHTML = 
        tableHTML(state.tableA, 'Bảng A (Nam - Nữ)') +
        tableHTML(state.tableB, 'Bảng B (Nam)');
}


// --- Logic Vòng Chung kết ---

/**
 * Cập nhật lịch Vòng Chung kết (Bán kết và Chung kết) dựa trên kết quả Vòng Bảng.
 * @param {boolean} onlyFinal - Chỉ cập nhật trận chung kết dựa trên bán kết (dùng khi nhập điểm bán kết)
 */
function scheduleFinalsAuto(onlyFinal = false) {
    tinhVaCapNhatXepHang(); // Đảm bảo bảng xếp hạng là mới nhất

    // 1. Cập nhật Bán kết (chỉ khi chưa có đội được gán)
    if (!onlyFinal) {
        if (state.tableA.length >= 2) {
            state.semifinals[0].teamA = state.tableA[0].team; // Nhất A
            state.semifinals[0].teamB = state.tableA[1].team; // Nhì A
        } else {
             state.semifinals[0].teamA = 'Nhất A';
             state.semifinals[0].teamB = 'Nhì A';
        }

        if (state.tableB.length >= 2) {
            state.semifinals[1].teamA = state.tableB[0].team; // Nhất B
            state.semifinals[1].teamB = state.tableB[1].team; // Nhì B
        } else {
             state.semifinals[1].teamA = 'Nhất B';
             state.semifinals[1].teamB = 'Nhì B';
        }
    }

    // 2. Cập nhật Chung kết
    const winnerSF1 = state.semifinals[0].winner;
    const winnerSF2 = state.semifinals[1].winner;

    if (winnerSF1) {
        state.final.teamA = winnerSF1; // Thắng SF1
    } else {
        state.final.teamA = 'Thắng SF1';
    }

    if (winnerSF2) {
        state.final.teamB = winnerSF2; // Thắng SF2
    } else {
        state.final.teamB = 'Thắng SF2';
    }
    
    // Nếu các đội đã được gán tên thực tế, nhưng điểm số vòng bán kết bị xóa (winner = null), 
    // thì điểm số chung kết phải được reset.
    if (!winnerSF1 || !winnerSF2) {
        state.final.scoreA = null;
        state.final.scoreB = null;
        state.final.winner = null;
        state.final.runnerUp = null;
    }
    
    renderFinals();
    renderFinalResults();
    stateChanged = true;
    if (!onlyFinal) {
        saveToGitHub();
        showModal('Cập nhật Vòng Chung kết', 'Đã gán **Nhất/Nhì Bảng A** vào Bán kết 1 và **Nhất/Nhì Bảng B** vào Bán kết 2.');
    }
}

/**
 * Hiển thị lịch thi đấu Vòng Chung kết
 */
function renderFinals() {
    const renderMatch = (match, isFinal = false) => {
        const id = match.id;
        const winnerClass = 'winner';
        const loserClass = 'loser';
        
        const teamA_Class = match.winner === match.teamA ? winnerClass : (match.loser === match.teamA ? loserClass : '');
        const teamB_Class = match.winner === match.teamB ? winnerClass : (match.loser === match.teamB ? loserClass : '');

        const readonly = (match.teamA === 'Thắng SF1' || match.teamA === 'Nhất A' || match.teamA === 'Nhất B') ? 'disabled' : ''; // Không cho nhập điểm nếu chưa gán đội

        let matchHtml = `
            <div class="d-flex align-items-center mb-2 p-2 border rounded shadow-sm">
                <div class="col-3 text-muted small">${match.time} (${match.court})</div>
                <div class="col-8">
                    <div class="d-flex align-items-center mb-1">
                        <span class="col-7 text-truncate ${teamA_Class}">${match.teamA}</span>
                        <input type="number" id="score-${id}-A" class="form-control form-control-sm match-score-cell-lg" style="width:50px;" 
                            value="${match.scoreA !== null ? match.scoreA : ''}" min="0" onchange="updateFinalsScore('${id}')" ${readonly}>
                    </div>
                    <div class="d-flex align-items-center">
                        <span class="col-7 text-truncate ${teamB_Class}">${match.teamB}</span>
                        <input type="number" id="score-${id}-B" class="form-control form-control-sm match-score-cell-lg" style="width:50px;"
                            value="${match.scoreB !== null ? match.scoreB : ''}" min="0" onchange="updateFinalsScore('${id}')" ${readonly}>
                    </div>
                </div>
            </div>
        `;
        return matchHtml;
    };
    
    // Bán kết
    const sfHtml = state.semifinals.map(match => renderMatch(match, false)).join('');
    document.getElementById('semifinalMatches').innerHTML = sfHtml || 'Chưa có lịch thi đấu bán kết.';
    
    // Chung kết
    const finalHtml = renderMatch(state.final, true);
    document.getElementById('finalMatch').innerHTML = finalHtml || 'Chưa có lịch thi đấu chung kết.';
}

/**
 * Hiển thị kết quả Chung cuộc (Vô địch, Á quân, Hạng Ba)
 */
function renderFinalResults() {
    // 1. Vô địch & Á quân
    const finalMatch = state.final;
    if (finalMatch.winner) {
        document.getElementById('champion').innerHTML = `🏆 Vô địch: <strong>${finalMatch.winner}</strong>`;
        document.getElementById('runnerUp').innerHTML = `🥈 Á quân: <strong>${finalMatch.runnerUp}</strong>`;
    } else {
        document.getElementById('champion').innerHTML = 'Vô địch: Đang chờ kết quả...';
        document.getElementById('runnerUp').innerHTML = 'Á quân: Đang chờ kết quả...';
    }

    // 2. Hạng Ba Đồng Hạng (Hai đội thua Bán kết)
    const loserSF1 = state.semifinals[0].loser;
    const loserSF2 = state.semifinals[1].loser;
    
    if (loserSF1 && loserSF2) {
        document.getElementById('thirdPlace').innerHTML = `🥉 Hạng Ba Đồng Hạng: <strong>${loserSF1}</strong> và <strong>${loserSF2}</strong>`;
    } else {
        document.getElementById('thirdPlace').innerHTML = 'Hạng Ba Đồng Hạng: Đang chờ kết quả...';
    }
}


// --- Logic Hiển thị Vòng Bảng ---

/**
 * Hàm điều hướng hiển thị lịch thi đấu (Theo Bảng đấu/Theo Sân)
 */
function renderMatchesView() {
    const viewMode = document.getElementById('viewMode').value;
    const container = document.getElementById('matchesViewContent');

    if (viewMode === 'table') {
        container.innerHTML = `
            <h6 id="scheduleAHeader" class="mt-4">Bảng A (Nam - Nữ)</h6><div id="tableMatchesA"></div>
            <h6 class="mt-4">Bảng B (Nam)</h6><div id="tableMatchesB"></div>
        `;
        renderMatchesByTable(state.matchesA, 'tableMatchesA', 'A');
        renderMatchesByTable(state.matchesB, 'tableMatchesB', 'B');
        
    } else if (viewMode === 'court') {
        container.innerHTML = `<div id="courtMatches"></div>`;
        renderMatchesByCourt();
    }
}

/**
 * Render lịch thi đấu theo chế độ Bảng đấu
 * @param {Array<object>} matches - Danh sách trận đấu
 * @param {string} containerId - ID của div chứa kết quả
 * @param {string} group - Tên bảng ('A' hoặc 'B')
 */
function renderMatchesByTable(matches, containerId, group) {
    const container = document.getElementById(containerId);
    if (!matches || matches.length === 0) {
        container.innerHTML = `<div class="alert alert-info">Chưa có lịch thi đấu cho Bảng ${group}.</div>`;
        return;
    }
    
    let html = `
        <div class="table-responsive">
        <table class="table table-striped table-hover table-sm">
            <thead>
                <tr>
                    <th style="width: 5%;">#</th>
                    <th style="width: 12%;">Giờ</th>
                    <th style="width: 10%;">Sân</th>
                    <th style="width: 30%;">Đội A</th>
                    <th style="width: 30%;">Đội B</th>
                    <th class="text-center">Điểm A</th>
                    <th class="text-center">Điểm B</th>
                </tr>
            </thead>
            <tbody>
    `;
    
    matches.forEach((match, index) => {
        const teamA_Class = match.winner === match.teamA ? 'winner' : (match.loser === match.teamA ? 'loser' : '');
        const teamB_Class = match.winner === match.teamB ? 'winner' : (match.loser === match.teamB ? 'loser' : '');
        const matchRowClass = match.winner ? 'table-light' : ''; // Đánh dấu trận đã xong
        
        html += `
            <tr class="${matchRowClass}">
                <td>${match.id}</td>
                <td>${match.time || '-'}</td>
                <td>${match.court || '-'}</td>
                <td class="text-truncate ${teamA_Class}">${match.teamA}</td>
                <td class="text-truncate ${teamB_Class}">${match.teamB}</td>
                <td class="match-score-cell">
                    <input type="number" id="score-${group}-${index}-A" 
                        value="${match.scoreA !== null ? match.scoreA : ''}" 
                        min="0" onchange="updateScore('${group}', ${index})">
                </td>
                <td class="match-score-cell">
                    <input type="number" id="score-${group}-${index}-B" 
                        value="${match.scoreB !== null ? match.scoreB : ''}" 
                        min="0" onchange="updateScore('${group}', ${index})">
                </td>
            </tr>
        `;
    });
    
    html += `
            </tbody>
        </table>
        </div>
    `;
    container.innerHTML = html;
}

/**
 * Render lịch thi đấu theo chế độ Sân thi đấu
 */
function renderMatchesByCourt() {
    const container = document.getElementById('courtMatches');
    const allMatches = [...state.matchesA, ...state.matchesB];
    
    if (allMatches.length === 0) {
        container.innerHTML = `<div class="alert alert-info">Chưa có lịch thi đấu nào được tạo.</div>`;
        return;
    }

    // 1. Nhóm các trận đấu theo Sân
    const matchesByCourt = {};
    state.courts.forEach(court => {
        matchesByCourt[court.name] = { 
            isMixed: court.isMixed, 
            matches: [] 
        };
    });

    allMatches.forEach(match => {
        if (match.court && matchesByCourt[match.court]) {
            matchesByCourt[match.court].matches.push(match);
        }
    });

    // 2. Sắp xếp các trận đấu trong mỗi sân theo Thời gian
    Object.keys(matchesByCourt).forEach(courtName => {
        matchesByCourt[courtName].matches.sort((a, b) => {
            if (!a.time) return 1;
            if (!b.time) return -1;
            return timeToMinutes(a.time) - timeToMinutes(b.time);
        });
    });

    // 3. Tạo HTML
    let finalHtml = '';
    
    // Sắp xếp các sân để hiển thị
    const sortedCourtNames = Object.keys(matchesByCourt).sort(); 

    sortedCourtNames.forEach(courtName => {
        const courtData = matchesByCourt[courtName];
        const matches = courtData.matches;
        
        // Bỏ qua sân không có trận, trừ khi nó có trong cấu hình sân
        const isConfiguredCourt = state.courts.some(c => c.name === courtName);
        if (matches.length === 0 && !isConfiguredCourt) return; 

        const groupType = courtData.isMixed ? 'Bảng A (Nam - Nữ)' : 'Bảng B (Nam)';
        
        finalHtml += `
            <h6 class="mt-4">${courtName} (${groupType})</h6>
            <div class="table-responsive">
            <table class="table table-striped table-hover table-sm">
                <thead>
                    <tr>
                        <th style="width: 5%;">#</th>
                        <th style="width: 15%;">Giờ</th>
                        <th style="width: 25%;">Đội A</th>
                        <th style="width: 25%;">Đội B</th>
                        <th class="text-center">Điểm A</th>
                        <th class="text-center">Điểm B</th>
                    </tr>
                </thead>
                <tbody>
        `;
        
        matches.forEach(match => {
            // Xác định matchIndex và group để dùng trong hàm updateScore
            const group = match.id.startsWith('A') ? 'A' : 'B';
            const matchesArray = group === 'A' ? state.matchesA : state.matchesB;
            const index = matchesArray.findIndex(m => m.id === match.id);

            const teamA_Class = match.winner === match.teamA ? 'winner' : (match.loser === match.teamA ? 'loser' : '');
            const teamB_Class = match.winner === match.teamB ? 'winner' : (match.loser === match.teamB ? 'loser' : '');
            const matchRowClass = match.winner ? 'table-light' : '';
            
            finalHtml += `
                <tr class="${matchRowClass}">
                    <td>${match.id}</td>
                    <td>${match.time || '-'}</td>
                    <td class="text-truncate ${teamA_Class}">${match.teamA}</td>
                    <td class="text-truncate ${teamB_Class}">${match.teamB}</td>
                    <td class="match-score-cell">
                        <input type="number" id="score-${group}-${index}-A" 
                            value="${match.scoreA !== null ? match.scoreA : ''}" 
                            min="0" onchange="updateScore('${group}', ${index})">
                    </td>
                    <td class="match-score-cell">
                        <input type="number" id="score-${group}-${index}-B" 
                            value="${match.scoreB !== null ? match.scoreB : ''}" 
                            min="0" onchange="updateScore('${group}', ${index})">
                    </td>
                </tr>
            `;
        });
        
        finalHtml += `
                </tbody>
            </table>
            </div>
        `;
    });

    container.innerHTML = finalHtml;
}


</script>
</body>
</html>
