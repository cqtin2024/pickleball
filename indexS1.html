<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pickleball Tournament Organizer V10.1</title>
    <style>
        :root {
            --primary-color: #4CAF50; /* Green */
            --secondary-color: #FFC107; /* Amber */
            --background-color: #f4f4f9;
            --text-color: #333;
            --alert-color: #F44336; /* Red */
            --success-color: #2196F3; /* Blue */
            --border-color: #ddd;
        }
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--background-color);
            color: var(--text-color);
        }
        .container {
            width: 95%;
            margin: 20px auto;
            background: white;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            border-radius: 8px;
            min-height: 80vh;
        }
        header {
            background-color: var(--primary-color);
            color: white;
            padding: 10px 20px;
            border-radius: 8px 8px 0 0;
            display: flex;
            align-items: center;
        }
        header img {
            height: 40px;
            margin-right: 15px;
            border-radius: 4px;
        }
        .nav-bar {
            display: flex;
            background-color: #333;
            overflow: hidden;
            border-radius: 0 0 8px 8px;
        }
        .nav-bar button {
            background-color: inherit;
            color: white;
            padding: 14px 20px;
            border: none;
            cursor: pointer;
            transition: 0.3s;
            font-size: 16px;
            flex-grow: 1;
        }
        .nav-bar button:hover:not(.active) {
            background-color: #555;
        }
        .nav-bar button.active {
            background-color: var(--primary-color);
        }
        .tab-content {
            padding: 20px;
        }
        h2 {
            color: var(--primary-color);
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 10px;
            margin-top: 0;
        }
        /* Form & Input styles */
        .input-group {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .input-group input[type="text"],
        .input-group input[type="number"],
        .input-group select {
            width: calc(100% - 12px);
            padding: 8px;
            margin-top: 5px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-sizing: border-box;
        }
        button {
            background-color: var(--primary-color);
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
            margin-right: 10px;
        }
        button:hover {
            background-color: #388E3C; /* Darker green */
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        /* Table styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        table th, table td {
            border: 1px solid var(--border-color);
            padding: 10px;
            text-align: left;
        }
        table th {
            background-color: #eee;
            color: var(--text-color);
        }
        /* Alert/Status styles */
        .alert {
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 4px;
            font-weight: bold;
        }
        .alert-success {
            background-color: #d4edda;
            color: #155724;
            border-color: #c3e6cb;
        }
        .alert-error {
            background-color: #f8d7da;
            color: #721c24;
            border-color: #f5c6cb;
        }
        .court-slot {
            padding: 5px;
            margin: 5px 0;
            border: 1px solid var(--primary-color);
            border-left: 5px solid var(--primary-color);
            border-radius: 4px;
            font-size: 0.9em;
        }
        .court-slot.warning {
            border-left: 5px solid var(--alert-color);
            background-color: #f8d7da;
        }
        /* Knockout Bracket Styling (Simplified for text/table view) */
        .bracket-round {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px dashed var(--border-color);
        }
        .bracket-match {
            margin: 5px 0;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: #f9f9f9;
        }
        .bracket-match.completed {
             background-color: #e0f2f1;
        }
        .team-slot {
            font-weight: bold;
            flex-basis: 45%;
            text-align: center;
        }
        .score-slot {
            font-size: 1.1em;
            color: var(--success-color);
        }
        .alert-time {
            color: var(--alert-color);
            font-weight: bold;
        }
    </style>
</head>
<body>

<div class="container">
    <header>
        <img id="logo-display" src="" alt="Logo" style="display:none;">
        <h1 id="tournament-title">PICKLEBALL TOURNAMENT ORGANIZER</h1>
    </header>
    
    <div class="nav-bar" id="navbar">
        <button onclick="openTab('C')" id="tab-C">C: C·∫§U H√åNH ‚öôÔ∏è</button>
        <button onclick="openTab('D')" id="tab-D">D: NG∆Ø·ªúI CH∆†I & ƒê·ªòI üë•</button>
        <button onclick="openTab('E')" id="tab-E">E: L·ªäCH THI ƒê·∫§U & TG ‚è∞</button>
        <button onclick="openTab('F')" id="tab-F">F: V√íNG B·∫¢NG üìä</button>
        <button onclick="openTab('G')" id="tab-G">G: V√íNG LO·∫†I üèÜ</button>
        <button onclick="openTab('L')" id="tab-L">L: K·∫æT QU·∫¢ ‚≠ê</button>
        <button onclick="openTab('H')" id="tab-H">H: TEST üß™</button>
    </div>

    <div id="C" class="tab-content">
        <h2>C: C·∫§U H√åNH ‚öôÔ∏è</h2>
        <div class="input-group">
            <label>C1a: T√™n Gi·∫£i ƒê·∫•u</label>
            <input type="text" id="config-name" value="Gi·∫£i Pickleball Demo M·ªü R·ªông">
            <label>C1a: Upload Logo (Base64)</label>
            <input type="file" id="config-logo" accept="image/*" onchange="handleLogoUpload(this)">
            <label>C1f: Ch·∫ø ƒë·ªô Trao Gi·∫£i Nh·∫•t ƒê·ªôc L·∫≠p (2 H·∫°ng)</label>
            <input type="checkbox" id="config-double-champion"> (B·∫≠t n·∫øu c√≥ H·∫°ng A/H·∫°ng B ri√™ng bi·ªát)
        </div>
        
        <h3>C2: Qu·∫£n L√Ω TH·ªÇ TH·ª®C V√íNG ƒê·∫§U</h3>
        <div class="input-group">
            <label>C2a0: Th·ªÉ th·ª©c V√≤ng Lo·∫°i (Knockout)</label>
            <select id="config-elimination-type">
                <option value="SINGLE">Single Elimination (Lo·∫°i ƒê∆°n)</option>
                <option value="DOUBLE">Double Elimination (Lo·∫°i K√©p - Nh√°nh Thua)</option>
            </select>
            <label>C2a1i: Quy t·∫Øc ƒêi·ªÉm Ch·∫°m Cao Nh·∫•t (Cap Score)</label>
            <input type="number" id="config-cap-score" value="13" min="11" placeholder="V√≠ d·ª•: 13 (Th·∫Øng 11 ƒëi·ªÉm, ƒëi·ªÉm t·ªëi ƒëa 13)">
            <label>C2a1: ƒêi·ªÉm Th·∫Øng m·ªói Set</label>
            <input type="number" id="config-win-score" value="11" min="1" placeholder="V√≠ d·ª•: 11">
        </div>
        <button onclick="saveConfig()">L∆∞u C·∫•u H√¨nh</button>
        <div id="config-status" class="alert alert-success" style="margin-top:15px; display:none;"></div>
    </div>

    <div id="D" class="tab-content" style="display:none;">
        <h2>D: NG∆Ø·ªúI CH∆†I & ƒê·ªòI üë•</h2>
        
        <h3>D2: Qu·∫£n l√Ω ƒê·ªôi/C·∫∑p ƒê·∫•u (Gi·∫£ ƒë·ªãnh m·ªói ƒë·ªôi 2 ng∆∞·ªùi)</h3>
        <button onclick="generateRandomTeams()">D2e: GH√âP C·∫∂P RANDOM (T·∫°o 8 ƒë·ªôi demo)</button>
        <div id="team-list-status" class="alert" style="margin-top:10px; display:none;"></div>

        <table id="teams-table">
            <thead>
                <tr>
                    <th>ID ƒê·ªôi</th>
                    <th>T√™n ƒê·ªôi</th>
                    <th>H·∫°ng (D2c)</th>
                    <th>Tr·∫°ng th√°i (D2a)</th>
                    <th>Nh√≥m/B·∫£ng (D3)</th>
                </tr>
            </thead>
            <tbody>
                </tbody>
        </table>

        <h3>D3: Ph√¢n B·∫£ng T·ª± ƒê·ªông</h3>
        <button onclick="generateGroups()">D3: PH√ÇN B·∫¢NG T·ª∞ ƒê·ªòNG</button>
        <p>*(Ch·∫°y sau khi c√≥ danh s√°ch ƒë·ªôi. C·∫ßn thi·∫øt cho V√≤ng B·∫£ng v√† L·∫≠p l·ªãch t·ªëi ∆∞u).*</p>
    </div>

    <div id="E" class="tab-content" style="display:none;">
        <h2>E: L·ªäCH THI ƒê·∫§U & TG ‚è∞ (Planning Engine)</h2>
        
        <h3>E1: C·∫•u H√¨nh Th·ªùi Gian & S√¢n ƒê·∫•u</h3>
        <div class="input-group">
            <label>Gi·ªù B·∫Øt ƒê·∫ßu (V√≠ d·ª•: 08:00)</label>
            <input type="time" id="schedule-start-time" value="08:00">
            <label>Th·ªùi L∆∞·ª£ng TB m·ªói Tr·∫≠n (Ph√∫t)</label>
            <input type="number" id="schedule-duration" value="30" min="5">
            <label>E1a: S·ªê L∆Ø·ª¢NG S√ÇN ƒê·∫§U</label>
            <input type="number" id="schedule-courts" value="2" min="1">
        </div>
        
        <h3>E2: Qu·∫£n L√Ω L·ªäCH TR√åNH T·ªîNG H·ª¢P</h3>
        <button onclick="generateSchedule()">E2a: T·∫†O L·ªäCH TR√åNH T·ªêI ∆ØU</button>
        <button onclick="showScheduleSummary()">E2c: XEM T√ìM T·∫ÆT L·ªäCH</button>
        <div id="schedule-status" class="alert" style="margin-top:15px; display:none;"></div>

        <div id="schedule-viewer" style="margin-top: 20px;">
            <h4>E2b: B·∫£ng L·ªãch Chi Ti·∫øt (T·∫•t c·∫£ tr·∫≠n ƒë·∫•u)</h4>
            <table id="schedule-table">
                <thead>
                    <tr>
                        <th>ID</th>
                        <th>V√≤ng</th>
                        <th>Th·ªùi Gian D·ª± Ki·∫øn</th>
                        <th>S√¢n</th>
                        <th>Tr·∫≠n ƒê·∫•u</th>
                        <th>Th·ªùi Gian Ngh·ªâ (C·∫£nh b√°o)</th>
                    </tr>
                </thead>
                <tbody>
                    </tbody>
            </table>
        </div>
    </div>

    <div id="F" class="tab-content" style="display:none;">
        <h2>F: V√íNG B·∫¢NG üìä (Execution & Monitoring)</h2>
        
        <h3>F2: X√¢y D·ª±ng Tr·∫≠n ƒê·∫•u V√≤ng B·∫£ng</h3>
        <button onclick="generateGroupMatches()">F2a: T·∫†O DANH S√ÅCH TR·∫¨N ƒê·∫§U V√íNG B·∫¢NG</button>
        
        <h3>F3: Nh·∫≠p K·∫øt Qu·∫£ & Gi√°m S√°t</h3>
        <div id="f-match-list">
            </div>
        
        <h3>F4: B·∫£ng X·∫øp H·∫°ng</h3>
        <div id="f-standings">
            </div>
    </div>

    <div id="G" class="tab-content" style="display:none;">
        <h2>G: V√íNG LO·∫†I üèÜ</h2>
        
        <h3>G1: X√¢y D·ª±ng C√¢y ƒê·∫•u Lo·∫°i T·ª∞ ƒê·ªòNG</h3>
        <button onclick="generateKnockoutBrackets()">G1: T·∫†O C√ÇY ƒê·∫§U LO·∫†I (D√πng k·∫øt qu·∫£ F4)</button>
        <div id="bracket-status" class="alert" style="margin-top:15px; display:none;"></div>

        <h3>G2: Theo D√µi & C·∫≠p Nh·∫≠t T·ª± ƒê·ªông</h3>
        <div id="knockout-bracket">
            </div>
    </div>

    <div id="L" class="tab-content" style="display:none;">
        <h2>L: K·∫æT QU·∫¢ ‚≠ê (Public Display)</h2>
        <h3>L1: ƒêANG DI·ªÑN RA (LIVE) / S·∫ÆP DI·ªÑN RA (L2)</h3>
        <div id="live-upcoming-matches">
            </div>

        <h3>L5: X·∫æP H·∫†NG CHUNG CU·ªòC</h3>
        <div id="final-standings">
            </div>
    </div>
    
    <div id="H" class="tab-content" style="display:none;">
        <h2>H: TEST üß™ (Utility)</h2>
        <div class="input-group">
            <h3>H1b: Simulate Results</h3>
            <button onclick="simulateGroupResults()">GI·∫¢ L·∫¨P K·∫æT QU·∫¢ V√íNG B·∫¢NG (Ch·∫°y F3)</button>
        </div>
        
        <div class="input-group">
            <h3>H2: Reset D·ªØ Li·ªáu (CRITICAL)</h3>
            <button onclick="hardReset()">H2a: X√ìA T·∫§T C·∫¢ D·ªÆ LI·ªÜU (HARD RESET)</button>
            <button onclick="softReset()">H2b: X√ìA PH√ÇN B·∫¢NG, L·ªäCH TR√åNH & K·∫æT QU·∫¢ (SOFT RESET)</button>
        </div>
    </div>

</div>

<script>
    // --- GLOBAL STATE ---
    let tournamentData = {
        config: {
            name: 'Gi·∫£i Pickleball Demo M·ªü R·ªông',
            logoUrl: '',
            eliminationType: 'SINGLE', // SINGLE or DOUBLE
            doubleChampion: false,
            capScore: 13,
            winScore: 11
        },
        teams: [],
        scheduleParams: {
            startTime: '08:00',
            duration: 30, // minutes
            numCourts: 2
        },
        matches: [], // All matches (Group & Knockout)
        groups: {}, // { A: [...teams], B: [...teams] }
    };

    // --- UTILITIES ---

    const generateId = (prefix = '') => prefix + Math.random().toString(36).substring(2, 9);
    const getTeam = (teamId) => tournamentData.teams.find(t => t.id === teamId);

    // Format time (e.g., "08:00")
    const formatTime = (time) => {
        const [hours, minutes] = time.split(':').map(Number);
        const date = new Date();
        date.setHours(hours, minutes, 0, 0);
        return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
    };

    const addMinutes = (time, mins) => {
        const [hours, minutes] = time.split(':').map(Number);
        const date = new Date();
        date.setHours(hours, minutes, 0, 0);
        date.setMinutes(date.getMinutes() + mins);
        return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
    };

    // --- TAB NAVIGATION ---
    function openTab(tabId) {
        const contents = document.querySelectorAll('.tab-content');
        contents.forEach(content => content.style.display = 'none');

        const buttons = document.querySelectorAll('.nav-bar button');
        buttons.forEach(button => button.classList.remove('active'));

        document.getElementById(tabId).style.display = 'block';
        document.getElementById(`tab-${tabId}`).classList.add('active');

        // Render content when tab is opened
        if (tabId === 'D') renderTeamTable();
        if (tabId === 'E') renderScheduleTable();
        if (tabId === 'F') renderGroupMatchList();
        if (tabId === 'G') renderKnockoutBracket();
        if (tabId === 'L') renderLiveUpcomingMatches();
    }
    document.addEventListener('DOMContentLoaded', () => {
        openTab('C'); // Start on Config tab
        document.getElementById('tournament-title').innerText = tournamentData.config.name;
    });

    // --- TAB C: C·∫§U H√åNH ---
    function handleLogoUpload(input) {
        const file = input.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                tournamentData.config.logoUrl = e.target.result;
                document.getElementById('logo-display').src = e.target.result;
                document.getElementById('logo-display').style.display = 'block';
            };
            reader.readAsDataURL(file);
        }
    }

    function saveConfig() {
        tournamentData.config.name = document.getElementById('config-name').value;
        tournamentData.config.eliminationType = document.getElementById('config-elimination-type').value;
        tournamentData.config.doubleChampion = document.getElementById('config-double-champion').checked;
        tournamentData.config.capScore = parseInt(document.getElementById('config-cap-score').value) || 13;
        tournamentData.config.winScore = parseInt(document.getElementById('config-win-score').value) || 11;

        document.getElementById('tournament-title').innerText = tournamentData.config.name;
        document.getElementById('config-status').innerText = 'L∆∞u c·∫•u h√¨nh th√†nh c√¥ng!';
        document.getElementById('config-status').style.display = 'block';
        setTimeout(() => document.getElementById('config-status').style.display = 'none', 3000);
    }

    // --- TAB D: NG∆Ø·ªúI CH∆†I & ƒê·ªòI ---
    function generateRandomTeams() {
        const numTeams = 8;
        tournamentData.teams = [];
        for (let i = 1; i <= numTeams; i++) {
            tournamentData.teams.push({
                id: generateId('T'),
                name: `ƒê·ªôi ${i}`,
                category: i % 2 === 0 ? 'A' : 'B', // D2c: Ph√¢n h·∫°ng A/B
                status: 'OFFICIAL', // D2a
                groupId: null,
                players: [{ name: `Player ${i}-1` }, { name: `Player ${i}-2` }]
            });
        }
        renderTeamTable();
        const statusEl = document.getElementById('team-list-status');
        statusEl.innerText = `ƒê√£ t·∫°o ${numTeams} ƒë·ªôi demo th√†nh c√¥ng!`;
        statusEl.className = 'alert alert-success';
        statusEl.style.display = 'block';
    }

    function renderTeamTable() {
        const tbody = document.getElementById('teams-table').getElementsByTagName('tbody')[0];
        tbody.innerHTML = '';
        tournamentData.teams.forEach(team => {
            const row = tbody.insertRow();
            row.insertCell().innerText = team.id;
            row.insertCell().innerText = team.name;
            row.insertCell().innerText = team.category;
            row.insertCell().innerText = team.status;
            row.insertCell().innerText = team.groupId || 'Ch∆∞a ph√¢n b·∫£ng';
        });
    }

    // D3: Ph√¢n B·∫£ng T·ª± ƒê·ªông
    function generateGroups() {
        const officialTeams = tournamentData.teams.filter(t => t.status === 'OFFICIAL');
        if (officialTeams.length === 0) {
            alert('Ch∆∞a c√≥ ƒë·ªôi thi ƒë·∫•u ch√≠nh th·ª©c.');
            return;
        }

        const numGroups = 4; // Hardcode 4 groups for simplicity (A, B, C, D)
        tournamentData.groups = { A: [], B: [], C: [], D: [] };
        const groupKeys = Object.keys(tournamentData.groups);

        // Simple Round Robin Distribution
        officialTeams.forEach((team, index) => {
            const groupId = groupKeys[index % numGroups];
            team.groupId = groupId;
            tournamentData.groups[groupId].push(team.id);
        });

        renderTeamTable();
        alert(`ƒê√£ ph√¢n ${officialTeams.length} ƒë·ªôi v√†o ${numGroups} b·∫£ng th√†nh c√¥ng.`);
    }

    // --- TAB E: L·ªäCH THI ƒê·∫§U & TG ---
    // E2a: H√†m generateSchedule() - Thu·∫≠t to√°n T·ªëi ∆∞u
    function generateSchedule() {
        if (tournamentData.matches.length === 0) {
            alert('Vui l√≤ng t·∫°o danh s√°ch tr·∫≠n ƒë·∫•u V√≤ng B·∫£ng (Tab F) v√†/ho·∫∑c V√≤ng Lo·∫°i (Tab G) tr∆∞·ªõc.');
            return;
        }

        const params = tournamentData.scheduleParams;
        const numCourts = params.numCourts;
        let currentTime = params.startTime;
        let teamsSchedule = {}; // { teamId: lastEndTime }
        let courtFreeTime = Array(numCourts).fill(params.startTime); // [Court1Free, Court2Free, ...]
        
        // 1. Reset all schedule fields
        tournamentData.matches.forEach(match => {
            match.scheduledTime = null;
            match.courtId = null;
            match.timeWarning = false;
        });

        // 2. Sort matches (e.g., by round, then randomly within round)
        const matchesToSchedule = tournamentData.matches.filter(m => m.status === 'SCHEDULED' || !m.status).sort((a, b) => {
            // Priority: Group matches first, then Knockout
            const roundA = a.roundId.startsWith('Group') ? 0 : 1;
            const roundB = b.roundId.startsWith('Group') ? 0 : 1;
            return roundA - roundB;
        });

        matchesToSchedule.forEach(match => {
            const teamAId = match.teamAId;
            const teamBId = match.teamBId;

            let earliestCourtTime = '23:59';
            let bestCourtIndex = -1;

            // Find the earliest free court
            courtFreeTime.forEach((freeTime, index) => {
                if (freeTime < earliestCourtTime) {
                    earliestCourtTime = freeTime;
                    bestCourtIndex = index;
                }
            });

            let scheduleTime = earliestCourtTime;
            let timeWarning = false;

            // 3. Logic Gi·∫£m ƒê·∫•u Li√™n T·ª•c (E2aiii)
            const checkTeamRestTime = (teamId, lastEndTime) => {
                if (lastEndTime) {
                    // Check if current match start time is too close to last match end time
                    const lastEnd = new Date(`2000/01/01 ${lastEndTime}`);
                    const currentStart = new Date(`2000/01/01 ${scheduleTime}`);
                    
                    // Convert to minutes difference
                    const diffInMins = (currentStart - lastEnd) / (1000 * 60); 

                    if (diffInMins < params.duration) {
                        // Less than match duration rest time, force 5 min rest (E2aiii)
                        scheduleTime = addMinutes(lastEndTime, 5);
                        return true; // Warning needed
                    }
                }
                return false;
            };

            // Check Team A
            if (teamAId && teamsSchedule[teamAId]) {
                 timeWarning = checkTeamRestTime(teamAId, teamsSchedule[teamAId]) || timeWarning;
            }
            // Check Team B
            if (teamBId && teamsSchedule[teamBId]) {
                 timeWarning = checkTeamRestTime(teamBId, teamsSchedule[teamBId]) || timeWarning;
            }
            
            // Recalculate match end time based on final scheduleTime
            const matchEndTime = addMinutes(scheduleTime, params.duration);

            // Update schedule
            match.scheduledTime = scheduleTime;
            match.courtId = bestCourtIndex + 1;
            match.timeWarning = timeWarning;

            // Update court free time (Court is free only after this match ends)
            courtFreeTime[bestCourtIndex] = matchEndTime;
            
            // Update teams last end time
            if (teamAId) teamsSchedule[teamAId] = matchEndTime;
            if (teamBId) teamsSchedule[teamBId] = matchEndTime;
        });

        renderScheduleTable();
        const statusEl = document.getElementById('schedule-status');
        statusEl.innerText = `ƒê√£ t·∫°o ${matchesToSchedule.length} l·ªãch tr√¨nh t·ªëi ∆∞u tr√™n ${numCourts} s√¢n.`;
        statusEl.className = 'alert alert-success';
        statusEl.style.display = 'block';
    }

    function renderScheduleTable() {
        const tbody = document.getElementById('schedule-table').getElementsByTagName('tbody')[0];
        tbody.innerHTML = '';
        
        const sortedMatches = tournamentData.matches.sort((a, b) => {
             // Sort by scheduled time
            if (!a.scheduledTime) return 1;
            if (!b.scheduledTime) return -1;
            if (a.scheduledTime === b.scheduledTime) return a.courtId - b.courtId;
            return a.scheduledTime.localeCompare(b.scheduledTime);
        });

        sortedMatches.forEach(match => {
            const row = tbody.insertRow();
            const teamA = getTeam(match.teamAId)?.name || 'TBD';
            const teamB = getTeam(match.teamBId)?.name || 'TBD';

            row.insertCell().innerText = match.id;
            row.insertCell().innerText = match.roundId;
            row.insertCell().innerText = match.scheduledTime || 'Ch∆∞a x·∫øp';
            row.insertCell().innerText = match.courtId ? `S√¢n ${match.courtId}` : '-';
            row.insertCell().innerHTML = `<strong>${teamA}</strong> vs <strong>${teamB}</strong>`;
            
            const warningCell = row.insertCell();
            if (match.timeWarning) {
                warningCell.innerHTML = `<span class="alert-time">‚ö†Ô∏è 5 ph√∫t ngh·ªâ ƒë∆∞·ª£c th√™m</span>`;
            } else {
                warningCell.innerText = '-';
            }
        });
    }

    // E2c: Xem T√≥m T·∫Øt L·ªãch (Simplified Text View)
    function showScheduleSummary() {
        let summary = '--- T√≥m T·∫Øt L·ªãch Tr√¨nh (Gi·ªù x S√¢n) ---\n';
        const sortedMatches = tournamentData.matches.filter(m => m.scheduledTime).sort((a, b) => a.scheduledTime.localeCompare(b.scheduledTime));
        
        let displayMap = {}; // { time: { courtId: match } }

        sortedMatches.forEach(match => {
            if (!displayMap[match.scheduledTime]) {
                displayMap[match.scheduledTime] = {};
            }
            const teamA = getTeam(match.teamAId)?.name || 'TBD';
            const teamB = getTeam(match.teamBId)?.name || 'TBD';
            displayMap[match.scheduledTime][match.courtId] = `${teamA} vs ${teamB} (${match.roundId})`;
        });

        for (const time in displayMap) {
            summary += `\n‚è∞ ${time}:`;
            for (let i = 1; i <= tournamentData.scheduleParams.numCourts; i++) {
                summary += ` | S√¢n ${i}: ${displayMap[time][i] || 'TR·ªêNG'}`;
            }
        }

        alert(summary);
    }

    // --- TAB F: V√íNG B·∫¢NG ---
    // F2a: T·∫°o Danh S√°ch Tr·∫≠n ƒê·∫•u V√≤ng B·∫£ng
    function generateGroupMatches() {
        tournamentData.matches = tournamentData.matches.filter(m => !m.roundId.startsWith('Group')); // Keep Knockout if exists
        const matches = [];
        
        for (const groupId in tournamentData.groups) {
            const groupTeams = tournamentData.groups[groupId];
            for (let i = 0; i < groupTeams.length; i++) {
                for (let j = i + 1; j < groupTeams.length; j++) {
                    matches.push({
                        id: generateId('M'),
                        roundId: `Group ${groupId}`,
                        teamAId: groupTeams[i],
                        teamBId: groupTeams[j],
                        score: { A: 0, B: 0, sets: [] },
                        winnerId: null,
                        status: 'SCHEDULED',
                        scheduledTime: null,
                        courtId: null,
                        actualStartTime: null
                    });
                }
            }
        }
        tournamentData.matches = [...matches, ...tournamentData.matches]; // Add group matches at the beginning
        renderGroupMatchList();
        alert(`ƒê√£ t·∫°o ${matches.length} tr·∫≠n ƒë·∫•u V√≤ng B·∫£ng.`);
    }

    // F3: Render Match List for Scoring
    function renderGroupMatchList() {
        const matchListEl = document.getElementById('f-match-list');
        matchListEl.innerHTML = '';
        const groupMatches = tournamentData.matches.filter(m => m.roundId.startsWith('Group'));

        if (groupMatches.length === 0) {
            matchListEl.innerHTML = '<p>Ch∆∞a c√≥ tr·∫≠n ƒë·∫•u V√≤ng B·∫£ng. Vui l√≤ng t·∫°o (F2a).</p>';
            return;
        }
        
        let html = '<table><thead><tr><th>Tr·∫≠n</th><th>Th·ªùi gian/S√¢n</th><th>T·ªâ s·ªë (Set 1)</th><th>H√†nh ƒë·ªông</th></tr></thead><tbody>';
        
        groupMatches.forEach(match => {
            const teamA = getTeam(match.teamAId)?.name || 'TBD';
            const teamB = getTeam(match.teamBId)?.name || 'TBD';
            const timeInfo = match.scheduledTime ? `${match.scheduledTime} / S√¢n ${match.courtId}` : 'Ch∆∞a x·∫øp l·ªãch';
            const scoreDisplay = match.winnerId ? `WIN: ${getTeam(match.winnerId)?.name}` : 'ƒêang ch·ªù';

            html += `
                <tr>
                    <td>${match.roundId}: <strong>${teamA} vs ${teamB}</strong></td>
                    <td>${timeInfo}</td>
                    <td><input type="number" id="score-A-${match.id}" value="0" style="width:50px"> : <input type="number" id="score-B-${match.id}" value="0" style="width:50px"></td>
                    <td>
                        <button onclick="recordGroupScore('${match.id}')" ${match.winnerId ? 'disabled' : ''}>Nh·∫≠p ƒëi·ªÉm</button>
                    </td>
                </tr>
            `;
        });
        html += '</tbody></table>';
        matchListEl.innerHTML = html;
        renderGroupStandings();
    }

    // F3: Record Score & F4: Update Standings
    function recordGroupScore(matchId) {
        const match = tournamentData.matches.find(m => m.id === matchId);
        if (!match || match.winnerId) return;

        const scoreA = parseInt(document.getElementById(`score-A-${matchId}`).value) || 0;
        const scoreB = parseInt(document.getElementById(`score-B-${matchId}`).value) || 0;
        
        const config = tournamentData.config;
        const winScore = config.winScore;
        const capScore = config.capScore;

        let winnerId = null;
        if (scoreA >= winScore && (scoreA - scoreB) >= 2 || scoreA >= capScore) {
            winnerId = match.teamAId;
        } else if (scoreB >= winScore && (scoreB - scoreA) >= 2 || scoreB >= capScore) {
            winnerId = match.teamBId;
        } else {
            alert('ƒêi·ªÉm ch∆∞a ƒë·ªß ƒëi·ªÅu ki·ªán th·∫Øng (Ph·∫£i c√°ch bi·ªát 2 ƒëi·ªÉm ho·∫∑c ƒë·∫°t Cap Score).');
            return;
        }

        match.score.sets = [{ scoreA, scoreB }]; // Simplified to one set
        match.score.A = scoreA;
        match.score.B = scoreB;
        match.winnerId = winnerId;
        match.loserId = (winnerId === match.teamAId) ? match.teamBId : match.teamAId;
        match.status = 'COMPLETED';
        match.actualStartTime = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
        
        // F3a: Simple Time Alert (Check if actual start time is way off scheduled time)
        if (match.scheduledTime) {
             const schTime = new Date(`2000/01/01 ${match.scheduledTime}`);
             const actTime = new Date(`2000/01/01 ${match.actualStartTime}`);
             const diffInMins = Math.abs((actTime - schTime) / (1000 * 60));
             if (diffInMins > 10) {
                 alert(`‚ö†Ô∏è C·∫£nh b√°o l·ªách l·ªãch: Tr·∫≠n ${match.id} b·∫Øt ƒë·∫ßu ch·∫≠m/s·ªõm ${Math.round(diffInMins)} ph√∫t so v·ªõi d·ª± ki·∫øn!`);
             }
        }


        // F4: Update Standings
        renderGroupStandings();
        renderGroupMatchList(); // Re-render to disable button
    }

    function renderGroupStandings() {
        const standingsEl = document.getElementById('f-standings');
        standingsEl.innerHTML = '';
        
        for (const groupId in tournamentData.groups) {
            const teamStats = {}; // { teamId: { P: 0, W: 0, L: 0, PF: 0, PA: 0, Diff: 0 } }
            tournamentData.groups[groupId].forEach(teamId => {
                teamStats[teamId] = { P: 0, W: 0, L: 0, PF: 0, PA: 0, Diff: 0, teamName: getTeam(teamId).name, teamId: teamId };
            });

            const groupMatches = tournamentData.matches.filter(m => m.roundId === `Group ${groupId}` && m.status === 'COMPLETED');
            
            groupMatches.forEach(match => {
                const statA = teamStats[match.teamAId];
                const statB = teamStats[match.teamBId];

                statA.P++; statB.P++;
                statA.PF += match.score.A; statA.PA += match.score.B;
                statB.PF += match.score.B; statB.PA += match.score.A;

                if (match.winnerId === match.teamAId) {
                    statA.W++; statB.L++;
                } else {
                    statA.L++; statB.W++;
                }
            });

            // Final calculation and sorting (W > Diff > PF)
            const sortedStats = Object.values(teamStats).sort((a, b) => {
                if (b.W !== a.W) return b.W - a.W;
                b.Diff = b.PF - b.PA; a.Diff = a.PF - a.PA;
                if (b.Diff !== a.Diff) return b.Diff - a.Diff;
                return b.PF - a.PF;
            });
            
            let html = `<h4>B·∫£ng ${groupId}</h4>`;
            html += '<table style="font-size:0.9em"><thead><tr><th>Rank</th><th>ƒê·ªôi</th><th>W</th><th>L</th><th>PF</th><th>PA</th><th>Diff</th></tr></thead><tbody>';
            
            sortedStats.forEach((stat, index) => {
                html += `<tr><td>${index + 1}</td><td>${stat.teamName}</td><td>${stat.W}</td><td>${stat.L}</td><td>${stat.PF}</td><td>${stat.PA}</td><td>${stat.PF - stat.PA}</td></tr>`;
            });

            html += '</tbody></table>';
            standingsEl.innerHTML += html;
        }
    }

    // --- TAB G: V√íNG LO·∫†I ---
    // G1: Thi·∫øt K·∫ø C√¢y ƒê·∫•u Lo·∫°i
    function generateKnockoutBrackets() {
        const finalStandings = getTeamsToAdvance(); // F4 -> G1 input
        if (finalStandings.length === 0) {
            document.getElementById('bracket-status').innerText = 'Ch∆∞a x√°c ƒë·ªãnh ƒë·ªôi thƒÉng h·∫°ng (C·∫ßn c√≥ k·∫øt qu·∫£ V√≤ng B·∫£ng).';
            document.getElementById('bracket-status').className = 'alert alert-error';
            document.getElementById('bracket-status').style.display = 'block';
            return;
        }

        const bracketMatches = generateBracketMatches(finalStandings, tournamentData.config.eliminationType);
        
        // Remove old knockout matches and add new ones
        tournamentData.matches = tournamentData.matches.filter(m => m.roundId.startsWith('Group')); 
        tournamentData.matches = [...tournamentData.matches, ...bracketMatches];
        
        renderKnockoutBracket();
        document.getElementById('bracket-status').innerText = `ƒê√£ t·∫°o ${bracketMatches.length} tr·∫≠n ƒë·∫•u V√≤ng Lo·∫°i.`;
        document.getElementById('bracket-status').className = 'alert alert-success';
        document.getElementById('bracket-status').style.display = 'block';
    }

    // Helper: Determine teams advancing from F4
    function getTeamsToAdvance() {
        // Simple logic: Top 2 from each group advance
        const advancingTeams = [];
        for (const groupId in tournamentData.groups) {
            const groupMatches = tournamentData.matches.filter(m => m.roundId === `Group ${groupId}` && m.status === 'COMPLETED');
            if (groupMatches.length === 0) return []; // Incomplete data

            const teamStats = {}; 
            tournamentData.groups[groupId].forEach(teamId => {
                teamStats[teamId] = { W: 0, Diff: 0, PF: 0, teamId: teamId };
            });

            // Re-calculate stats for sorting
            groupMatches.forEach(match => {
                const statA = teamStats[match.teamAId];
                const statB = teamStats[match.teamBId];
                if (match.winnerId === match.teamAId) statA.W++; else statB.W++;
                statA.PF += match.score.A; statA.PF -= match.score.B; 
                statB.PF += match.score.B; statB.PF -= match.score.A; 
            });

            const sortedStats = Object.values(teamStats).sort((a, b) => {
                if (b.W !== a.W) return b.W - a.W;
                return b.PF - a.PF;
            });

            advancingTeams.push(...sortedStats.slice(0, 2).map(s => s.teamId)); // Top 2 advance
        }
        return advancingTeams;
    }

    // G1a: Core Bracket Generation (Simplified Single Elimination 8 teams)
    function generateBracketMatches(teamIds, eliminationType) {
        if (teamIds.length === 0) return [];
        
        let matches = [];
        let currentRoundTeams = [...teamIds];

        // Ensure 8 teams for a simple 8-team bracket
        if (currentRoundTeams.length < 8) {
             const numNeeded = 8 - currentRoundTeams.length;
             for(let i=0; i<numNeeded; i++) currentRoundTeams.push(null); // Add TBD slots
        } else if (currentRoundTeams.length > 8) {
             currentRoundTeams = currentRoundTeams.slice(0, 8); // Take top 8
        }
        
        const roundNames = ['T·ª© K·∫øt', 'B√°n K·∫øt', 'Chung K·∫øt'];
        let matchIndex = 0;

        for (let round = 0; round < roundNames.length; round++) {
            const numMatches = currentRoundTeams.length / 2;
            let nextRoundTeams = [];

            for (let i = 0; i < numMatches; i++) {
                matchIndex++;
                const matchId = generateId(`KO${round + 1}M${i + 1}`);
                
                let teamAId = currentRoundTeams[i * 2];
                let teamBId = currentRoundTeams[i * 2 + 1];

                if (round > 0) { // For later rounds, teams are determined by previous winners
                    teamAId = teamAId || `W${matchIndex - numMatches}`; 
                    teamBId = teamBId || `W${matchIndex}`; 
                }
                
                matches.push({
                    id: matchId,
                    roundId: `${roundNames[round]}`,
                    teamAId: teamAId,
                    teamBId: teamBId,
                    score: { A: 0, B: 0, sets: [] },
                    winnerId: null,
                    status: (teamAId && teamBId) && !teamAId.startsWith('W') ? 'SCHEDULED' : 'TBD',
                    nextMatchId: (round < roundNames.length - 1) ? `W${matchIndex + numMatches}` : null,
                    loserMatchId: (eliminationType === 'DOUBLE' && roundNames[round] !== 'Chung K·∫øt') ? `L${matchIndex}` : null
                });

                nextRoundTeams.push(`W${matchId}`);
            }
            currentRoundTeams = nextRoundTeams;
        }

        // Add Double Elimination logic if needed (Simplified)
        if (eliminationType === 'DOUBLE') {
            // For a basic demo, we'll stop here to avoid massive complexity.
            // Full implementation would require generating Loser's Bracket matches (G1c)
        }

        return matches;
    }

    function renderKnockoutBracket() {
        const bracketEl = document.getElementById('knockout-bracket');
        bracketEl.innerHTML = '';
        const knockoutMatches = tournamentData.matches.filter(m => !m.roundId.startsWith('Group'));

        if (knockoutMatches.length === 0) {
            bracketEl.innerHTML = '<p>C√¢y ƒë·∫•u lo·∫°i ch∆∞a ƒë∆∞·ª£c t·∫°o. Vui l√≤ng ch·∫°y G1.</p>';
            return;
        }

        // Group matches by round
        const rounds = knockoutMatches.reduce((acc, match) => {
            acc[match.roundId] = acc[match.roundId] || [];
            acc[match.roundId].push(match);
            return acc;
        }, {});

        for (const roundName in rounds) {
            let html = `<div class="bracket-round"><h4>${roundName}</h4>`;
            rounds[roundName].forEach(match => {
                const teamA = getTeam(match.teamAId)?.name || match.teamAId || 'TBD';
                const teamB = getTeam(match.teamBId)?.name || match.teamBId || 'TBD';
                
                const scoreDisplay = match.winnerId ? `WIN: ${getTeam(match.winnerId)?.name}` : (match.status === 'COMPLETED' ? 'L·ªñI' : 'vs');

                html += `
                    <div class="bracket-match ${match.status === 'COMPLETED' ? 'completed' : ''}">
                        <div class="team-slot">${teamA}</div>
                        <div class="score-slot" id="ko-score-${match.id}">${scoreDisplay}</div>
                        <div class="team-slot">${teamB}</div>
                        <button onclick="recordKnockoutScore('${match.id}')" ${match.winnerId ? 'disabled' : ''}>Nh·∫≠p ƒëi·ªÉm</button>
                    </div>
                `;
            });
            html += `</div>`;
            bracketEl.innerHTML += html;
        }
    }

    // G2: Record Knockout Score and Auto-Update
    function recordKnockoutScore(matchId) {
        const match = tournamentData.matches.find(m => m.id === matchId);
        if (!match || match.winnerId) return;

        // Simplified scoring for Knockout: Winner is the one with higher random score
        const scoreA = Math.floor(Math.random() * 5) + 11; 
        const scoreB = Math.floor(Math.random() * 5) + 11; 
        
        let winnerId;
        if (scoreA > scoreB) {
            winnerId = match.teamAId;
        } else if (scoreB > scoreA) {
            winnerId = match.teamBId;
        } else {
             // Tie, re-roll
             return recordKnockoutScore(matchId); 
        }

        match.winnerId = winnerId;
        match.loserId = (winnerId === match.teamAId) ? match.teamBId : match.teamAId;
        match.status = 'COMPLETED';

        // G2i: Auto-fill next match slot
        if (match.nextMatchId) {
            const nextMatch = tournamentData.matches.find(m => m.id.startsWith(match.nextMatchId.substring(1)));
            if (nextMatch) {
                if (nextMatch.teamAId === match.nextMatchId) {
                    nextMatch.teamAId = winnerId;
                } else if (nextMatch.teamBId === match.nextMatchId) {
                    nextMatch.teamBId = winnerId;
                }
                nextMatch.status = (nextMatch.teamAId && nextMatch.teamBId && !nextMatch.teamAId.startsWith('W')) ? 'SCHEDULED' : 'TBD';
            }
        }
        
        // G2d: Logic Di chuy·ªÉn ƒê·ªôi Thua (N·∫øu Double Elimination - Simplified)
        // Omitted for brevity in this demo, but the logic would be similar to G2i, using loserMatchId.

        renderKnockoutBracket();
        renderFinalStandings();
    }
    
    // --- TAB L: K·∫æT QU·∫¢ ---
    function renderLiveUpcomingMatches() {
        const liveUpcomingEl = document.getElementById('live-upcoming-matches');
        liveUpcomingEl.innerHTML = '';
        
        const liveMatches = tournamentData.matches.filter(m => m.status === 'IN_PROGRESS'); // Requires real time update logic
        const upcomingMatches = tournamentData.matches.filter(m => m.status === 'SCHEDULED' && m.scheduledTime);
        
        let html = '<h4>S·∫ÆP DI·ªÑN RA (L2)</h4>';
        if (upcomingMatches.length === 0) {
            html += '<p>Kh√¥ng c√≥ tr·∫≠n ƒë·∫•u s·∫Øp t·ªõi.</p>';
        } else {
             html += '<table><thead><tr><th>Gi·ªù D·ª± Ki·∫øn</th><th>S√¢n</th><th>Tr·∫≠n ƒê·∫•u</th></tr></thead><tbody>';
             upcomingMatches.forEach(match => {
                const teamA = getTeam(match.teamAId)?.name || 'TBD';
                const teamB = getTeam(match.teamBId)?.name || 'TBD';
                html += `<tr><td>${match.scheduledTime}</td><td>${match.courtId}</td><td>${teamA} vs ${teamB} (${match.roundId})</td></tr>`;
             });
             html += '</tbody></table>';
        }

        liveUpcomingEl.innerHTML = html;
        renderFinalStandings();
    }

    // L5: X·∫øp H·∫°ng Chung Cu·ªôc (Simple Winner/Runner-up)
    function renderFinalStandings() {
        const finalEl = document.getElementById('final-standings');
        finalEl.innerHTML = '';
        
        const finalMatch = tournamentData.matches.find(m => m.roundId === 'Chung K·∫øt' && m.winnerId);
        
        if (finalMatch) {
            const winner = getTeam(finalMatch.winnerId);
            const runnerUp = getTeam(finalMatch.loserId);
            
            let html = `
                <div class="alert alert-success">
                    <h3>üèÜ V√î ƒê·ªäCH: ${winner.name}</h3>
                    <p>ü•à H·∫°ng nh√¨: ${runnerUp.name}</p>
                </div>
            `;
            finalEl.innerHTML = html;
        } else {
             finalEl.innerHTML = '<p>X·∫øp h·∫°ng chung cu·ªôc s·∫Ω ƒë∆∞·ª£c hi·ªÉn th·ªã sau khi tr·∫≠n Chung K·∫øt ho√†n t·∫•t.</p>';
        }
    }

    // --- TAB H: TEST (UTILITY) ---
    // H1b: Simulate Group Results
    function simulateGroupResults() {
        const groupMatches = tournamentData.matches.filter(m => m.roundId.startsWith('Group') && !m.winnerId);
        if (groupMatches.length === 0) {
             alert('Kh√¥ng c√≥ tr·∫≠n V√≤ng B·∫£ng n√†o ƒë·ªÉ gi·∫£ l·∫≠p.');
             return;
        }

        groupMatches.forEach(match => {
            if (!match.winnerId) {
                // Random scores that guarantee a win
                const scoreA = Math.floor(Math.random() * 3) + 11; // 11, 12, 13
                const scoreB = Math.floor(Math.random() * 10);
                
                match.score.sets = [{ scoreA, scoreB }];
                match.score.A = scoreA;
                match.score.B = scoreB;
                match.winnerId = scoreA > scoreB ? match.teamAId : match.teamBId;
                match.loserId = scoreA > scoreB ? match.teamBId : match.teamAId;
                match.status = 'COMPLETED';
                match.actualStartTime = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
            }
        });

        renderGroupStandings();
        renderGroupMatchList();
        alert(`ƒê√£ gi·∫£ l·∫≠p ${groupMatches.length} tr·∫≠n ƒë·∫•u V√≤ng B·∫£ng th√†nh c√¥ng!`);
    }

    // H2a: Hard Reset
    function hardReset() {
        if (confirm('C·∫¢NH B√ÅO: Thao t√°c n√†y s·∫Ω X√ìA T·∫§T C·∫¢ d·ªØ li·ªáu c·ªßa gi·∫£i ƒë·∫•u. B·∫°n c√≥ ch·∫Øc ch·∫Øn?')) {
            localStorage.removeItem('tournamentData'); // If using localStorage
            location.reload(); 
        }
    }

    // H2b: Soft Reset
    function softReset() {
        if (confirm('Thao t√°c n√†y s·∫Ω X√ìA Ph√¢n B·∫£ng, L·ªãch Tr√¨nh, V√≤ng B·∫£ng v√† V√≤ng Lo·∫°i, nh∆∞ng GI·ªÆ L·∫†I danh s√°ch ƒê·ªôi v√† C·∫•u H√¨nh. Ti·∫øp t·ª•c?')) {
            tournamentData.matches = [];
            tournamentData.groups = {};
            tournamentData.teams.forEach(t => t.groupId = null); // Reset D3 data
            
            renderTeamTable();
            renderScheduleTable();
            renderGroupMatchList();
            renderKnockoutBracket();
            renderFinalStandings();
            alert('Soft Reset ho√†n t·∫•t. B·∫°n c√≥ th·ªÉ b·∫Øt ƒë·∫ßu l·∫°i t·ª´ b∆∞·ªõc Ph√¢n B·∫£ng (D3).');
        }
    }

</script>

</body>
</html>
