<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pickleball Tournament Organizer V10.1 N√¢ng C·∫•p</title>
    <style>
        :root {
            --primary-color: #00796B; /* Teal/Xanh ng·ªçc */
            --secondary-color: #FF9800; /* Cam/H·ªï ph√°ch */
            --background-color: #f0f4f7;
            --text-color: #263238;
            --alert-color: #D32F2F; /* Red/C·∫£nh b√°o */
            --warning-color: #FBC02D; /* Yellow/L·ªách l·ªãch */
            --success-color: #388E3C; /* Green/Th√†nh c√¥ng */
            --border-color: #CFD8DC;
            --card-bg: #FFFFFF;
        }
        body {
            font-family: 'Inter', Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--background-color);
            color: var(--text-color);
        }
        .container {
            width: 95%;
            max-width: 1200px;
            margin: 20px auto;
            background: var(--card-bg);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border-radius: 12px;
            min-height: 90vh;
        }
        header {
            background-color: var(--primary-color);
            color: white;
            padding: 15px 20px;
            border-radius: 12px 12px 0 0;
            display: flex;
            align-items: center;
        }
        header img {
            height: 45px;
            margin-right: 15px;
            border-radius: 6px;
            object-fit: contain;
        }
        .nav-bar {
            display: flex;
            background-color: #333;
            border-radius: 0 0 12px 12px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .nav-bar button {
            background-color: inherit;
            color: white;
            padding: 12px 15px;
            border: none;
            cursor: pointer;
            transition: 0.3s;
            font-size: 15px;
            flex-grow: 1;
            outline: none;
            border-right: 1px solid #444;
        }
        .nav-bar button:last-child {
            border-right: none;
        }
        .nav-bar button:hover:not(.active) {
            background-color: #555;
        }
        .nav-bar button.active {
            background-color: var(--secondary-color);
            color: var(--text-color);
            font-weight: bold;
        }
        .tab-content {
            padding: 25px;
        }
        h2, h3 {
            color: var(--primary-color);
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 8px;
            margin-top: 10px;
        }
        .input-group {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: #fafafa;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #455A64;
        }
        input[type="text"],
        input[type="number"],
        input[type="time"],
        select {
            width: 100%;
            padding: 10px;
            margin-top: 5px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-sizing: border-box;
        }
        button {
            background-color: var(--primary-color);
            color: white;
            padding: 10px 18px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
            margin-right: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        button:hover {
            background-color: #004D40; /* Darker teal */
            transform: translateY(-1px);
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            box-shadow: none;
        }
        /* Table styles */
        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin-top: 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
        }
        table th, table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        table th {
            background-color: #E0F2F1;
            color: var(--text-color);
            font-weight: bold;
            text-transform: uppercase;
        }
        /* Alert/Status styles */
        .alert {
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 8px;
            font-weight: bold;
        }
        .alert-success {
            background-color: #E8F5E9;
            color: var(--success-color);
            border: 1px solid var(--success-color);
        }
        .alert-error {
            background-color: #FFEBEE;
            color: var(--alert-color);
            border: 1px solid var(--alert-color);
        }
        .alert-warning { /* F3a: C·∫£nh b√°o l·ªách l·ªãch */
            background-color: #FFFDE7;
            color: var(--warning-color);
            border: 1px solid var(--warning-color);
        }
        /* Schedule/Monitoring Styles */
        .time-monitor-alert {
            color: var(--alert-color);
            font-weight: bold;
        }
        .time-monitor-warning {
            color: var(--warning-color);
            font-weight: bold;
        }

        /* Bracket Styling */
        .bracket-container {
            display: flex;
            gap: 20px;
            overflow-x: auto;
            padding: 10px 0;
        }
        .bracket-round {
            min-width: 250px;
            padding: 10px;
            flex-shrink: 0;
        }
        .bracket-round h4 {
            color: #546E7A;
            margin-bottom: 15px;
            border-bottom: 1px solid #CFD8DC;
            font-size: 1.1em;
        }
        .bracket-match {
            margin: 15px 0;
            padding: 10px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--card-bg);
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            transition: border-color 0.3s;
        }
        .bracket-match.completed {
             border-color: var(--success-color);
             background-color: #E8F5E9;
        }
        .match-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
            margin-bottom: 5px;
        }
        .match-teams strong {
            display: block;
            margin: 5px 0;
            padding: 3px;
            border-radius: 4px;
            background-color: #f7f7f7;
        }
        .match-teams strong.winner {
            background-color: #C8E6C9;
            color: var(--success-color);
        }
        .match-score {
            font-weight: bold;
            color: var(--primary-color);
        }
        .match-status {
            font-style: italic;
            color: #78909C;
        }

        /* Public View (Tab L) Styling */
        .public-card {
            background-color: var(--card-bg);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .live-match-item {
            border-left: 5px solid var(--primary-color);
            padding: 15px;
            margin-bottom: 10px;
            background-color: #E0F7FA;
            border-radius: 6px;
        }
        .live-match-item strong {
            font-size: 1.2em;
            color: var(--alert-color);
        }
        .final-result-item {
            margin-top: 15px;
            padding: 15px;
            background-color: #FFF8E1;
            border-radius: 8px;
            border: 2px solid var(--secondary-color);
            text-align: center;
        }
        .final-result-item h3 {
            color: var(--secondary-color);
            border-bottom: none;
        }
        .final-result-item p {
            font-size: 1.1em;
            font-weight: bold;
            color: var(--text-color);
        }
    </style>
</head>
<body>

<div class="container">
    <header>
        <img id="logo-display" src="" alt="Logo" style="display:none;">
        <h1 id="tournament-title">PICKLEBALL TOURNAMENT ORGANIZER</h1>
    </header>
    
    <div class="nav-bar" id="navbar">
        <button onclick="openTab('C')" id="tab-C">C: C·∫§U H√åNH ‚öôÔ∏è</button>
        <button onclick="openTab('D')" id="tab-D">D: NG∆Ø·ªúI CH∆†I & ƒê·ªòI üë•</button>
        <button onclick="openTab('E')" id="tab-E">E: L·ªäCH THI ƒê·∫§U & TG ‚è∞</button>
        <button onclick="openTab('F')" id="tab-F">F: V√íNG B·∫¢NG üìä</button>
        <button onclick="openTab('G')" id="tab-G">G: V√íNG LO·∫†I üèÜ</button>
        <button onclick="openTab('L')" id="tab-L">L: K·∫æT QU·∫¢ ‚≠ê</button>
        <button onclick="openTab('H')" id="tab-H">H: TEST üß™</button>
    </div>

    <div id="C" class="tab-content">
        <h2>C: C·∫§U H√åNH ‚öôÔ∏è</h2>
        <div class="input-group">
            <label>C1a: T√™n Gi·∫£i ƒê·∫•u</label>
            <input type="text" id="config-name" value="Gi·∫£i Pickleball Demo N√¢ng C·∫•p">
            <label>C1a: Upload Logo (Base64)</label>
            <input type="file" id="config-logo" accept="image/*" onchange="handleLogoUpload(this)">
            <label>C1f: Ch·∫ø ƒë·ªô Trao Gi·∫£i Nh·∫•t ƒê·ªôc L·∫≠p (2 H·∫°ng)</label>
            <input type="checkbox" id="config-double-champion"> (B·∫≠t n·∫øu c√≥ H·∫°ng A/H·∫°ng B ri√™ng bi·ªát)
        </div>
        
        <h3>C2: Qu·∫£n L√Ω TH·ªÇ TH·ª®C V√íNG ƒê·∫§U</h3>
        <div class="input-group">
            <label>C2a0: Th·ªÉ th·ª©c V√≤ng Lo·∫°i (Knockout)</label>
            <select id="config-elimination-type">
                <option value="SINGLE">Single Elimination (Lo·∫°i ƒê∆°n)</option>
                <option value="DOUBLE">Double Elimination (Lo·∫°i K√©p - Nh√°nh Thua)</option>
            </select>
            <label>C2a1i: Quy t·∫Øc ƒêi·ªÉm Ch·∫°m Cao Nh·∫•t (Cap Score)</label>
            <input type="number" id="config-cap-score" value="13" min="11" placeholder="V√≠ d·ª•: 13 (Th·∫Øng 11 ƒëi·ªÉm, ƒëi·ªÉm t·ªëi ƒëa 13)">
            <label>C2a1: ƒêi·ªÉm Th·∫Øng m·ªói Set</label>
            <input type="number" id="config-win-score" value="11" min="1" placeholder="V√≠ d·ª•: 11">
            <label>S·ªë ƒë·ªôi thƒÉng h·∫°ng t·ª´ m·ªói b·∫£ng</label>
            <input type="number" id="config-advancing-teams" value="2" min="1" max="4">
        </div>
        <button onclick="saveConfig()">L∆∞u C·∫•u H√¨nh</button>
        <div id="config-status" class="alert alert-success" style="margin-top:15px; display:none;"></div>
    </div>

    <div id="D" class="tab-content" style="display:none;">
        <h2>D: NG∆Ø·ªúI CH∆†I & ƒê·ªòI üë•</h2>
        
        <h3>D2: Qu·∫£n l√Ω ƒê·ªôi/C·∫∑p ƒê·∫•u</h3>
        <button onclick="generateRandomTeams()">D2e: GH√âP C·∫∂P RANDOM (T·∫°o 8 ƒë·ªôi demo)</button>
        <div id="team-list-status" class="alert" style="margin-top:10px; display:none;"></div>

        <table id="teams-table">
            <thead>
                <tr>
                    <th>ID ƒê·ªôi</th>
                    <th>T√™n ƒê·ªôi</th>
                    <th>H·∫°ng (D2c)</th>
                    <th>Tr·∫°ng th√°i (D2a)</th>
                    <th>Nh√≥m/B·∫£ng (D3)</th>
                </tr>
            </thead>
            <tbody>
                <!-- Team rows populated by JS -->
            </tbody>
        </table>

        <h3>D3: Ph√¢n B·∫£ng T·ª± ƒê·ªông</h3>
        <button onclick="generateGroups()">D3: PH√ÇN B·∫¢NG T·ª∞ ƒê·ªòNG</button>
        <p>*(Ch·∫°y sau khi c√≥ danh s√°ch ƒë·ªôi. C·∫ßn thi·∫øt cho V√≤ng B·∫£ng v√† L·∫≠p l·ªãch t·ªëi ∆∞u).*</p>
    </div>

    <div id="E" class="tab-content" style="display:none;">
        <h2>E: L·ªäCH THI ƒê·∫§U & TG ‚è∞ (Planning Engine)</h2>
        
        <h3>E1: C·∫•u H√¨nh Th·ªùi Gian & S√¢n ƒê·∫•u</h3>
        <div class="input-group">
            <label>Gi·ªù B·∫Øt ƒê·∫ßu (V√≠ d·ª•: 08:00)</label>
            <input type="time" id="schedule-start-time" value="08:00">
            <label>Th·ªùi L∆∞·ª£ng TB m·ªói Tr·∫≠n (Ph√∫t)</label>
            <input type="number" id="schedule-duration" value="30" min="5">
            <label>E1a: S·ªê L∆Ø·ª¢NG S√ÇN ƒê·∫§U</label>
            <input type="number" id="schedule-courts" value="2" min="1">
        </div>
        
        <h3>E2: Qu·∫£n L√Ω L·ªäCH TR√åNH T·ªîNG H·ª¢P (E2a: Logic T·ªëi ∆Øu)</h3>
        <button onclick="generateSchedule()">E2a: T·∫†O L·ªäCH TR√åNH T·ªêI ∆ØU</button>
        <button onclick="showScheduleSummary()">E2c: XEM T√ìM T·∫ÆT L·ªäCH</button>
        <div id="schedule-status" class="alert" style="margin-top:15px; display:none;"></div>

        <div id="schedule-viewer" style="margin-top: 20px;">
            <h4>E2b: B·∫£ng L·ªãch Chi Ti·∫øt (T·∫•t c·∫£ tr·∫≠n ƒë·∫•u)</h4>
            <table id="schedule-table">
                <thead>
                    <tr>
                        <th>ID</th>
                        <th>V√≤ng</th>
                        <th>Th·ªùi Gian D·ª± Ki·∫øn</th>
                        <th>S√¢n</th>
                        <th>Tr·∫≠n ƒê·∫•u</th>
                        <th>T·ªëi ∆∞u Gi√£n C√°ch</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Schedule rows populated by JS -->
                </tbody>
            </table>
        </div>
    </div>

    <div id="F" class="tab-content" style="display:none;">
        <h2>F: V√íNG B·∫¢NG üìä (Execution & Monitoring)</h2>
        
        <h3>F2: X√¢y D·ª±ng Tr·∫≠n ƒê·∫•u V√≤ng B·∫£ng</h3>
        <button onclick="generateGroupMatches()">F2a: T·∫†O DANH S√ÅCH TR·∫¨N ƒê·∫§U V√íNG B·∫¢NG</button>
        
        <h3>F3: Nh·∫≠p K·∫øt Qu·∫£ & Gi√°m S√°t</h3>
        <div id="f-match-list">
            <!-- Matches to be scored -->
        </div>
        
        <h3>F4: B·∫£ng X·∫øp H·∫°ng (Logic t√≠nh to√°n n√¢ng cao)</h3>
        <div id="f-standings">
            <!-- Standings populated by JS -->
        </div>
    </div>

    <div id="G" class="tab-content" style="display:none;">
        <h2>G: V√íNG LO·∫†I üèÜ</h2>
        
        <h3>G1: X√¢y D·ª±ng C√¢y ƒê·∫•u Lo·∫°i T·ª∞ ƒê·ªòNG</h3>
        <button onclick="generateKnockoutBrackets()">G1: T·∫†O C√ÇY ƒê·∫§U LO·∫†I (D√πng k·∫øt qu·∫£ F4)</button>
        <div id="bracket-status" class="alert" style="margin-top:15px; display:none;"></div>

        <h3>G2: Theo D√µi & C·∫≠p Nh·∫≠t T·ª± ƒê·ªông (H·ªó tr·ª£ Double Elimination)</h3>
        <div class="bracket-container" id="knockout-bracket">
            <!-- Knockout matches populated by JS -->
        </div>
    </div>

    <div id="L" class="tab-content" style="display:none;">
        <h2>L: K·∫æT QU·∫¢ ‚≠ê (Public Display)</h2>
        <div class="public-card">
            <h3>L1/L2: ƒêANG DI·ªÑN RA (LIVE) / S·∫ÆP DI·ªÑN RA</h3>
            <div id="live-upcoming-matches">
                <!-- Live and Upcoming matches -->
            </div>
        </div>

        <div class="public-card">
            <h3>L5: X·∫æP H·∫†NG CHUNG CU·ªòC</h3>
            <div id="final-standings">
                <!-- Final ranks -->
            </div>
        </div>
    </div>
    
    <div id="H" class="tab-content" style="display:none;">
        <h2>H: TEST üß™ (Utility)</h2>
        <div class="input-group">
            <h3>H1b: Simulate Results</h3>
            <button onclick="simulateGroupResults()">GI·∫¢ L·∫¨P K·∫æT QU·∫¢ V√íNG B·∫¢NG (Ch·∫°y F3)</button>
        </div>
        
        <div class="input-group">
            <h3>H2: Reset D·ªØ Li·ªáu (CRITICAL)</h3>
            <button onclick="hardReset()">H2a: X√ìA T·∫§T C·∫¢ D·ªÆ LI·ªÜU (HARD RESET)</button>
            <button onclick="softReset()">H2b: X√ìA PH√ÇN B·∫¢NG, L·ªäCH TR√åNH & K·∫æT QU·∫¢ (SOFT RESET)</button>
        </div>
    </div>

</div>

<script>
    // --- GLOBAL STATE ---
    let tournamentData = {
        config: {
            name: 'Gi·∫£i Pickleball Demo N√¢ng C·∫•p',
            logoUrl: '',
            eliminationType: 'SINGLE', // SINGLE or DOUBLE
            doubleChampion: false,
            capScore: 13,
            winScore: 11,
            advancingTeams: 2 // F4 logic
        },
        teams: [],
        scheduleParams: {
            startTime: '08:00',
            duration: 30, // minutes
            numCourts: 2
        },
        matches: [], // All matches (Group & Knockout)
        groups: {}, // { A: [...teams], B: [...teams] }
    };

    // --- UTILITIES ---

    const generateId = (prefix = '') => prefix + Math.random().toString(36).substring(2, 9);
    const getTeam = (teamId) => tournamentData.teams.find(t => t.id === teamId);

    // Format time (e.g., "08:00")
    const formatTime = (time) => {
        if (!time) return 'TBA';
        const [hours, minutes] = time.split(':').map(Number);
        const date = new Date();
        date.setHours(hours, minutes, 0, 0);
        return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
    };

    const addMinutes = (time, mins) => {
        if (!time) return '00:00'; // Should not happen if scheduling correctly
        const [hours, minutes] = time.split(':').map(Number);
        const date = new Date();
        date.setHours(hours, minutes, 0, 0);
        date.setMinutes(date.getMinutes() + mins);
        // Returns HH:MM format (24h)
        return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false }).replace(' AM', '').replace(' PM', '').trim();
    };
    
    // Time difference utility for monitoring (F3a)
    const timeDiffInMinutes = (time1, time2) => {
        if (!time1 || !time2) return 0;
        const date1 = new Date(`2000/01/01 ${time1}`);
        const date2 = new Date(`2000/01/01 ${time2}`);
        return Math.abs((date1 - date2) / (1000 * 60));
    };

    // --- TAB NAVIGATION ---
    function openTab(tabId) {
        const contents = document.querySelectorAll('.tab-content');
        contents.forEach(content => content.style.display = 'none');

        const buttons = document.querySelectorAll('.nav-bar button');
        buttons.forEach(button => button.classList.remove('active'));

        document.getElementById(tabId).style.display = 'block';
        document.getElementById(`tab-${tabId}`).classList.add('active');

        // Render content when tab is opened
        if (tabId === 'D') renderTeamTable();
        if (tabId === 'E') renderScheduleTable();
        if (tabId === 'F') renderGroupMatchList();
        if (tabId === 'G') renderKnockoutBracket();
        if (tabId === 'L') renderLiveUpcomingMatches();
    }
    document.addEventListener('DOMContentLoaded', () => {
        openTab('C'); // Start on Config tab
        document.getElementById('tournament-title').innerText = tournamentData.config.name;
    });

    // --- TAB C: C·∫§U H√åNH ---
    function handleLogoUpload(input) {
        const file = input.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                tournamentData.config.logoUrl = e.target.result;
                document.getElementById('logo-display').src = e.target.result;
                document.getElementById('logo-display').style.display = 'block';
            };
            reader.readAsDataURL(file);
        }
    }

    function saveConfig() {
        tournamentData.config.name = document.getElementById('config-name').value;
        tournamentData.config.eliminationType = document.getElementById('config-elimination-type').value;
        tournamentData.config.doubleChampion = document.getElementById('config-double-champion').checked;
        tournamentData.config.capScore = parseInt(document.getElementById('config-cap-score').value) || 13;
        tournamentData.config.winScore = parseInt(document.getElementById('config-win-score').value) || 11;
        tournamentData.config.advancingTeams = parseInt(document.getElementById('config-advancing-teams').value) || 2;

        document.getElementById('tournament-title').innerText = tournamentData.config.name;
        document.getElementById('config-status').innerText = 'L∆∞u c·∫•u h√¨nh th√†nh c√¥ng!';
        document.getElementById('config-status').style.display = 'block';
        setTimeout(() => document.getElementById('config-status').style.display = 'none', 3000);
    }

    // --- TAB D: NG∆Ø·ªúI CH∆†I & ƒê·ªòI ---
    function generateRandomTeams() {
        const numTeams = 8;
        tournamentData.teams = [];
        for (let i = 1; i <= numTeams; i++) {
            tournamentData.teams.push({
                id: generateId('T'),
                name: `ƒê·ªôi ${i}`,
                category: i % 2 === 0 ? 'A' : 'B', // D2c: Ph√¢n h·∫°ng A/B
                status: 'OFFICIAL', // D2a
                groupId: null,
                players: [{ name: `Player ${i}-1` }, { name: `Player ${i}-2` }]
            });
        }
        renderTeamTable();
        const statusEl = document.getElementById('team-list-status');
        statusEl.innerText = `ƒê√£ t·∫°o ${numTeams} ƒë·ªôi demo th√†nh c√¥ng!`;
        statusEl.className = 'alert alert-success';
        statusEl.style.display = 'block';
    }

    function renderTeamTable() {
        const tbody = document.getElementById('teams-table').getElementsByTagName('tbody')[0];
        tbody.innerHTML = '';
        tournamentData.teams.forEach(team => {
            const row = tbody.insertRow();
            row.insertCell().innerText = team.id;
            row.insertCell().innerText = team.name;
            row.insertCell().innerText = team.category;
            row.insertCell().innerText = team.status;
            row.insertCell().innerText = team.groupId || 'Ch∆∞a ph√¢n b·∫£ng';
        });
    }

    // D3: Ph√¢n B·∫£ng T·ª± ƒê·ªông
    function generateGroups() {
        const officialTeams = tournamentData.teams.filter(t => t.status === 'OFFICIAL');
        if (officialTeams.length === 0) {
            alert('Ch∆∞a c√≥ ƒë·ªôi thi ƒë·∫•u ch√≠nh th·ª©c.');
            return;
        }

        const numGroups = 4; // Hardcode 4 groups for simplicity (A, B, C, D)
        tournamentData.groups = {};
        for (let i = 0; i < numGroups; i++) {
            tournamentData.groups[String.fromCharCode(65 + i)] = []; // A, B, C, D
        }
        const groupKeys = Object.keys(tournamentData.groups);

        // Simple Round Robin Distribution
        officialTeams.forEach((team, index) => {
            const groupId = groupKeys[index % numGroups];
            team.groupId = groupId;
            tournamentData.groups[groupId].push(team.id);
        });

        renderTeamTable();
        alert(`ƒê√£ ph√¢n ${officialTeams.length} ƒë·ªôi v√†o ${numGroups} b·∫£ng th√†nh c√¥ng.`);
    }

    // --- TAB E: L·ªäCH THI ƒê·∫§U & TG (E2a Logic T·ªëi ∆Øu) ---
    function generateSchedule() {
        if (tournamentData.matches.length === 0) {
            alert('Vui l√≤ng t·∫°o danh s√°ch tr·∫≠n ƒë·∫•u V√≤ng B·∫£ng (Tab F) v√†/ho·∫∑c V√≤ng Lo·∫°i (Tab G) tr∆∞·ªõc.');
            return;
        }

        const params = tournamentData.scheduleParams;
        const numCourts = params.numCourts;
        const matchDuration = params.duration;
        
        // Map to store last match end time for each team and court
        let teamsSchedule = {}; // { teamId: lastEndTime (HH:MM) }
        let courtFreeTime = Array(numCourts).fill(params.startTime); // [Court1Free, Court2Free, ...]
        
        // Reset schedule fields for matches that are not completed
        tournamentData.matches.forEach(match => {
            if (match.status !== 'COMPLETED') {
                match.scheduledTime = null;
                match.courtId = null;
                match.timeWarning = false;
            }
        });

        // Sort matches: Group matches first, then Knockout (KO) in order of round
        const matchesToSchedule = tournamentData.matches.filter(m => m.status !== 'COMPLETED').sort((a, b) => {
            const isGroupA = a.roundId.startsWith('Group');
            const isGroupB = b.roundId.startsWith('Group');
            
            if (isGroupA && !isGroupB) return -1;
            if (!isGroupA && isGroupB) return 1;
            
            // For Knockout matches, sort by round name (T·ª© K·∫øt, B√°n K·∫øt, Chung K·∫øt)
            if (!isGroupA && !isGroupB) {
                const roundsOrder = { 'T·ª© K·∫øt': 1, 'B√°n K·∫øt': 2, 'Chung K·∫øt': 3 };
                return (roundsOrder[a.roundId] || 99) - (roundsOrder[b.roundId] || 99);
            }
            return 0;
        });

        matchesToSchedule.forEach(match => {
            const teamAId = match.teamAId;
            const teamBId = match.teamBId;
            
            let bestCourtIndex = -1;
            let earliestCourtTime = '23:59';
            
            // 1. Find the earliest free court time
            courtFreeTime.forEach((freeTime, index) => {
                if (freeTime < earliestCourtTime) {
                    earliestCourtTime = freeTime;
                    bestCourtIndex = index;
                }
            });

            let scheduleTime = earliestCourtTime;
            let timeWarning = false;
            let addedRestMinutes = 0;

            // 2. Logic Gi√£n C√°ch (E2aiii): Check team rest time and force 5 min rest if needed
            const checkTeamRestTime = (teamId) => {
                if (teamId && teamsSchedule[teamId]) {
                    const lastEndTime = teamsSchedule[teamId];
                    // Calculate time difference between scheduled start and team's last end time
                    const diffInMins = timeDiffInMinutes(lastEndTime, scheduleTime);
                    
                    if (diffInMins < matchDuration) {
                        // Force a 5-minute rest period
                        addedRestMinutes = 5;
                        scheduleTime = addMinutes(lastEndTime, addedRestMinutes);
                        return true; // Warning needed
                    }
                }
                return false;
            };

            // Check Team A and Team B (adjust scheduleTime if necessary)
            if (checkTeamRestTime(teamAId)) timeWarning = true;
            if (checkTeamRestTime(teamBId)) timeWarning = true; // Re-check if A adjusted the time
            
            // Recalculate match end time based on final scheduleTime
            const matchEndTime = addMinutes(scheduleTime, matchDuration);

            // 3. Update schedule data
            match.scheduledTime = scheduleTime;
            match.courtId = bestCourtIndex + 1;
            match.timeWarning = timeWarning;

            // 4. Update court and team free times
            courtFreeTime[bestCourtIndex] = matchEndTime;
            if (teamAId && !teamAId.startsWith('W') && !teamAId.startsWith('L')) teamsSchedule[teamAId] = matchEndTime;
            if (teamBId && !teamBId.startsWith('W') && !teamBId.startsWith('L')) teamsSchedule[teamBId] = matchEndTime;
        });

        renderScheduleTable();
        const statusEl = document.getElementById('schedule-status');
        statusEl.innerText = `ƒê√£ t·∫°o ${matchesToSchedule.length} l·ªãch tr√¨nh t·ªëi ∆∞u tr√™n ${numCourts} s√¢n.`;
        statusEl.className = 'alert alert-success';
        statusEl.style.display = 'block';
    }

    function renderScheduleTable() {
        const tbody = document.getElementById('schedule-table').getElementsByTagName('tbody')[0];
        tbody.innerHTML = '';
        
        const sortedMatches = tournamentData.matches.sort((a, b) => {
            if (!a.scheduledTime && b.scheduledTime) return 1;
            if (a.scheduledTime && !b.scheduledTime) return -1;
            if (!a.scheduledTime && !b.scheduledTime) return a.roundId.localeCompare(b.roundId); // Sort by round if no time
            
            if (a.scheduledTime === b.scheduledTime) return a.courtId - b.courtId;
            return a.scheduledTime.localeCompare(b.scheduledTime);
        });

        sortedMatches.forEach(match => {
            const row = tbody.insertRow();
            const teamA = getTeam(match.teamAId)?.name || match.teamAId || 'TBD';
            const teamB = getTeam(match.teamBId)?.name || match.teamBId || 'TBD';

            row.insertCell().innerText = match.id;
            row.insertCell().innerText = match.roundId;
            row.insertCell().innerText = match.scheduledTime || 'Ch∆∞a x·∫øp';
            row.insertCell().innerText = match.courtId ? `S√¢n ${match.courtId}` : '-';
            row.insertCell().innerHTML = `<strong>${teamA}</strong> vs <strong>${teamB}</strong>`;
            
            const warningCell = row.insertCell();
            if (match.timeWarning) {
                warningCell.innerHTML = `<span class="time-monitor-warning">‚ö†Ô∏è Ngh·ªâ √≠t h∆°n ${tournamentData.scheduleParams.duration} ph√∫t.</span>`;
            } else {
                warningCell.innerText = '-';
            }
        });
    }

    // E2c: Xem T√≥m T·∫Øt L·ªãch (Simplified Text View)
    function showScheduleSummary() {
        let summary = '--- T√≥m T·∫Øt L·ªãch Tr√¨nh (Gi·ªù x S√¢n) ---\n';
        const sortedMatches = tournamentData.matches.filter(m => m.scheduledTime).sort((a, b) => a.scheduledTime.localeCompare(b.scheduledTime));
        
        let displayMap = {}; // { time: { courtId: match } }

        sortedMatches.forEach(match => {
            if (!displayMap[match.scheduledTime]) {
                displayMap[match.scheduledTime] = {};
            }
            const teamA = getTeam(match.teamAId)?.name || match.teamAId || 'TBD';
            const teamB = getTeam(match.teamBId)?.name || match.teamBId || 'TBD';
            displayMap[match.scheduledTime][match.courtId] = `${teamA} vs ${teamB} (${match.roundId})`;
        });

        for (const time in displayMap) {
            summary += `\n‚è∞ ${time}:`;
            for (let i = 1; i <= tournamentData.scheduleParams.numCourts; i++) {
                summary += ` | S√¢n ${i}: ${displayMap[time][i] || 'TR·ªêNG'}`;
            }
        }

        alert(summary);
    }


    // --- TAB F: V√íNG B·∫¢NG (F4 Logic N√¢ng C·∫•p) ---
    // F2a: T·∫°o Danh S√°ch Tr·∫≠n ƒê·∫•u V√≤ng B·∫£ng (Logic gi·ªØ nguy√™n)
    function generateGroupMatches() {
        tournamentData.matches = tournamentData.matches.filter(m => !m.roundId.startsWith('Group')); // Keep Knockout if exists
        const matches = [];
        
        for (const groupId in tournamentData.groups) {
            const groupTeams = tournamentData.groups[groupId];
            for (let i = 0; i < groupTeams.length; i++) {
                for (let j = i + 1; j < groupTeams.length; j++) {
                    matches.push({
                        id: generateId('M'),
                        roundId: `Group ${groupId}`,
                        teamAId: groupTeams[i],
                        teamBId: groupTeams[j],
                        score: { A: 0, B: 0, sets: [] },
                        winnerId: null,
                        loserId: null,
                        status: 'SCHEDULED',
                        scheduledTime: null,
                        courtId: null,
                        actualStartTime: null
                    });
                }
            }
        }
        tournamentData.matches = [...matches, ...tournamentData.matches]; // Add group matches at the beginning
        renderGroupMatchList();
        alert(`ƒê√£ t·∫°o ${matches.length} tr·∫≠n ƒë·∫•u V√≤ng B·∫£ng.`);
    }

    // F3: Record Score & F4: Update Standings
    function recordGroupScore(matchId) {
        const match = tournamentData.matches.find(m => m.id === matchId);
        if (!match || match.winnerId) return;

        const scoreA = parseInt(document.getElementById(`score-A-${matchId}`).value) || 0;
        const scoreB = parseInt(document.getElementById(`score-B-${matchId}`).value) || 0;
        
        const config = tournamentData.config;
        const winScore = config.winScore;
        const capScore = config.capScore;

        let winnerId = null;
        
        // C2a1i: Logic ƒêi·ªÉm Th·∫Øng
        const checkWin = (s1, s2) => {
             return (s1 >= winScore && (s1 - s2) >= 2) || (s1 >= capScore && s1 > s2);
        }

        if (checkWin(scoreA, scoreB)) {
            winnerId = match.teamAId;
        } else if (checkWin(scoreB, scoreA)) {
            winnerId = match.teamBId;
        } else {
            alert('ƒêi·ªÉm ch∆∞a ƒë·ªß ƒëi·ªÅu ki·ªán th·∫Øng (Ph·∫£i c√°ch bi·ªát 2 ƒëi·ªÉm ho·∫∑c ƒë·∫°t Cap Score).');
            return;
        }

        match.score.sets = [{ scoreA, scoreB }]; // Simplified to one set
        match.score.A = scoreA;
        match.score.B = scoreB;
        match.winnerId = winnerId;
        match.loserId = (winnerId === match.teamAId) ? match.teamBId : match.teamAId;
        match.status = 'COMPLETED';
        const currentTime = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
        match.actualStartTime = currentTime;
        
        // F3a: Gi√°m s√°t Sai L·ªách Th·ªùi Gian
        if (match.scheduledTime) {
             const diffInMins = timeDiffInMinutes(match.scheduledTime, match.actualStartTime);
             let alertMessage = '';
             if (diffInMins > 10) {
                 alertMessage = `‚ö†Ô∏è Ch·∫≠m ${Math.round(diffInMins)} ph√∫t.`;
             } else if (diffInMins > 5) {
                 alertMessage = `üü° L·ªách ${Math.round(diffInMins)} ph√∫t.`;
             }
             if (alertMessage) console.log(`[F3a] Tr·∫≠n ${match.id}: ${alertMessage}`);
        }

        // Trigger updates
        renderGroupStandings();
        renderGroupMatchList(); 
    }

    // F4: N√¢ng c·∫•p Logic t√≠nh to√°n BXH
    function renderGroupStandings() {
        const standingsEl = document.getElementById('f-standings');
        standingsEl.innerHTML = '';
        
        for (const groupId in tournamentData.groups) {
            const teamStats = {}; 
            tournamentData.groups[groupId].forEach(teamId => {
                teamStats[teamId] = { P: 0, W: 0, L: 0, PF: 0, PA: 0, Diff: 0, teamName: getTeam(teamId).name, teamId: teamId };
            });

            const groupMatches = tournamentData.matches.filter(m => m.roundId === `Group ${groupId}` && m.status === 'COMPLETED');
            
            groupMatches.forEach(match => {
                const statA = teamStats[match.teamAId];
                const statB = teamStats[match.teamBId];

                statA.P++; statB.P++;
                statA.PF += match.score.A; statA.PA += match.score.B;
                statB.PF += match.score.B; statB.PA += match.score.A;

                if (match.winnerId === match.teamAId) {
                    statA.W++; statB.L++;
                } else {
                    statA.L++; statB.W++;
                }
            });

            // Final calculation and sorting (W > Diff > PF)
            const sortedStats = Object.values(teamStats).sort((a, b) => {
                b.Diff = b.PF - b.PA; a.Diff = a.PF - a.PA;

                // 1. Th·∫Øng (W)
                if (b.W !== a.W) return b.W - a.W;
                // 2. Hi·ªáu s·ªë ƒëi·ªÉm (Diff)
                if (b.Diff !== a.Diff) return b.Diff - a.Diff;
                // 3. ƒêi·ªÉm Th·∫Øng (PF)
                return b.PF - a.PF;
            });
            
            let html = `<h4>B·∫£ng ${groupId}</h4>`;
            html += '<table style="font-size:0.9em"><thead><tr><th>Rank</th><th>ƒê·ªôi</th><th>W</th><th>L</th><th>PF</th><th>PA</th><th>Diff</th></tr></thead><tbody>';
            
            sortedStats.forEach((stat, index) => {
                const rankClass = (index < tournamentData.config.advancingTeams) ? 'font-weight: bold; background-color: #E0F2F1;' : '';
                html += `<tr style="${rankClass}"><td>${index + 1}</td><td>${stat.teamName}</td><td>${stat.W}</td><td>${stat.L}</td><td>${stat.PF}</td><td>${stat.PA}</td><td>${stat.Diff}</td></tr>`;
            });

            html += '</tbody></table>';
            standingsEl.innerHTML += html;
        }
    }

    // --- TAB G: V√íNG LO·∫†I (G1c Double Elimination) ---
    function generateKnockoutBrackets() {
        const teamsToAdvance = getTeamsToAdvance(); // F4 -> G1 input
        if (teamsToAdvance.length === 0) {
            document.getElementById('bracket-status').innerText = 'Ch∆∞a x√°c ƒë·ªãnh ƒë·ªôi thƒÉng h·∫°ng (C·∫ßn c√≥ k·∫øt qu·∫£ V√≤ng B·∫£ng).';
            document.getElementById('bracket-status').className = 'alert alert-error';
            document.getElementById('bracket-status').style.display = 'block';
            return;
        }

        // Calculate power of 2 size (8, 16, 32...)
        let size = 8;
        while (size < teamsToAdvance.length) size *= 2;

        // Pad teams to fit bracket size (e.g., 6 teams -> 8 slots, 2 byes)
        const paddedTeams = [...teamsToAdvance];
        while (paddedTeams.length < size) paddedTeams.push(null);
        
        // Generate matches based on type
        const eliminationType = tournamentData.config.eliminationType;
        let bracketMatches = [];
        
        if (eliminationType === 'SINGLE') {
             bracketMatches = generateSingleElimination(paddedTeams);
        } else { // DOUBLE (G1c logic)
             bracketMatches = generateDoubleElimination(paddedTeams);
        }
        
        // Remove old knockout matches and add new ones
        tournamentData.matches = tournamentData.matches.filter(m => m.roundId.startsWith('Group')); 
        tournamentData.matches = [...tournamentData.matches, ...bracketMatches];
        
        renderKnockoutBracket();
        document.getElementById('bracket-status').innerText = `ƒê√£ t·∫°o ${bracketMatches.length} tr·∫≠n ƒë·∫•u V√≤ng Lo·∫°i (${eliminationType}).`;
        document.getElementById('bracket-status').className = 'alert alert-success';
        document.getElementById('bracket-status').style.display = 'block';
    }
    
    // Helper: Generate Single Elimination Bracket
    function generateSingleElimination(teams) {
        let matches = [];
        let numRounds = Math.log2(teams.length);
        let currentRoundTeams = [...teams];
        
        const roundNames = ['V√≤ng 1/8', 'T·ª© K·∫øt', 'B√°n K·∫øt', 'Chung K·∫øt'];
        let matchCounter = 0;
        let numTeamsInRound = teams.length;

        for (let r = 0; r < numRounds; r++) {
            const roundName = roundNames[roundNames.length - numRounds + r];
            const numMatches = numTeamsInRound / 2;
            let nextRoundTeams = [];
            
            for (let i = 0; i < numMatches; i++) {
                matchCounter++;
                const matchId = generateId(`W${matchCounter}`);
                
                const teamAId = currentRoundTeams[i * 2];
                const teamBId = currentRoundTeams[i * 2 + 1];
                
                matches.push({
                    id: matchId,
                    roundId: roundName,
                    teamAId: teamAId,
                    teamBId: teamBId,
                    score: { A: 0, B: 0, sets: [] },
                    winnerId: null,
                    loserId: null,
                    status: (teamAId && teamBId) ? 'SCHEDULED' : (teamAId || teamBId ? 'BYE' : 'TBD'),
                    nextMatchId: `W${matchCounter + numMatches - i % numMatches}`, // Link to next round
                    bracket: 'Winner'
                });
                nextRoundTeams.push(matchId);
            }
            numTeamsInRound /= 2;
            currentRoundTeams = nextRoundTeams;
        }
        return matches;
    }

    // Helper: Generate Double Elimination Bracket (Simplified frame for G1c)
    function generateDoubleElimination(teams) {
        // This is a highly simplified FRAMEWORK to show G1c logic integration.
        // Full implementation requires complex indexing (W1 -> W5, L1 -> L2, etc.)
        let matches = [];
        let numRounds = Math.log2(teams.length);
        let roundMatchCounter = 0;
        
        // --- Nh√°nh Th·∫Øng (Winner Bracket) ---
        let winnerMatches = generateSingleElimination(teams).map(m => {
            m.bracket = 'Winner';
            m.roundId = 'WB-' + m.roundId;
            return m;
        });
        matches.push(...winnerMatches);
        
        // --- Nh√°nh Thua (Loser Bracket) ---
        // Create L-Bracket matches placeholders (needs detailed G1c indexing)
        let loserMatches = [];
        // Example: WB-Round 1 losers go to LB-Round 1
        const numWBR1 = teams.length / 2;
        const numLBRounds = 2 * numRounds - 2; // Approximated
        
        for (let r = 1; r <= 3; r++) { // Only create 3 rounds for demo
            roundMatchCounter++;
            for (let i = 1; i <= Math.max(1, teams.length / (2 * r)); i++) {
                 const matchId = generateId(`L${roundMatchCounter}-${i}`);
                 loserMatches.push({
                    id: matchId,
                    roundId: `LB-R${r}`,
                    teamAId: r === 1 ? `Loser-W${i}` : `Winner-${generateId('L')}`, // G2d: Link to WB Losers
                    teamBId: `Winner-${generateId('L')}`,
                    score: { A: 0, B: 0, sets: [] },
                    winnerId: null,
                    loserId: null,
                    status: 'TBD',
                    bracket: 'Loser'
                 });
            }
        }
        matches.push(...loserMatches);

        // Final Grand Final
        matches.push({
            id: generateId('GF'),
            roundId: 'Grand Final',
            teamAId: 'Winner-WB-Chung K·∫øt',
            teamBId: 'Winner-LB-R3', 
            score: { A: 0, B: 0, sets: [] },
            winnerId: null,
            loserId: null,
            status: 'TBD',
            bracket: 'Final'
        });
        
        return matches;
    }

    function renderKnockoutBracket() {
        const bracketEl = document.getElementById('knockout-bracket');
        bracketEl.innerHTML = '';
        const knockoutMatches = tournamentData.matches.filter(m => !m.roundId.startsWith('Group'));

        if (knockoutMatches.length === 0) {
            bracketEl.innerHTML = '<p>C√¢y ƒë·∫•u lo·∫°i ch∆∞a ƒë∆∞·ª£c t·∫°o. Vui l√≤ng ch·∫°y G1.</p>';
            return;
        }

        // Group matches by bracket and round
        const structuredBrackets = knockoutMatches.reduce((acc, match) => {
            const bracket = match.bracket || 'Single';
            acc[bracket] = acc[bracket] || {};
            acc[bracket][match.roundId] = acc[bracket][match.roundId] || [];
            acc[bracket][match.roundId].push(match);
            return acc;
        }, {});
        
        const bracketOrder = ['Winner', 'Loser', 'Final', 'Single'];
        
        bracketOrder.forEach(bracketKey => {
            const rounds = structuredBrackets[bracketKey];
            if (!rounds) return;

            let bracketHtml = `<div><h3>${bracketKey.toUpperCase()} BRACKET</h3><div class="bracket-container">`;

            for (const roundName in rounds) {
                let roundHtml = `<div class="bracket-round"><h4>${roundName}</h4>`;
                rounds[roundName].forEach(match => {
                    const teamA = getTeam(match.teamAId)?.name || match.teamAId || 'TBD';
                    const teamB = getTeam(match.teamBId)?.name || match.teamBId || 'TBD';
                    
                    const winnerName = match.winnerId ? getTeam(match.winnerId)?.name : null;
                    const teamAClass = winnerName === teamA ? 'winner' : '';
                    const teamBClass = winnerName === teamB ? 'winner' : '';
                    
                    const statusText = match.status === 'COMPLETED' ? 'K·∫øt th√∫c' : (match.status === 'TBD' ? 'Ch·ªù ƒë·ªôi' : 'S·∫Øp x·∫øp');

                    roundHtml += `
                        <div class="bracket-match ${match.status === 'COMPLETED' ? 'completed' : ''}">
                            <div class="match-info">
                                <span class="match-score">${match.score.A || 0} - ${match.score.B || 0}</span>
                                <span class="match-status">${statusText}</span>
                            </div>
                            <div class="match-teams">
                                <strong class="${teamAClass}">${teamA}</strong>
                                <strong class="${teamBClass}">${teamB}</strong>
                            </div>
                            <button onclick="recordKnockoutScore('${match.id}')" ${match.winnerId ? 'disabled' : ''}>Nh·∫≠p ƒëi·ªÉm</button>
                        </div>
                    `;
                });
                roundHtml += `</div>`;
                bracketHtml += roundHtml;
            }
            bracketHtml += `</div></div>`;
            bracketEl.innerHTML += bracketHtml;
        });
    }

    // G2: Record Knockout Score and Auto-Update (G2i/G2d)
    function recordKnockoutScore(matchId) {
        const match = tournamentData.matches.find(m => m.id === matchId);
        if (!match || match.winnerId || match.status === 'TBD') return;

        // Simplified scoring for Knockout: Random Win/Loss
        const scoreA = Math.floor(Math.random() * 5) + 11; 
        const scoreB = Math.floor(Math.random() * 5) + 11; 
        
        let winnerId;
        if (scoreA !== scoreB) {
            winnerId = scoreA > scoreB ? match.teamAId : match.teamBId;
        } else {
             return recordKnockoutScore(matchId); 
        }

        match.score.A = scoreA;
        match.score.B = scoreB;
        match.winnerId = winnerId;
        match.loserId = (winnerId === match.teamAId) ? match.teamBId : match.teamAId;
        match.status = 'COMPLETED';

        // --- G2i/G2d: Auto-fill next match slot ---
        tournamentData.matches.forEach(nextMatch => {
            // Check for Winner Progression (G2i)
            if (nextMatch.teamAId === match.id) { 
                nextMatch.teamAId = winnerId;
                console.log(`[G2i] ${winnerId} ti·∫øn v√†o tr·∫≠n ${nextMatch.id} (Slot A)`);
            } else if (nextMatch.teamBId === match.id) {
                nextMatch.teamBId = winnerId;
                console.log(`[G2i] ${winnerId} ti·∫øn v√†o tr·∫≠n ${nextMatch.id} (Slot B)`);
            }
            
            // Check for Loser Progression (G2d - Simplified for demo)
            if (match.bracket === 'Winner' && tournamentData.config.eliminationType === 'DOUBLE') {
                 // Logic: Send loser to the appropriate Loser Bracket match
                 // Example: if nextMatch.teamBId === 'Loser-W1', then update
                 // Due to simplified indexing, we only update if it's explicitly TBD
                 if (nextMatch.bracket === 'Loser' && (nextMatch.teamAId === 'TBD' || nextMatch.teamBId === 'TBD')) {
                     // Very simple logic to fill the first available TBD slot in LB
                     if (nextMatch.teamAId === 'TBD') nextMatch.teamAId = match.loserId;
                     else if (nextMatch.teamBId === 'TBD') nextMatch.teamBId = match.loserId;
                     console.log(`[G2d] ${match.loserId} xu·ªëng nh√°nh thua tr·∫≠n ${nextMatch.id}`);
                 }
            }

            // Update status if both teams are known
            if (nextMatch.teamAId && nextMatch.teamBId && (nextMatch.status === 'TBD' || nextMatch.status === 'BYE')) {
                 if (!nextMatch.teamAId.startsWith('W') && !nextMatch.teamAId.startsWith('L') && !nextMatch.teamBId.startsWith('W') && !nextMatch.teamBId.startsWith('L')) {
                    nextMatch.status = 'SCHEDULED';
                 }
            }
        });


        renderKnockoutBracket();
        renderFinalStandings();
    }
    
    // --- TAB L: K·∫æT QU·∫¢ (N√¢ng c·∫•p giao di·ªán) ---
    function renderLiveUpcomingMatches() {
        const liveUpcomingEl = document.getElementById('live-upcoming-matches');
        liveUpcomingEl.innerHTML = '';
        
        const nowTime = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
        
        // Filter matches
        const liveMatches = tournamentData.matches.filter(m => m.status === 'IN_PROGRESS'); // Needs external trigger to set IN_PROGRESS
        const upcomingMatches = tournamentData.matches.filter(m => m.status === 'SCHEDULED' && m.scheduledTime && m.scheduledTime.localeCompare(nowTime) >= 0)
                                                    .sort((a, b) => a.scheduledTime.localeCompare(b.scheduledTime)).slice(0, 5); // Top 5
        
        let html = '<h4>TR·∫¨N ƒêANG DI·ªÑN RA (L1)</h4>';
        if (liveMatches.length > 0) {
            liveMatches.forEach(match => {
                const teamA = getTeam(match.teamAId)?.name || 'TBD';
                const teamB = getTeam(match.teamBId)?.name || 'TBD';
                html += `<div class="live-match-item">S√¢n ${match.courtId}: <strong>${teamA} vs ${teamB}</strong> (${match.score.A}-${match.score.B})</div>`;
            });
        } else {
            html += '<p>Kh√¥ng c√≥ tr·∫≠n ƒë·∫•u ƒëang di·ªÖn ra.</p>';
        }


        html += '<h4>S·∫ÆP DI·ªÑN RA (L2)</h4>';
        if (upcomingMatches.length > 0) {
             html += '<table><thead><tr><th>Gi·ªù D·ª± Ki·∫øn</th><th>S√¢n</th><th>Tr·∫≠n ƒê·∫•u</th><th>V√≤ng</th></tr></thead><tbody>';
             upcomingMatches.forEach(match => {
                const teamA = getTeam(match.teamAId)?.name || 'TBD';
                const teamB = getTeam(match.teamBId)?.name || 'TBD';
                html += `<tr><td>${match.scheduledTime}</td><td>${match.courtId}</td><td>${teamA} vs ${teamB}</td><td>${match.roundId}</td></tr>`;
             });
             html += '</tbody></table>';
        } else {
             html += '<p>Kh√¥ng c√≥ tr·∫≠n ƒë·∫•u n√†o trong danh s√°ch s·∫Øp di·ªÖn ra.</p>';
        }

        liveUpcomingEl.innerHTML = html;
    }

    // L5: X·∫øp H·∫°ng Chung Cu·ªôc (N√¢ng c·∫•p)
    function renderFinalStandings() {
        const finalEl = document.getElementById('final-standings');
        finalEl.innerHTML = '';
        
        const finalMatch = tournamentData.matches.find(m => m.roundId === 'Chung K·∫øt' && m.winnerId);
        const grandFinalMatch = tournamentData.matches.find(m => m.roundId === 'Grand Final' && m.winnerId);

        let html = '';
        
        if (grandFinalMatch || finalMatch) {
            const match = grandFinalMatch || finalMatch;
            const winner = getTeam(match.winnerId);
            const runnerUp = getTeam(match.loserId);
            
            html += `
                <div class="final-result-item">
                    <h3>üèÜ V√î ƒê·ªäCH TO√ÄN GI·∫¢I</h3>
                    <p>${winner.name}</p>
                    <p style="font-size:0.9em; color:#888;">ü•à √Å Qu√¢n: ${runnerUp.name}</p>
                </div>
            `;
            finalEl.innerHTML = html;
        } else {
             finalEl.innerHTML = '<p>X·∫øp h·∫°ng chung cu·ªôc s·∫Ω ƒë∆∞·ª£c hi·ªÉn th·ªã sau khi V√≤ng Lo·∫°i k·∫øt th√∫c.</p>';
        }
    }

    // --- TAB H: TEST (UTILITY) ---
    // H1b: Simulate Group Results (Gi·ªØ nguy√™n, ƒë·∫£m b·∫£o logic F4 ƒë∆∞·ª£c k√≠ch ho·∫°t)
    function simulateGroupResults() {
        const groupMatches = tournamentData.matches.filter(m => m.roundId.startsWith('Group') && !m.winnerId);
        if (groupMatches.length === 0) {
             alert('Kh√¥ng c√≥ tr·∫≠n V√≤ng B·∫£ng n√†o ƒë·ªÉ gi·∫£ l·∫≠p.');
             return;
        }

        groupMatches.forEach(match => {
            if (!match.winnerId) {
                // Random scores that guarantee a win
                const scoreA = Math.floor(Math.random() * 3) + 11; // 11, 12, 13
                const scoreB = Math.floor(Math.random() * 10);
                
                match.score.sets = [{ scoreA, scoreB }];
                match.score.A = scoreA;
                match.score.B = scoreB;
                match.winnerId = scoreA > scoreB ? match.teamAId : match.teamBId;
                match.loserId = scoreA > scoreB ? match.teamBId : match.teamAId;
                match.status = 'COMPLETED';
                match.actualStartTime = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
            }
        });

        renderGroupStandings();
        renderGroupMatchList();
        alert(`ƒê√£ gi·∫£ l·∫≠p ${groupMatches.length} tr·∫≠n ƒë·∫•u V√≤ng B·∫£ng th√†nh c√¥ng!`);
    }

    // H2a/H2b (Gi·ªØ nguy√™n)
    function hardReset() {
        if (confirm('C·∫¢NH B√ÅO: Thao t√°c n√†y s·∫Ω X√ìA T·∫§T C·∫¢ d·ªØ li·ªáu c·ªßa gi·∫£i ƒë·∫•u. B·∫°n c√≥ ch·∫Øc ch·∫Øn?')) {
            location.reload(); 
        }
    }

    function softReset() {
        if (confirm('Thao t√°c n√†y s·∫Ω X√ìA Ph√¢n B·∫£ng, L·ªãch Tr√¨nh, V√≤ng B·∫£ng v√† V√≤ng Lo·∫°i, nh∆∞ng GI·ªÆ L·∫†I danh s√°ch ƒê·ªôi v√† C·∫•u H√¨nh. Ti·∫øp t·ª•c?')) {
            tournamentData.matches = [];
            tournamentData.groups = {};
            tournamentData.teams.forEach(t => t.groupId = null); // Reset D3 data
            
            renderTeamTable();
            renderScheduleTable();
            renderGroupMatchList();
            renderKnockoutBracket();
            renderFinalStandings();
            alert('Soft Reset ho√†n t·∫•t. B·∫°n c√≥ th·ªÉ b·∫Øt ƒë·∫ßu l·∫°i t·ª´ b∆∞·ªõc Ph√¢n B·∫£ng (D3).');
        }
    }
</script>

</body>
</html>
