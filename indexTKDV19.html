<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TKD Championship 2025 ‚Äî Qu·∫£n l√Ω gi·∫£i Pickleball V13 GitHub</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body { background:#f7f9fc; font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial; color:#222; padding:18px; }
    .tab-content { margin-top: 18px; }
    .logo { 
      width:64px; 
      height:64px; 
      object-fit:contain; 
      border-radius:8px; 
      border:1px solid #e6eefc; 
      padding:6px; 
      /* ƒê√£ x√≥a background URL placeholder ƒë·ªÉ d√πng ·∫£nh t·ª´ th·∫ª <img> */
      background:#fff; 
    }
    table th { background:#0d6efd; color:#fff; position:sticky; top:0; }
    .status { font-size:0.95rem; color:#555; }
    /* Responsive adjustment for match inputs */
    .match-score-cell input {
      width: 45px;
      text-align: center;
      padding: 0.1rem;
    }
    @media (max-width: 576px) {
      .match-score-cell input {
        width: 35px;
      }
    }
    .winner { font-weight: bold; color: green; }
    .loser { color: red; }
    .ranking-container { display: flex; flex-direction: column; gap: 20px; }
    @media (min-width: 768px) {
        .ranking-container { flex-direction: row; }
        .ranking-container > div { flex: 1; }
    }
    
    /* NEW BRACKET STYLES */
    .tournament-bracket {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 10px 0;
        width: 100%;
    }
    .bracket-layout {
        width: 100%;
        max-width: 800px;
        margin: 0 auto;
    }
    .round-sf {
        position: relative;
        padding: 0 20px;
    }
    .round-final {
        position: relative;
        padding-top: 30px; 
    }
    .match-up {
        background: #f8f9fa; /* light grey */
        border: 1px solid #dee2e6;
        border-radius: 4px;
        padding: 10px;
        min-width: 180px;
        flex-grow: 1;
        max-width: 45%;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .match-up-final {
        min-width: 250px;
        max-width: 350px;
        background: #fff;
        border-width: 2px;
    }
    .team-name {
        padding: 3px 0;
        font-size: 0.95rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .team-name.winner-bracket {
        font-weight: bold;
        color: #198754; /* Success green */
    }
    .team-name.loser-bracket {
        color: #dc3545; /* Danger red */
        opacity: 0.8;
    }
    .match-score {
        font-size: 0.9rem;
        color: #000;
        font-weight: bold;
    }
    .round-label {
        text-align: center;
        font-weight: 600;
        color: #0d6efd;
        font-size: 0.8rem;
        margin-bottom: 5px;
    }

    /* Final Results Boxes */
    .team-box {
        padding: 12px 20px;
        border-radius: 8px;
        text-align: center;
        border: 2px solid #ccc;
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    .team-box.champion {
        background-color: #d1e7dd; /* Success light */
        border-color: #198754;
    }
    .team-box.runner-up {
        background-color: #fff3cd; /* Warning light */
        border-color: #ffc107;
    }
    .team-box.third-place {
        background-color: #cfe2ff; /* Info light */
        border-color: #0d6efd;
    }
    .team-box h4 {
        margin-bottom: 5px;
    }
    .team-box p {
        margin-top: 0;
        font-size: 1.1rem;
        color: #212529;
    }

    .teams-out-header {
        width: 100%;
        margin-bottom: 10px;
        padding-bottom: 5px;
        border-bottom: 1px dashed #ccc;
    }
    .teams-out {
        width: 100%;
        max-width: 700px;
    }

    /* Mobile adjustments */
    @media (max-width: 768px) {
        .round-sf {
            flex-direction: column;
            gap: 20px;
        }
        .match-up {
            max-width: 100%;
        }
    }
  </style>

<style id="rounds-hide-original-buttons">
/* hide original create/fill buttons in matches to move to config */
#matches .btn-primary[onclick*="taoLichThiDauCungGio"], 
#matches .btn-secondary[onclick*="taoLichCoDinh"],
#matches .btn-success[onclick*="autoFillScores"] { display: none !important; }
</style>

</head>
<body>
<div class="container">
  <div class="d-flex justify-content-between align-items-center mb-3">
    <div class="d-flex align-items-center gap-2">
      <img class="logo" src="data/logoTKD.png" alt="Logo TKD">
      <div>
        <h3 class="mb-0">TKD Championship 2025</h3>
        <div>Ng√†y thi ƒë·∫•u: 18/10/2025</div>
      </div>
    </div>
    <div>
      <div id="autoSaveStatus" class="text-end status">Auto-save: <span id="autoState" class="text-danger">T·∫Øt</span></div>
      <div id="lastSaved" class="text-end status">Ch∆∞a l∆∞u</div>
    </div>
  </div>

  <ul class="nav nav-tabs" id="mainTabs">
    <li class="nav-item"><button class="nav-link active" data-bs-toggle="tab" data-bs-target="#overview" onclick="renderOverview()">T·ªïng quan</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#matches">V√≤ng B·∫£ng</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#finals">V√≤ng Chung K·∫øt</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#results">K·∫øt qu·∫£ Chung cu·ªôc</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#config">C·∫•u h√¨nh</button></li>
  </ul>

  <div class="tab-content">
    <div class="tab-pane fade show active p-3" id="overview">
        <div id="overviewContent">ƒêang t·∫£i d·ªØ li·ªáu...</div>
    </div>
    
    <div class="tab-pane fade p-3" id="matches">
  <div id="roundsScheduleContainer" class="mb-3">\n  <div id="roundsWarning" class="alert alert-danger d-none" role="alert"></div>
    <div class="d-flex justify-content-between align-items-center mb-2">
      <h5 class="mb-0">üìÖ L·ªãch thi ƒë·∫•u - Nh√≥m theo S√¢n</h5>
      <div id="roundsLoadStatus" class="small text-muted"></div>
    </div>
    <div id="roundsControls" class="mb-2">
      <button class="btn btn-sm btn-outline-primary" onclick="loadCalendarRound()">T·∫£i L·ªãch t·ª´ GitHub</button>
      <button class="btn btn-sm btn-outline-secondary" onclick="syncScoresFromState()">ƒê·ªìng b·ªô T·ªâ s·ªë t·ª´ state.json</button>
      <button class="btn btn-sm btn-outline-dark" onclick="loadDefaultSchedule()">D√πng L·ªãch M·∫∑c ƒê·ªãnh</button>
    </div>
    <div id="roundsByCourt" class="row g-3"></div>
  </div>

      <div class="d-flex gap-2 mb-2 flex-wrap">
        <button class="btn btn-sm btn-primary" onclick="taoLichThiDauCungGio()">T·∫°o l·ªãch thi ƒë·∫•u T·ªëi ∆∞u (T·ª± ƒë·ªông)</button>
        <button class="btn btn-sm btn-secondary" onclick="taoLichCoDinh()">T·∫°o l·ªãch C·ªë ƒë·ªãnh</button>
        
        <button class="btn btn-sm btn-info" onclick="document.getElementById('fileInput').click()">Import L·ªãch (CSV)</button>
        <input type="file" id="fileInput" accept=".csv" style="display: none;" onchange="handleFileSelect(event)">
        
        <button class="btn btn-sm btn-warning" onclick="exportSchedule()">Export L·ªãch (CSV)</button>

        <button class="btn btn-sm btn-success" onclick="autoFillScores()">ƒêi·ªÅn k·∫øt qu·∫£ T·ª± ƒë·ªông (11 - X)</button>
      </div>
      
      <h6 id="scheduleAHeader" class="mt-4">B·∫£ng A (Nam - N·ªØ)</h6><div id="tableMatchesA">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u.</div>
      
      <h6 class="mt-4">B·∫£ng B (Nam)</h6><div id="tableMatchesB">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u.</div>
      
      <button class="btn btn-warning mt-4" onclick="scheduleFinalsAuto()">L√™n l·ªãch V√≤ng Chung k·∫øt (T·ª± ƒë·ªông h√≥a)</button>
    </div>

    <div class="tab-pane fade p-3" id="finals">
        <div id="finalsContent">
            <h6 class="mt-4">V√≤ng B√°n k·∫øt (16:30, S√¢n 1-2)</h6>
            <div id="semifinalMatches">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u b√°n k·∫øt. K·∫øt qu·∫£ V√≤ng B·∫£ng s·∫Ω t·ª± ƒë·ªông c·∫≠p nh·∫≠t l·ªãch.</div>

            <h6 class="mt-4">Tr·∫≠n Chung k·∫øt (17:00, S√¢n 1)</h6>
            <div id="finalMatch">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u chung k·∫øt.</div>
        </div>
    </div>

    <div class="tab-pane fade p-3" id="results">
        <h5 class="mb-3">B·∫£ng x·∫øp h·∫°ng V√≤ng B·∫£ng (C·∫≠p nh·∫≠t li√™n t·ª•c)</h5>
        <div id="rankingTables" class="ranking-container">
            </div>

        <hr class="my-4">

        <h5 class="mb-3">Danh hi·ªáu Chung cu·ªôc & C√¢y Gi·∫£i ƒë·∫•u</h5>
        <div id="tournamentBracket" class="tournament-bracket">
            </div>
    </div>

    <div class="tab-pane fade p-3" id="config">

  <!-- Court configuration block (inserted by assistant) -->
  <div id="courtConfigBlock" class="card mb-3 p-3 shadow-sm">
    <h6>üéæ C·∫•u h√¨nh S√¢n thi ƒë·∫•u</h6>
    <div id="courtConfigList" class="mt-2"></div>
    <div class="mt-2 d-flex gap-2">
      <button class="btn btn-sm btn-outline-success" onclick="addCourtConfig()">‚ûï Th√™m s√¢n m·ªõi</button>
      <button class="btn btn-sm btn-outline-secondary" onclick="renderCourtConfig()">‚ü≥ L√†m m·ªõi giao di·ªán</button>
    </div>
    <div class="small text-muted mt-2">M·∫∑c ƒë·ªãnh 4 s√¢n (b·∫Øt ƒë·∫ßu 14:00, th·ªùi l∆∞·ª£ng 240 ph√∫t). Thay ƒë·ªïi s·∫Ω ƒë∆∞·ª£c l∆∞u t·ª± ƒë·ªông.</div>
  </div>

<div class="card mt-3 p-3 shadow-sm">
  <h6>‚öôÔ∏è C√¥ng c·ª• qu·∫£n l√Ω n√¢ng cao</h6>
  <div class="d-flex gap-2 flex-wrap mt-2">
    <button class="btn btn-outline-primary btn-sm" onclick="taoLichThiDauCungGio()">T·∫°o l·ªãch v√≤ng b·∫£ng (T·ª± ƒë·ªông)</button>
    <button class="btn btn-outline-success btn-sm" onclick="taoLichCoDinh()">T·∫°o l·ªãch c·ªë ƒë·ªãnh</button>
    <button class="btn btn-outline-warning btn-sm" onclick="autoFillScores()">ƒêi·ªÅn k·∫øt qu·∫£ t·ª± ƒë·ªông</button>
    <button class="btn btn-outline-info btn-sm" onclick="loadCalendarRound()">T·∫£i L·ªãch t·ª´ GitHub</button>
    <button class="btn btn-outline-secondary btn-sm" onclick="syncScoresFromState()">ƒê·ªìng b·ªô T·ªâ s·ªë t·ª´ state.json</button>
    <button class="btn btn-outline-dark btn-sm" onclick="exportAllState()">üì¶ Xu·∫•t to√†n b·ªô d·ªØ li·ªáu (.json)</button>
  </div>
  <div id="advancedToolsStatus" class="small text-muted mt-2"></div>
</div>

      <p class="text-muted">Nh·∫≠p th√¥ng tin kho l∆∞u tr·ªØ GitHub ƒë·ªÉ t·ª± ƒë·ªông l∆∞u tr·ªØ d·ªØ li·ªáu gi·∫£i ƒë·∫•u.</p>
      <div class="row g-2 mb-2">
        <div class="col-md-3"><input id="cfgOwner" class="form-control" placeholder="Owner (V√≠ d·ª•: user_name)"></div>
        <div class="col-md-3"><input id="cfgRepo" class="form-control" placeholder="Repo (V√≠ d·ª•: my-data-repo)"></div>
        <div class="col-md-3"><input id="cfgFolder" class="form-control" value="data"></div>
        <div class="col-md-3"><input id="cfgFile" class="form-control" value="state.json"></div>
      </div>
      <input id="cfgToken" type="password" class="form-control mb-2" placeholder="D√°n GitHub Personal Access Token (PAT) t·∫°i ƒë√¢y">
      <div class="d-flex gap-2">
        <button class="btn btn-primary" onclick="saveConfig()">L∆∞u c·∫•u h√¨nh Local</button>
        <button class="btn btn-success" onclick="checkConnection()">Ki·ªÉm tra & T·∫£i D·ªØ li·ªáu</button>
      </div>
      <div class="mt-2" id="configStatus"></div>
      
      <div class="card bg-light mt-4 shadow-sm">
        <div class="card-body">
            <h5 class="card-title text-info">üîë H∆∞·ªõng d·∫´n l·∫•y GitHub Token (PAT)</h5>
            <ol class="small mb-0">
                <li>Truy c·∫≠p <a href="https://github.com/settings/tokens" target="_blank" class="text-info">GitHub Tokens Settings</a> (B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p).</li>
                <li>Ch·ªçn **Generate new token** (ho·∫∑c **Generate new token (classic)** n·∫øu b·∫°n d√πng t√†i kho·∫£n c≈©).</li>
                <li>**T√™n Token:** ƒê·∫∑t t√™n d·ªÖ nh·ªõ (v√≠ d·ª•: `TKDManager_AutoSave`).</li>
                <li>**Th·ªùi h·∫°n:** Ch·ªçn t√πy √Ω (n√™n ch·ªçn 90 ng√†y ho·∫∑c T√πy ch·ªânh).</li>
                <li>**Ph·∫°m vi (Scopes):** **B·∫ÆT BU·ªòC** t√≠ch ch·ªçn √¥ **`repo`** (cho ph√©p truy c·∫≠p v√†o kho l∆∞u tr·ªØ).</li>
                <li>Nh·∫•n **Generate token** v√† **SAO CH√âP** chu·ªói Token v·ª´a ƒë∆∞·ª£c t·∫°o.</li>
                <li>D√°n chu·ªói Token ƒë√≥ v√†o √¥ "D√°n GitHub Personal Access Token (PAT) t·∫°i ƒë√¢y" b√™n tr√™n.</li>
            </ol>
            <p class="mt-2 mb-0 text-danger small">‚ö†Ô∏è **L∆∞u √Ω:** Token ch·ªâ hi·ªÉn th·ªã **M·ªòT L·∫¶N**. H√£y sao ch√©p ngay l·∫≠p t·ª©c v√† gi·ªØ b√≠ m·∫≠t. N·∫øu m·∫•t, b·∫°n ph·∫£i t·∫°o l·∫°i Token m·ªõi.</p>
        </div>
      </div>
      </div>
  </div>
</div>

<div class="modal fade" id="customAlertModal" tabindex="-1" aria-labelledby="customAlertModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="customAlertModalLabel">Th√¥ng b√°o</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="customAlertModalBody">
        N·ªôi dung th√¥ng b√°o
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-primary" data-bs-dismiss="modal">ƒê√≥ng</button>
      </div>
    </div>
  </div>
</div>

<script>
// D·ªØ li·ªáu l·ªãch c·ªë ƒë·ªãnh t·ª´ file TKDPlayers - Sheet2 (1).csv (ƒê√É C·∫¨P NH·∫¨T)
const FIXED_SCHEDULE_CSV = `Gi·ªù b·∫Øt ƒë·∫ßu,Gi·ªù k·∫øt th√∫c,L∆∞·ª£t tr·∫≠n,S√¢n 1,S√¢n 2,S√¢n 3,S√¢n 7,Th·ªùi l∆∞·ª£ng d·ª± ki·∫øn
2:00,2:15,1,Ti·ªáp/Th·ªßy - Ph∆∞∆°ng/Thanh,Giang/Long - H∆∞·ªùng/ƒê·∫°t,H·∫≠u/D≈©ng - H·∫°nh/Ti·∫øn,Huy·ªÅn/Lu√¢n - Linh/M.H√πng,0:15
2:15,2:30,2,Tri·ªÅu/Minh - Hi·ªÉn/P.H√πng,T√≠n/Khi√™m - √Ånh/To√†n,H·∫≠u/D≈©ng - H∆∞·ªùng/ƒê·∫°t,Giang/Long - Huy·ªÅn/Lu√¢n,0:15
2:30,2:45,3,Ph∆∞∆°ng/Thanh - √Ånh/To√†n,Tri·ªÅu/Minh - T√≠n/Khi√™m,H·∫°nh/Ti·∫øn - Linh/M.H√πng,Tri·ªÅu/Minh - Hi·ªÉn/P.H√πng,0:15
2:45,3:00,4,,H·∫°nh/Ti·∫øn - Giang/Long,Huy·ªÅn/Lu√¢n - H∆∞·ªùng/ƒê·∫°t,H·∫≠u/D≈©ng - Linh/M.H√πng,0:15
3:00,3:15,5,,Ti·ªáp/Th·ªßy - √Ånh/To√†n,T√≠n/Khi√™m - Hi·ªÉn/M.H√πng,,0:15
3:15,3:30,6,,Ph∆∞∆°ng/Thanh - Tri·ªÅu/Minh,Giang/Long - Linh/M.H√πng,,0:15
3:30,3:45,7,,H·∫°nh/Ti·∫øn - H∆∞·ªùng/ƒê·∫°t,H·∫≠u/D≈©ng - Huy·ªÅn/Lu√¢n,,0:15
3:45,4:00,8,,Ti·ªáp/Th·ªßy - T√≠n/Khi√™m,Ph∆∞∆°ng/Thanh - Hi·ªÉn/P.H√πng,,0:15
4:00,4:15,9,,Tri·ªÅu/Minh - √Ånh/To√†n,Ti·ªáp/Th·ªßy - Ph∆∞∆°ng/Thanh,H·∫°nh/Ti·∫øn - Huy·ªÅn/Lu√¢n,0:15
4:15,4:30,10,,T√≠n/Khi√™m - Ph∆∞∆°ng/Thanh,Giang/Long - H·∫≠u/D≈©ng,,0:15
4:30,4:45,11,H·∫≠u/D≈©ng - H·∫°nh/Ti·∫øn,Giang/Long - H∆∞·ªùng/ƒê·∫°t,Huy·ªÅn/Lu√¢n - Linh/M.H√πng,H·∫≠u/D≈©ng - Linh/M.H√πng,0:15
4:45,5:00,12,,,,0:15
5:00,5:15,13,H·∫≠u/D≈©ng - Giang/Long,Huy·ªÅn/Lu√¢n - H·∫°nh/Ti·∫øn,Linh/M.H√πng - H∆∞·ªùng/ƒê·∫°t,,0:15
5:15,5:30,14,Tri·ªÅu/Minh - Ti·ªáp/Th·ªßy,√Ånh/To√†n - Hi·ªÉn/P.H√πng,Ph∆∞∆°ng/Thanh - T√≠n/Khi√™m,,0:15
5:30,5:45,15,H·∫≠u/D≈©ng - Huy·ªÅn/Lu√¢n,Giang/Long - Linh/M.H√πng,H·∫°nh/Ti·∫øn - H∆∞·ªùng/ƒê·∫°t,,0:15
5:45,6:00,16,,,,0:15
6:00,6:15,17,Huy·ªÅn/Lu√¢n - Giang/Long,H·∫≠u/D≈©ng - H∆∞·ªùng/ƒê·∫°t,H·∫°nh/Ti·∫øn - Linh/M.H√πng,,0:15
6:15,6:30,18,Ti·ªáp/Th·ªßy - Hi·ªÉn/P.H√πng,Ph∆∞∆°ng/Thanh - √Ånh/To√†n,Tri·ªÅu/Minh - T√≠n/Khi√™m,,0:15
6:30,6:45,19,H·∫≠u/D≈©ng - H·∫°nh/Ti·∫øn,Giang/Long - H∆∞·ªùng/ƒê·∫°t,Huy·ªÅn/Lu√¢n - Linh/M.H√πng,Ti·ªáp/Th·ªßy - Ph∆∞∆°ng/Thanh,0:15
6:45,7:00,20,Tri·ªÅu/Minh - Hi·ªÉn/P.H√πng,T√≠n/Khi√™m - √Ånh/To√†n,H·∫≠u/D≈©ng - H∆∞·ªùng/ƒê·∫°t,Giang/Long - Huy·ªÅn/Lu√¢n,0:15
7:00,7:15,21,Ph∆∞∆°ng/Thanh - √Ånh/To√†n,Tri·ªÅu/Minh - T√≠n/Khi√™m,H·∫°nh/Ti·∫øn - Linh/M.H√πng,Ti·ªáp/Th·ªßy - Hi·ªÉn/P.H√πng,0:15
7:15,7:30,22,,H·∫°nh/Ti·∫øn - Giang/Long,Huy·ªÅn/Lu√¢n - H∆∞·ªùng/ƒê·∫°t,H·∫≠u/D≈©ng - Linh/M.H√πng,0:15
7:30,7:45,23,,Ti·ªáp/Th·ªßy - √Ånh/To√†n,T√≠n/Khi√™m - Hi·ªÉn/P.H√πng,,0:15
7:45,8:00,24,,Ph∆∞∆°ng/Thanh - Tri·ªÅu/Minh,Giang/Long - Linh/M.H√πng,,0:15
8:00,8:15,25,,H·∫°nh/Ti·∫øn - H∆∞·ªùng/ƒê·∫°t,H·∫≠u/D≈©ng - Huy·ªÅn/Lu√¢n,,0:15
8:15,8:30,26,,Ti·ªáp/Th·ªßy - T√≠n/Khi√™m,Ph∆∞∆°ng/Thanh - Hi·ªÉn/P.H√πng,,0:15
8:30,8:45,27,,Tri·ªÅu/Minh - √Ånh/To√†n,Ti·ªáp/Th·ªßy - Ph∆∞∆°ng/Thanh,H·∫°nh/Ti·∫øn - Huy·ªÅn/Lu√¢n,0:15
8:45,9:00,28,,T√≠n/Khi√™m - Ph∆∞∆°ng/Thanh,Giang/Long - H·∫≠u/D≈©ng,,0:15
9:00,9:15,29,H·∫≠u/D≈©ng - H·∫°nh/Ti·∫øn,Giang/Long - H∆∞·ªùng/ƒê·∫°t,Huy·ªÅn/Lu√¢n - Linh/M.H√πng,H·∫≠u/D≈©ng - Linh/M.H√πng,0:15
9:15,9:30,30,,,,0:15
9:30,9:45,31,H·∫≠u/D≈©ng - Giang/Long,Huy·ªÅn/Lu√¢n - H·∫°nh/Ti·∫øn,Linh/M.H√πng - H∆∞·ªùng/ƒê·∫°t,,0:15
9:45,10:00,32,Tri·ªÅu/Minh - Ti·ªáp/Th·ªßy,√Ånh/To√†n - Hi·ªÉn/P.H√πng,Ph∆∞∆°ng/Thanh - T√≠n/Khi√™m,,0:15
10:00,10:15,33,H·∫≠u/D≈©ng - Huy·ªÅn/Lu√¢n,Giang/Long - Linh/M.H√πng,H·∫°nh/Ti·∫øn - H∆∞·ªùng/ƒê·∫°t,,0:15
10:15,10:30,34,,,,0:15
10:30,10:45,35,Huy·ªÅn/Lu√¢n - Giang/Long,H·∫≠u/D≈©ng - H∆∞·ªùng/ƒê·∫°t,H·∫°nh/Ti·∫øn - Linh/M.H√πng,,0:15
10:45,11:00,36,Ti·ªáp/Th·ªßy - Hi·ªÉn/P.H√πng,Ph∆∞∆°ng/Thanh - √Ånh/To√†n,Tri·ªÅu/Minh - T√≠n/Khi√™m,,0:15`;

// Bi·∫øn state l∆∞u tr·ªØ d·ªØ li·ªáu ch√≠nh c·ªßa ·ª©ng d·ª•ng.
let state = { 
  mixedTeams: ["H·∫≠u/D≈©ng","H·∫°nh/Ti·∫øn","Giang/Long","Huy·ªÅn/Lu√¢n","Linh/M.H√πng","H∆∞·ªùng/ƒê·∫°t"], // B·∫£ng A (Nam-N·ªØ)
  maleTeams: ["Ti·ªáp/Th·ªßy","Ph∆∞∆°ng/Thanh","Tri·ªÅu/Minh","T√≠n/Khi√™m","√Ånh/To√†n","Hi·ªÉn/P.H√πng"], // B·∫£ng B (Nam)
  matchesA: [], 
  matchesB: [],
  tableA: [], // B·∫£ng x·∫øp h·∫°ng A
  tableB: [], // B·∫£ng x·∫øp h·∫°ng B
  
  // LOGIC B√ÅN K·∫æT: SF1: Nh·∫•t A vs Nh·∫•t B, SF2: Nh√¨ B vs Nh√¨ A
  semifinals: [
    { id: 'SF1', teamA: 'Nh·∫•t A', teamB: 'Nh·∫•t B', scoreA: null, scoreB: null, time: '16:30', court: 'S√¢n 1', winner: null, loser: null },
    { id: 'SF2', teamA: 'Nh√¨ B', teamB: 'Nh√¨ A', scoreA: null, scoreB: null, time: '16:30', court: 'S√¢n 2', winner: null, loser: null }
  ],
  final: { id: 'F', teamA: 'Th·∫Øng SF1', teamB: 'Th·∫Øng SF2', scoreA: null, scoreB: null, time: '17:00', court: 'S√¢n 1', winner: null, runnerUp: null },
  config: {}
};

let stateChanged = false; // Bi·∫øn c·ªù theo d√µi thay ƒë·ªïi d·ªØ li·ªáu
let currentSha = null; // Bi·∫øn l∆∞u tr·ªØ SHA c·ªßa file tr√™n GitHub
let autoSaveInterval = null; // Bi·∫øn l∆∞u tr·ªØ ID c·ªßa interval

// --- Custom Modal Function ---
function showModal(title, body) {
    document.getElementById('customAlertModalLabel').textContent = title;
    document.getElementById('customAlertModalBody').innerHTML = body;
    const modal = new bootstrap.Modal(document.getElementById('customAlertModal'));
    modal.show();
}

/**
 * H√†m chuy·ªÉn ƒë·ªïi tab
 * @param {string} tabId - ID c·ªßa tab c·∫ßn chuy·ªÉn (v√≠ d·ª•: 'matches', 'overview')
 */
function switchTab(tabId) {
    const tabElement = document.querySelector(`#mainTabs button[data-bs-target="#${tabId}"]`);
    if (tabElement) {
        // T·∫Øt tab ƒëang active
        document.querySelectorAll('#mainTabs .nav-link').forEach(btn => btn.classList.remove('active'));
        document.querySelectorAll('.tab-content .tab-pane').forEach(pane => pane.classList.remove('show', 'active'));

        // B·∫≠t tab m·ªõi
        tabElement.classList.add('active');
        document.getElementById(tabId).classList.add('show', 'active');
    }
}

// --- Helper Functions cho Base64 ---
function b64EncodeUnicode(str) {
  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g,
    function(match, p1) {
      return String.fromCharCode('0x' + p1);
    }));
}

function b64DecodeUnicode(str) {
  return decodeURIComponent(atob(str).split('').map(function(c) {
    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
  }).join(''));
}

// --- GitHub API Functions (Gi·ªØ nguy√™n) ---

async function fetchFileSha(cfg) {
    const filePath = `${cfg.folder}/${cfg.file}`;
    const apiUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}/contents/${filePath}`;
    
    try {
        const response = await fetch(apiUrl, {
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });
        
        if (response.ok) {
            const data = await response.json();
            currentSha = data.sha;
            return { sha: data.sha, content: data.content };
        } else if (response.status === 404) {
            currentSha = null; 
            return { sha: null };
        } else {
            throw new Error(`L·ªói khi l·∫•y SHA: ${response.statusText}`);
        }
    } catch (error) {
        console.error("L·ªói Fetch SHA:", error);
        throw new Error(`L·ªói k·∫øt n·ªëi ho·∫∑c API: ${error.message}`);
    }
}

async function loadFromGitHub() {
    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) return;

    try {
        updateStatus('configStatus', 'info', 'ƒêang t·∫£i d·ªØ li·ªáu t·ª´ GitHub...');
        const result = await fetchFileSha(cfg);
        
        if (result.content) {
            const jsonString = b64DecodeUnicode(result.content);
            const loadedState = JSON.parse(jsonString);

            state.matchesA = loadedState.matchesA || [];
            state.matchesB = loadedState.matchesB || [];
            
            const loadedSemifinals = loadedState.semifinals;
            if (loadedSemifinals && loadedSemifinals.length === 2 && 
                loadedSemifinals[0].teamA !== 'Nh·∫•t A' && loadedSemifinals[0].teamB !== 'Nh·∫•t B' ||
                loadedSemifinals[1].teamA !== 'Nh√¨ B' && loadedSemifinals[1].teamB !== 'Nh√¨ A'
            ) {
            } else {
                state.semifinals = loadedSemifinals || state.semifinals;
            }

            state.final = loadedState.final || state.final;
            
            renderMatches();
            tinhVaCapNhatXepHang();
            renderFinals();
            renderFinalResults();
            renderOverview();
            
            updateStatus('configStatus', 'success', `T·∫£i d·ªØ li·ªáu th√†nh c√¥ng t·ª´: ${cfg.owner}/${cfg.repo}/${cfg.folder}/${cfg.file}`);
            document.getElementById('lastSaved').textContent = `L·∫ßn t·∫£i: ${new Date().toLocaleTimeString('vi-VN')}`;
        } else {
            updateStatus('configStatus', 'warning', 'File d·ªØ li·ªáu ch∆∞a t·ªìn t·∫°i tr√™n GitHub. Vui l√≤ng nh·∫•n L∆∞u ho·∫∑c T·ª± ƒë·ªông l∆∞u ƒë·ªÉ t·∫°o file.');
        }

        startAutoSave();

    } catch (error) {
        updateStatus('configStatus', 'danger', `L·ªói t·∫£i d·ªØ li·ªáu: ${error.message}. Vui l√≤ng ki·ªÉm tra l·∫°i Token/Repo.`);
        console.error("L·ªói khi t·∫£i d·ªØ li·ªáu t·ª´ GitHub:", error);
    }
}

async function saveToGitHub() {
    if (!stateChanged) return;

    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) {
        console.warn("Kh√¥ng th·ªÉ t·ª± ƒë·ªông l∆∞u: Thi·∫øu c·∫•u h√¨nh GitHub.");
        document.getElementById('autoState').className = 'text-warning';
        document.getElementById('autoState').textContent = 'T·∫°m d·ª´ng (Thi·∫øu Config)';
        return;
    }

    document.getElementById('autoState').className = 'text-info';
    document.getElementById('autoState').textContent = 'ƒêang l∆∞u...';

    const apiUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}/contents/${cfg.folder}/${cfg.file}`;
    const content = b64EncodeUnicode(JSON.stringify(state));
    
    try {
        const result = await fetchFileSha(cfg);
        const sha = result.sha; 
        
        const payload = {
            message: `[Auto-save] C·∫≠p nh·∫≠t tr·∫°ng th√°i gi·∫£i ƒë·∫•u TKD l√∫c ${new Date().toLocaleString('vi-VN')}`,
            content: content,
            sha: sha 
        };

        const response = await fetch(apiUrl, {
            method: 'PUT',
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Content-Type': 'application/json',
                'Accept': 'application/vnd.github.v3+json'
            },
            body: JSON.stringify(payload)
        });

        if (response.ok) {
            const data = await response.json();
            currentSha = data.content.sha;
            stateChanged = false;
            document.getElementById('lastSaved').textContent = `L·∫ßn l∆∞u: ${new Date().toLocaleTimeString('vi-VN')}`;
            document.getElementById('autoState').className = 'text-success';
            document.getElementById('autoState').textContent = 'ƒê√£ L∆∞u';
        } else {
            throw new Error(`L·ªói HTTP: ${response.status} - ${response.statusText}`);
        }
    } catch (error) {
        console.error("L·ªói khi l∆∞u l√™n GitHub:", error);
        document.getElementById('autoState').className = 'text-danger';
        document.getElementById('autoState').textContent = 'L·ªói L∆∞u';
    }
}

async function checkConnection() {
    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) {
        updateStatus('configStatus', 'warning', 'Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß Owner, Repo v√† Token.');
        return;
    }

    try {
        updateStatus('configStatus', 'info', 'ƒêang ki·ªÉm tra k·∫øt n·ªëi...');
        
        const repoCheckUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}`;
        const repoResponse = await fetch(repoCheckUrl, {
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });

        if (!repoResponse.ok) {
            throw new Error(`L·ªói truy c·∫≠p kho l∆∞u tr·ªØ. M√£: ${repoResponse.status}. (Ki·ªÉm tra Token/Repo/Owner)`);
        }
        
        updateStatus('configStatus', 'success', 'K·∫øt n·ªëi GitHub th√†nh c√¥ng! ƒêang t·∫£i d·ªØ li·ªáu...');
        await loadFromGitHub();

    } catch (error) {
        updateStatus('configStatus', 'danger', `Ki·ªÉm tra k·∫øt n·ªëi th·∫•t b·∫°i: ${error.message}.`);
        console.error("L·ªói ki·ªÉm tra k·∫øt n·ªëi:", error);
    }
}

// --- C·∫•u h√¨nh & Kh·ªüi t·∫°o (Gi·ªØ nguy√™n) ---
function loadConfig() {
    const savedConfig = localStorage.getItem('pkb_config');
    if (savedConfig) {
        state.config = JSON.parse(savedConfig);
        document.getElementById('cfgOwner').value = state.config.owner || '';
        document.getElementById('cfgRepo').value = state.config.repo || '';
        document.getElementById('cfgFolder').value = state.config.folder || 'data';
        document.getElementById('cfgFile').value = state.config.file || 'state.json';
        document.getElementById('cfgToken').value = state.config.token || '';
    }
}

function saveConfig(){
  const cfg = {
    owner: document.getElementById('cfgOwner').value,
    repo: document.getElementById('cfgRepo').value,
    folder: document.getElementById('cfgFolder').value,
    file: document.getElementById('cfgFile').value,
    token: document.getElementById('cfgToken').value
  };
  state.config = cfg;
  localStorage.setItem('pkb_config', JSON.stringify(cfg));
  updateStatus('configStatus', 'success', 'ƒê√£ l∆∞u c·∫•u h√¨nh v√†o tr√¨nh duy·ªát. Vui l√≤ng Ki·ªÉm tra & T·∫£i D·ªØ li·ªáu.');
}

function updateStatus(id, type, message) {
    const statusDiv = document.getElementById(id);
    statusDiv.innerHTML = `<div class="alert alert-${type} p-2 mt-2">${message}</div>`;
}

function startAutoSave() {
    if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
    }
    
    if (state.config.token && state.config.owner && state.config.repo) {
        autoSaveInterval = setInterval(saveToGitHub, 60000);
        document.getElementById('autoState').className = 'text-warning';
        document.getElementById('autoState').textContent = 'Ho·∫°t ƒë·ªông...';
    } else {
        document.getElementById('autoState').className = 'text-danger';
        document.getElementById('autoState').textContent = 'T·∫Øt';
    }
}


window.onload = function() {
    loadConfig();
    
    if (state.config.token) {
        loadFromGitHub(); 
    } else {
        renderMatches();
        tinhVaCapNhatXepHang();
        renderFinals();
        renderFinalResults();
        renderOverview(); 
        startAutoSave(); 
    }
};

// --- Tab T·ªïng quan (Gi·ªØ nguy√™n) ---
function renderOverview() {
    const allPlayers = [...state.mixedTeams, ...state.maleTeams]
        .flatMap(team => team.split('/')).map(p => p.trim());
    const uniquePlayers = Array.from(new Set(allPlayers)).sort();
    
    const totalTeams = state.mixedTeams.length + state.maleTeams.length;
    const totalMatchesA = state.matchesA.length;
    const totalMatchesB = state.matchesB.length;
    const completedMatches = [...state.matchesA, ...state.matchesB].filter(m => m.scoreA !== null && m.scoreB !== null).length;
    const totalMatches = totalMatchesA + totalMatchesB;

    let html = `
        <div class="row">
            <div class="col-md-6 mb-4">
                <div class="card shadow-sm border-primary">
                    <div class="card-body">
                        <h5 class="card-title text-primary">üìä Th√¥ng tin Gi·∫£i ƒë·∫•u</h5>
                        <p><strong>T·ªïng s·ªë V·∫≠n ƒë·ªông vi√™n:</strong> <span class="badge bg-primary">${uniquePlayers.length}</span> ng∆∞·ªùi</p>
                        <p><strong>T·ªïng s·ªë ƒê·ªôi tham gia:</strong> <span class="badge bg-primary">${totalTeams}</span> ƒë·ªôi</p>
                        <p><strong>T·ªïng s·ªë Tr·∫≠n ƒë·∫•u (V√≤ng B·∫£ng):</strong> <span class="badge bg-primary">${totalMatches}</span> tr·∫≠n (ƒê√£ ho√†n th√†nh: ${completedMatches}/${totalMatches})</p>
                    </div>
                </div>
            </div>
            <div class="col-md-6 mb-4">
                <div class="card shadow-sm border-success">
                    <div class="card-body">
                        <h5 class="card-title text-success">üìã Ph√¢n lo·∫°i B·∫£ng ƒë·∫•u</h5>
                        <p><strong>B·∫£ng A (Nam - N·ªØ):</strong> ${state.mixedTeams.length} ƒë·ªôi (T·ªïng ${totalMatchesA} tr·∫≠n)</p>
                        <p><strong>B·∫£ng B (Nam):</strong> ${state.maleTeams.length} ƒë·ªôi (T·ªïng ${totalMatchesB} tr·∫≠n)</p>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card mt-2 shadow-sm">
            <div class="card-body">
                <h5 class="card-title text-secondary">üë• Danh s√°ch ƒê·ªôi & V·∫≠n ƒë·ªông vi√™n</h5>
                <div class="row">
                    <div class="col-lg-6">
                        <h6>B·∫£ng A (Nam-N·ªØ):</h6>
                        <ul class="list-group list-group-flush small">
                            ${state.mixedTeams.map(team => `<li class="list-group-item">${team}</li>`).join('')}
                        </ul>
                    </div>
                    <div class="col-lg-6">
                        <h6>B·∫£ng B (Nam):</h6>
                        <ul class="list-group list-group-flush small">
                            ${state.maleTeams.map(team => `<li class="list-group-item">${team}</li>`).join('')}
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    `;

    document.getElementById('overviewContent').innerHTML = html;
}

// --- V√≤ng B·∫£ng: T·∫°o L·ªãch C·ªë ƒê·ªãnh (Gi·ªØ nguy√™n logic) ---
function parseFixedSchedule(csvContent, mixedTeams, maleTeams) {
    const allMatches = [];
    const rows = csvContent.trim().split('\r\n');
    
    // B·ªè qua d√≤ng ti√™u ƒë·ªÅ ƒë·∫ßu ti√™n
    const dataRows = rows.slice(1); 
    
    const COURT_CONFIG = [
        { colIndex: 3, courtName: 'S√¢n 1' },
        { colIndex: 4, courtName: 'S√¢n 2' },
        { colIndex: 5, courtName: 'S√¢n 3' },
        { colIndex: 6, courtName: 'S√¢n 7' },
    ];
    
    dataRows.forEach(row => {
        const columns = row.split(','); 
        const time = columns[0] ? columns[0].trim() : '';

        COURT_CONFIG.forEach(court => {
            let matchString = columns[court.colIndex] ? columns[court.colIndex].trim() : '';

            if (matchString && matchString.toLowerCase() !== 'd·ª± ph√≤ng' && matchString !== '-' && matchString.includes(' - ')) {
                const teams = matchString.split(' - ');
                if (teams.length === 2) {
                    const teamA = teams[0].trim();
                    const teamB = teams[1].trim();
                    let bang = null;
                    
                    const teamAExistsA = mixedTeams.includes(teamA);
                    const teamBExistsA = mixedTeams.includes(teamB);
                    const teamAExistsB = maleTeams.includes(teamA);
                    const teamBExistsB = maleTeams.includes(teamB);
                    
                    if (teamAExistsA && teamBExistsA) {
                        bang = 'A'; 
                    } else if (teamAExistsB && teamBExistsB) {
                        bang = 'B'; 
                    } else {
                        return; 
                    }
                    
                    allMatches.push({
                        teamA, teamB, time, court: court.courtName, bang, scoreA: null, scoreB: null
                    });
                }
            }
        });
    });

    allMatches.sort((a, b) => {
        const timeToMinutes = (t) => {
            const [h, m] = t.split(':').map(Number);
            return h * 60 + m;
        };
        return timeToMinutes(a.time) - timeToMinutes(b.time);
    });

    return { matchesA: allMatches.filter(m => m.bang === 'A'), matchesB: allMatches.filter(m => m.bang === 'B') };
}

function taoLichCoDinh() {
    const csvData = parseFixedSchedule(FIXED_SCHEDULE_CSV, state.mixedTeams, state.maleTeams);
    state.matchesA = csvData.matchesA;
    state.matchesB = csvData.matchesB;
    renderMatches();
    tinhVaCapNhatXepHang();
    renderOverview();
    stateChanged = true;
    
    // Chuy·ªÉn tab v√† cu·ªôn t·ªõi v·ªã tr√≠ B·∫£ng A
    switchTab('matches');
    setTimeout(() => {
        const headerA = document.getElementById('scheduleAHeader');
        if (headerA) {
            headerA.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    }, 10);
    
    showModal('Th√†nh c√¥ng', 'ƒê√£ t·∫°o l·ªãch thi ƒë·∫•u **C·ªë ƒë·ªãnh** d·ª±a tr√™n d·ªØ li·ªáu. Vui l√≤ng ki·ªÉm tra l·ªãch t·∫°i tab **V√≤ng B·∫£ng**.');
}

// --- V√≤ng B·∫£ng: T·∫°o L·ªãch T·ªëi ∆Øu (Gi·ªØ nguy√™n) ---

function taoLichThiDauCungGio(){
  const start = new Date('2025-10-18T14:00:00');
  const duration = 15 * 60000; 

  state.matchesA = distributeMatchesSameTime(state.mixedTeams, ['S√¢n 2','S√¢n 3'], start, duration);
  state.matchesB = distributeMatchesSameTime(state.maleTeams, ['S√¢n 7','S√¢n 8'], start, duration);

  renderMatches();
  tinhVaCapNhatXepHang();
  renderOverview();
  stateChanged = true;
}

function distributeMatchesSameTime(teams, courts, start, duration){
  const matches = [];
  const nextTime = {}; 
  teams.forEach(t => nextTime[t] = new Date(start.getTime() - duration));

  let queue = [];
  for(let i=0; i < teams.length; i++){
    for(let j=i+1; j < teams.length; j++) queue.push([teams[i], teams[j]]);
  }

  let time = new Date(start);
  let totalCourts = courts.length;

  while(queue.length){
    let matchesScheduledInThisSlot = 0;
    
    for(let c=0; c < totalCourts && queue.length; c++){
      let idx = queue.findIndex(p => new Date(nextTime[p[0]]) <= time && new Date(nextTime[p[1]]) <= time);
      
      if(idx >= 0){
        let [teamA, teamB] = queue.splice(idx,1)[0];
        
        matches.push({
          teamA, 
          teamB, 
          scoreA: null, 
          scoreB: null, 
          time: time.toLocaleTimeString('vi-VN',{hour:'2-digit',minute:'2-digit'}), 
          court: courts[c],
          // G√°n 'A' ho·∫∑c 'B' cho b·∫£ng (c·∫ßn thi·∫øt cho Import/Export)
          bang: state.mixedTeams.includes(teamA) ? 'A' : 'B' 
        });
        
        nextTime[teamA] = new Date(time.getTime() + duration);
        nextTime[teamB] = new Date(time.getTime() + duration);
        matchesScheduledInThisSlot++;
      }
    }
    
    if (matchesScheduledInThisSlot > 0 || totalCourts > 0) {
      time = new Date(time.getTime() + duration);
    } else if (queue.length > 0) {
        time = new Date(time.getTime() + duration);
    } else {
        break; 
    }
  }

  return matches;
}


// --- V√≤ng B·∫£ng: ƒêi·ªÅn k·∫øt qu·∫£ T·ª± ƒë·ªông (Gi·ªØ nguy√™n) ---
function autoFillScores() {
    const fillMatchScores = (matches) => {
        matches.forEach(m => {
            if (m.scoreA === null && m.scoreB === null) {
                const winnerScore = 11;
                const loserScore = Math.floor(Math.random() * 11);
                
                if (Math.random() < 0.5) {
                    m.scoreA = winnerScore;
                    m.scoreB = loserScore;
                } else {
                    m.scoreA = loserScore;
                    m.scoreB = winnerScore;
                }
            }
        });
    };

    fillMatchScores(state.matchesA);
    fillMatchScores(state.matchesB);
    
    renderMatches();
    tinhVaCapNhatXepHang();
    renderOverview();
    stateChanged = true;
}


// --- V√≤ng B·∫£ng: Hi·ªÉn th·ªã v√† C·∫≠p nh·∫≠t T·ªâ s·ªë (Gi·ªØ nguy√™n) ---
function renderMatches(){
  document.getElementById('tableMatchesA').innerHTML = renderMatchesTable(state.matchesA,'A');
  document.getElementById('tableMatchesB').innerHTML = renderMatchesTable(state.matchesB,'B');
}

function renderMatchesTable(list,id){
  if(!list.length)return'<div>Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u.</div>';
  let html="<div class='table-responsive'><table class='table table-bordered table-sm'><thead><tr><th>ƒê·ªôi A</th><th>ƒê·ªôi B</th><th class='text-center'>T·ªâ s·ªë</th><th>Gi·ªù</th><th>S√¢n</th></tr></thead><tbody>";
  list.forEach((m,i)=>{
    html+=`<tr>
      <td>${m.teamA}</td>
      <td>${m.teamB}</td>
      <td class='match-score-cell d-flex justify-content-center align-items-center gap-1'>
        <input type='number' min='0' value='${m.scoreA !== null ? m.scoreA : ''}' onchange='capNhatTiSo(this, "match", "${id}", ${i}, true)' class='form-control form-control-sm'> 
        - 
        <input type='number' min='0' value='${m.scoreB !== null ? m.scoreB : ''}' onchange='capNhatTiSo(this, "match", "${id}", ${i}, false)' class='form-control form-control-sm'>
      </td>
      <td>${m.time}</td>
      <td>${m.court}</td>
    </tr>`;
  });
  return html+="</tbody></table></div>";
}

function capNhatTiSo(inputElement, type, id, index, isA){
  const val = inputElement.value;
  const score = val === '' ? null : (parseInt(val) >= 0 ? parseInt(val) : 0); 

  if (type === 'match') {
      const list = id === 'A' ? state.matchesA : state.matchesB;
      const match = list[index];
      
      let scoreA_new = isA ? score : match.scoreA;
      let scoreB_new = isA ? match.scoreB : score;
      
      const scoreA_old = match.scoreA;
      const scoreB_old = match.scoreB;

      if (scoreA_new !== null && scoreB_new !== null) {
          if (scoreA_new < 0 || scoreA_new > 11 || scoreB_new < 0 || scoreB_new > 11) {
              showModal('L·ªói Nh·∫≠p ƒêi·ªÉm', 'ƒêi·ªÉm v√≤ng b·∫£ng ph·∫£i n·∫±m trong kho·∫£ng $0 \\le \\text{ƒêi·ªÉm} \\le 11$.');
              inputElement.value = isA ? scoreA_old : scoreB_old;
              return;
          }
          if (scoreA_new === 11 && scoreB_new >= 11 || scoreB_new === 11 && scoreA_new >= 11) {
              showModal('L·ªói Nh·∫≠p ƒêi·ªÉm', `T·ªâ s·ªë kh√¥ng h·ª£p l·ªá (${scoreA_new}-${scoreB_new}). N·∫øu m·ªôt ƒë·ªôi ƒë·∫°t 11 ƒëi·ªÉm, ƒë·ªôi kia ph·∫£i $< 11$.`);
              inputElement.value = isA ? scoreA_old : scoreB_old;
              return;
          }
      }
      
      if(isA) match.scoreA = score;
      else match.scoreB = score;
      
      tinhVaCapNhatXepHang();
  } else if (type === 'semifinal') {
      if(isA) state.semifinals[index].scoreA = score;
      else state.semifinals[index].scoreB = score;
      updateMatchResult(state.semifinals[index]);
      updateFinalMatch();
  } else if (type === 'final') {
      if(isA) state.final.scoreA = score;
      else state.final.scoreB = score;
      updateMatchResult(state.final);
  }
  
  if (type !== 'match') {
      renderFinals();
      renderFinalResults();
  }
  
  renderOverview();
  stateChanged = true;
}

// --- V√≤ng B·∫£ng: T√≠nh v√† Hi·ªÉn th·ªã X·∫øp H·∫°ng Li√™n T·ª•c (Gi·ªØ nguy√™n) ---
function tinhVaCapNhatXepHang(){
  const A = tinhDiemBang(state.matchesA, 'A');
  const B = tinhDiemBang(state.matchesB, 'B');
  
  state.tableA = A; 
  state.tableB = B;

  scheduleFinalsAuto();
  
  renderBangXepHang('A', A); 
  renderBangXepHang('B', B);
}

function tinhDiemBang(matches, bangId){
  const teamsInMatch = new Set();
  matches.forEach(m => {
      teamsInMatch.add(m.teamA);
      teamsInMatch.add(m.teamB);
  });
  
  const table = {};
  teamsInMatch.forEach(team => table[team] = {team, wins: 0, losses: 0, pointsW: 0, pointsL: 0, bang: bangId});

  matches.forEach(m => {
    if(!table[m.teamA] || !table[m.teamB]) return;
    if(m.scoreA == null || m.scoreB == null) return;
    
    const aWin = m.scoreA > m.scoreB; 
    const bWin = m.scoreB > m.scoreA;
    
    if(aWin) {
      table[m.teamA].wins++; 
      table[m.teamB].losses++;
    } else if(bWin) {
      table[m.teamB].wins++; 
      table[m.teamA].losses++;
    }
    
    table[m.teamA].pointsW += m.scoreA; 
    table[m.teamA].pointsL += m.scoreB;
    table[m.teamB].pointsW += m.scoreB; 
    table[m.teamB].pointsL += m.scoreA;
  });
  
  let list = Object.values(table);
  list.forEach(t => { 
    t.diff = t.pointsW - t.pointsL; 
    t.points = t.wins * 2; 
  });
  
  // S·∫Øp x·∫øp: ƒêi·ªÉm > Hi·ªáu s·ªë > ƒêi·ªÉm th·∫Øng > T√™n ƒë·ªôi
  list.sort((a,b) => 
    b.points - a.points || 
    b.diff - a.diff || 
    b.pointsW - a.pointsW || 
    a.team.localeCompare(b.team) 
  ); 
  
  return list;
}

function renderBangXepHang(bang,list){
  let html=`<h6 class="mt-4">B·∫£ng ${bang}</h6><div class='table-responsive'><table class='table table-striped table-sm'><thead><tr><th>H·∫°ng</th><th>ƒê·ªôi</th><th>Th·∫Øng</th><th>Thua</th><th>ƒêi·ªÉm</th><th>Hi·ªáu s·ªë</th></tr></thead><tbody>`;
  list.forEach((r, index)=>{ 
    html+=`<tr>
      <td>${index + 1}</td>
      <td>${r.team}</td>
      <td>${r.wins}</td>
      <td>${r.losses}</td>
      <td><span class="badge bg-primary">${r.points}</span></td>
      <td>${r.diff}</td>
    </tr>` 
  });
  html+='</tbody></table></div>';
  
  const targetId = bang === 'A' ? 'rankingTableA' : 'rankingTableB';
  let targetElement = document.getElementById(targetId);

  if (!targetElement) {
      targetElement = document.createElement('div');
      targetElement.id = targetId;
      document.getElementById('rankingTables').appendChild(targetElement);
  }
  
  targetElement.innerHTML = html;
}

// --- Import/Export L·ªãch thi ƒë·∫•u ---

/**
 * X·ª≠ l√Ω s·ª± ki·ªán khi file CSV ƒë∆∞·ª£c ch·ªçn.
 */
function handleFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const csvContent = e.target.result;
            parseImportedSchedule(csvContent);
            event.target.value = null; // Reset input file
        } catch (error) {
            showModal('L·ªói Import', `Kh√¥ng th·ªÉ ƒë·ªçc file: ${error.message}. Vui l√≤ng ki·ªÉm tra ƒë·ªãnh d·∫°ng CSV.`);
        }
    };
    reader.readAsText(file, 'UTF-8');
}

/**
 * Ph√¢n t√≠ch c√∫ ph√°p file CSV ƒë∆°n gi·∫£n (xu·∫•t t·ª´ ch·ª©c nƒÉng Export) ƒë·ªÉ c·∫≠p nh·∫≠t l·ªãch.
 * ƒê·ªãnh d·∫°ng mong mu·ªën: B·∫£ng,Gi·ªù,S√¢n,ƒê·ªôi A,ƒê·ªôi B,T·ªâ s·ªë A,T·ªâ s·ªë B
 */
function parseImportedSchedule(csvContent) {
    const rows = csvContent.trim().split('\n');
    if (rows.length < 2) {
        return showModal('L·ªói D·ªØ li·ªáu', 'File CSV kh√¥ng ch·ª©a d·ªØ li·ªáu tr·∫≠n ƒë·∫•u.');
    }

    const newMatchesA = [];
    const newMatchesB = [];
    const header = rows[0].split(',').map(h => h.trim());
    
    // Ki·ªÉm tra Header
    const expectedHeader = ['B·∫£ng', 'Gi·ªù', 'S√¢n', 'ƒê·ªôi A', 'ƒê·ªôi B', 'T·ªâ s·ªë A', 'T·ªâ s·ªë B'];
    if (header.slice(0, 5).join(',') !== expectedHeader.slice(0, 5).join(',')) {
        return showModal('L·ªói ƒê·ªãnh d·∫°ng', `ƒê·ªãnh d·∫°ng Header kh√¥ng ƒë√∫ng. C·∫ßn: ${expectedHeader.join(',')}`);
    }

    // X·ª≠ l√Ω t·ª´ng d√≤ng d·ªØ li·ªáu
    rows.slice(1).forEach((row, rowIndex) => {
        // S·ª≠ d·ª•ng regex ƒë·ªÉ x·ª≠ l√Ω c√°c d·∫•u ph·∫©y b√™n trong d·∫•u ngo·∫∑c k√©p (n·∫øu c√≥, m·∫∑c d√π kh√¥ng khuy·∫øn kh√≠ch cho t√™n ƒë·ªôi)
        // Hi·ªán t·∫°i, ta d√πng split ƒë∆°n gi·∫£n.
        const columns = row.split(',').map(c => c.trim());

        if (columns.length >= 7) {
            const [bang, time, court, teamA, teamB, scoreAStr, scoreBStr] = columns;

            // Ki·ªÉm tra t√≠nh h·ª£p l·ªá c·ªßa ƒë·ªôi v√† b·∫£ng
            const isValidA = state.mixedTeams.includes(teamA) && state.mixedTeams.includes(teamB) && bang === 'A';
            const isValidB = state.maleTeams.includes(teamA) && state.maleTeams.includes(teamB) && bang === 'B';

            if (!isValidA && !isValidB) {
                // C√≥ th·ªÉ b·ªè qua d√≤ng n√†y ho·∫∑c b√°o l·ªói
                console.warn(`B·ªè qua d√≤ng ${rowIndex + 2}: ƒê·ªôi/B·∫£ng kh√¥ng h·ª£p l·ªá (${teamA} vs ${teamB}, B·∫£ng ${bang})`);
                return;
            }

            const match = {
                teamA: teamA,
                teamB: teamB,
                time: time,
                court: court,
                bang: bang,
                scoreA: scoreAStr === '' || isNaN(parseInt(scoreAStr)) ? null : parseInt(scoreAStr),
                scoreB: scoreBStr === '' || isNaN(parseInt(scoreBStr)) ? null : parseInt(scoreBStr)
            };

            if (bang === 'A') {
                newMatchesA.push(match);
            } else if (bang === 'B') {
                newMatchesB.push(match);
            }
        }
    });

    if (newMatchesA.length === 0 && newMatchesB.length === 0) {
        return showModal('L·ªói Import', 'Kh√¥ng t√¨m th·∫•y tr·∫≠n ƒë·∫•u h·ª£p l·ªá n√†o trong file.');
    }

    state.matchesA = newMatchesA;
    state.matchesB = newMatchesB;

    renderMatches();
    tinhVaCapNhatXepHang();
    renderOverview();
    stateChanged = true;
    showModal('Th√†nh c√¥ng', `ƒê√£ import th√†nh c√¥ng ${newMatchesA.length} tr·∫≠n B·∫£ng A v√† ${newMatchesB.length} tr·∫≠n B·∫£ng B.`);
}

/**
 * Xu·∫•t l·ªãch thi ƒë·∫•u hi·ªán t·∫°i (bao g·ªìm t·ªâ s·ªë) ra file CSV.
 */
function exportSchedule() {
    const allMatches = [...state.matchesA, ...state.matchesB];
    const header = ['B·∫£ng', 'Gi·ªù', 'S√¢n', 'ƒê·ªôi A', 'ƒê·ªôi B', 'T·ªâ s·ªë A', 'T·ªâ s·ªë B'];
    let csv = header.join(',') + '\n';

    allMatches.forEach(m => {
        const row = [
            m.bang,
            m.time,
            m.court,
            m.teamA,
            m.teamB,
            m.scoreA !== null ? m.scoreA : '',
            m.scoreB !== null ? m.scoreB : ''
        ];
        csv += row.join(',') + '\n';
    });

    // T·∫°o Blob v√† link t·∫£i xu·ªëng
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    
    link.setAttribute("href", url);
    link.setAttribute("download", `lich_thi_dau_tkd_${new Date().toISOString().slice(0,10)}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    showModal('Xu·∫•t file th√†nh c√¥ng', 'File **lich\_thi\_dau\_tkd.csv** ƒë√£ ƒë∆∞·ª£c t·∫£i xu·ªëng.');
}


// --- V√≤ng Chung K·∫øt: L√™n L·ªãch v√† C·∫≠p Nh·∫≠t (Gi·ªØ nguy√™n) ---

function scheduleFinalsAuto() {
    
    const teamA1 = state.tableA[0]?.team || 'Nh·∫•t A';
    const teamA2 = state.tableA[1]?.team || 'Nh√¨ A';
    const teamB1 = state.tableB[0]?.team || 'Nh·∫•t B';
    const teamB2 = state.tableB[1]?.team || 'Nh√¨ B';

    if (!(teamA1.startsWith('Nh·∫•t') || teamA2.startsWith('Nh√¨') || teamB1.startsWith('Nh·∫•t') || teamB2.startsWith('Nh√¨'))) {
        
        let needsUpdate = false;
        
        // SF1: Nh·∫•t A vs Nh·∫•t B
        if (state.semifinals[0].teamA !== teamA1 || state.semifinals[0].teamB !== teamB1) {
             state.semifinals[0] = { ...state.semifinals[0], teamA: teamA1, teamB: teamB1, scoreA: null, scoreB: null, winner: null, loser: null };
             needsUpdate = true;
        }
        // SF2: Nh√¨ B vs Nh√¨ A
        if (state.semifinals[1].teamA !== teamB2 || state.semifinals[1].teamB !== teamA2) {
             state.semifinals[1] = { ...state.semifinals[1], teamA: teamB2, teamB: teamA2, scoreA: null, scoreB: null, winner: null, loser: null };
             needsUpdate = true;
        }
        
        if (needsUpdate) {
            stateChanged = true;
        }
    }
    
    updateFinalMatch();
    
    renderFinals();
    renderFinalResults();
}

function updateMatchResult(match) {
    if (match.scoreA !== null && match.scoreB !== null) {
        if (match.scoreA > match.scoreB) {
            match.winner = match.teamA;
            match.loser = match.teamB;
        } else if (match.scoreB > match.scoreA) {
            match.winner = match.teamB;
            match.loser = match.teamA;
        } else {
            match.winner = null; 
            match.loser = null;
        }
        stateChanged = true;
    } else {
        match.winner = null;
        match.loser = null;
    }
}

function updateFinalMatch() {
    const sf1Winner = state.semifinals[0].winner;
    const sf2Winner = state.semifinals[1].winner;
    
    let finalTeamA = 'Th·∫Øng SF1';
    let finalTeamB = 'Th·∫Øng SF2';
    let teamUpdated = false;
    
    if (sf1Winner && state.final.teamA !== sf1Winner) {
        finalTeamA = sf1Winner;
        state.final.scoreA = null; 
        state.final.scoreB = null; 
        teamUpdated = true;
    } else if (sf1Winner) {
        finalTeamA = sf1Winner;
    }
    
    if (sf2Winner && state.final.teamB !== sf2Winner) {
        finalTeamB = sf2Winner;
        state.final.scoreA = null; 
        state.final.scoreB = null; 
        teamUpdated = true;
    } else if (sf2Winner) {
        finalTeamB = sf2Winner;
    }

    if (teamUpdated) {
        stateChanged = true;
    }
    
    state.final.teamA = finalTeamA;
    state.final.teamB = finalTeamB;
    updateMatchResult(state.final);
}

function renderFinals(){
    let sfHtml = `<div class='table-responsive'><table class='table table-bordered table-sm'><thead><tr><th>Tr·∫≠n</th><th>ƒê·ªôi A</th><th>ƒê·ªôi B</th><th class='text-center'>T·ªâ s·ªë</th><th>K·∫øt qu·∫£</th></tr></thead><tbody>`;
    state.semifinals.forEach((m, i) => {
        const teamAClass = m.winner === m.teamA ? 'winner' : (m.loser === m.teamA ? 'loser' : '');
        const teamBClass = m.winner === m.teamB ? 'winner' : (m.loser === m.teamB ? 'loser' : '');
        const disabled = m.teamA.startsWith('Nh·∫•t') || m.teamB.startsWith('Nh√¨') ? 'disabled' : '';

        sfHtml += `<tr>
            <td>${m.id} (${m.time}, ${m.court})</td>
            <td class="${teamAClass}">${m.teamA}</td>
            <td class="${teamBClass}">${m.teamB}</td>
            <td class='match-score-cell d-flex justify-content-center align-items-center gap-1'>
                <input type='number' min='0' value='${m.scoreA !== null ? m.scoreA : ''}' onchange='capNhatTiSo(this, "semifinal", "${m.id}", ${i}, true)' class='form-control form-control-sm' ${disabled}> 
                - 
                <input type='number' min='0' value='${m.scoreB !== null ? m.scoreB : ''}' onchange='capNhatTiSo(this, "semifinal", "${m.id}", ${i}, false)' class='form-control form-control-sm' ${disabled}>
            </td>
            <td>${m.winner ? m.winner + ' th·∫Øng' : 'ƒêang ƒë·∫•u'}</td>
        </tr>`;
    });
    sfHtml += `</tbody></table></div>`;
    document.getElementById('semifinalMatches').innerHTML = sfHtml;

    const final = state.final;
    const teamAClassF = final.winner === final.teamA ? 'winner' : (final.loser === final.teamA ? 'loser' : '');
    const teamBClassF = final.winner === final.teamB ? 'winner' : (final.loser === final.teamB ? 'loser' : '');
    
    const disabledF = final.teamA.startsWith('Th·∫Øng') || final.teamB.startsWith('Th·∫Øng') ? 'disabled' : '';

    let fHtml = `<div class='table-responsive'><table class='table table-bordered table-sm'><thead><tr><th>Tr·∫≠n</th><th>ƒê·ªôi A</th><th>ƒê·ªôi B</th><th class='text-center'>T·ªâ s·ªë</th><th>K·∫øt qu·∫£</th></tr></thead><tbody>`;
    fHtml += `<tr>
        <td>Chung k·∫øt (${final.time}, ${final.court})</td>
        <td class="${teamAClassF}">${final.teamA}</td>
        <td class="${teamBClassF}">${final.teamB}</td>
        <td class='match-score-cell d-flex justify-content-center align-items-center gap-1'>
            <input type='number' min='0' value='${final.scoreA !== null ? final.scoreA : ''}' onchange='capNhatTiSo(this, "final", "${final.id}", 0, true)' class='form-control form-control-sm' ${disabledF}> 
            - 
            <input type='number' min='0' value='${final.scoreB !== null ? final.scoreB : ''}' onchange='capNhatTiSo(this, "final", "${final.id}", 0, false)' class='form-control form-control-sm' ${disabledF}>
        </td>
        <td>${final.winner ? final.winner + ' V√¥ ƒë·ªãch' : 'ƒêang ƒë·∫•u'}</td>
    </tr>`;
    fHtml += `</tbody></table></div>`;
    document.getElementById('finalMatch').innerHTML = fHtml;
}

// --- C·∫¨P NH·∫¨T: V·∫Ω c√¢y gi·∫£i ƒë·∫•u v√† l√†m n·ªïi b·∫≠t k·∫øt qu·∫£ ---
function renderFinalResults() {
    const final = state.final;
    const sf1 = state.semifinals[0];
    const sf2 = state.semifinals[1];
    
    const sf1Loser = sf1.loser;
    const sf2Loser = sf2.loser;
    
    let thirdPlaceTeams = [];
    if (sf1Loser) thirdPlaceTeams.push(sf1Loser);
    if (sf2Loser) thirdPlaceTeams.push(sf2Loser);
    thirdPlaceTeams.sort(); 

    // 1. L·∫•y danh s√°ch ƒë·ªôi b·ªã lo·∫°i t·ª´ V√≤ng B·∫£ng (H·∫°ng 3, 4, 5, 6)
    const teamsOutA = state.tableA.slice(2);
    const teamsOutB = state.tableB.slice(2);
    const teamsOut = [...teamsOutA, ...teamsOutB];
    teamsOut.sort((a, b) => {
        // ∆Øu ti√™n ƒë·ªôi c√≥ th·ª© h·∫°ng cao h∆°n (th·ª© 3 tr∆∞·ªõc th·ª© 6)
        const rankA = state.tableA.findIndex(t => t.team === a.team) !== -1 ? state.tableA.findIndex(t => t.team === a.team) + 1 : state.tableB.findIndex(t => t.team === a.team) + 1;
        const rankB = state.tableA.findIndex(t => t.team === b.team) !== -1 ? state.tableA.findIndex(t => t.team === b.team) + 1 : state.tableB.findIndex(t => t.team === b.team) + 1;
        if (rankA !== rankB) return rankA - rankB;
        return a.team.localeCompare(b.team);
    });
    
    // --- B·∫Øt ƒë·∫ßu v·∫Ω C√¢y Gi·∫£i ƒë·∫•u ---
    let html = '';

    // A. B·∫£ng T√≥m T·∫Øt K·∫øt Qu·∫£ Cu·ªëi C√πng
    html += `
        <div class="d-flex flex-wrap justify-content-center gap-4 mb-5">
            <div class="team-box champion">
                <h4 class="text-success">ü•á V√î ƒê·ªäCH</h4>
                <p class="mb-0 fs-5">${final.winner || 'Ch∆∞a x√°c ƒë·ªãnh'}</p>
            </div>
            <div class="team-box runner-up">
                <h4 class="text-warning">ü•à √Å QU√ÇN</h4>
                <p class="mb-0 fs-5">${final.loser || 'Ch∆∞a x√°c ƒë·ªãnh'}</p>
            </div>
            <div class="team-box third-place">
                <h4 class="text-primary">ü•â ƒê·ªíNG H·∫†NG 3</h4>
                <p class="mb-0 fs-5">${thirdPlaceTeams.length === 2 ? thirdPlaceTeams.join(' & ') : 'Ch∆∞a x√°c ƒë·ªãnh'}</p>
            </div>
        </div>
    `;

    // B. C√¢y Gi·∫£i ƒë·∫•u (Semi-finals v√† Final)
    
    // H√†m render Match Box
    const renderMatchBox = (m, roundLabel) => {
        const teamAClass = m.winner === m.teamA ? 'winner-bracket' : (m.loser === m.teamA ? 'loser-bracket' : '');
        const teamBClass = m.winner === m.teamB ? 'winner-bracket' : (m.loser === m.teamB ? 'loser-bracket' : '');
        
        return `
            <div class="match-up ${roundLabel === 'Chung k·∫øt' ? 'match-up-final' : ''}">
                <div class="round-label text-center mb-1">${roundLabel} (${m.time}, ${m.court})</div>
                <div class="team-name ${teamAClass}">
                    <span>${m.teamA}</span> 
                    <span class="match-score">${m.scoreA !== null ? m.scoreA : ''}</span>
                </div>
                <hr class="my-1">
                <div class="team-name ${teamBClass}">
                    <span>${m.teamB}</span> 
                    <span class="match-score">${m.scoreB !== null ? m.scoreB : ''}</span>
                </div>
                ${m.winner ? `<div class="mt-2 text-center small text-success">**${m.winner}** th·∫Øng</div>` : ''}
            </div>
        `;
    };
    
    // Layout d√πng Flexbox ƒë·ªÉ x·∫øp 2 b√°n k·∫øt v√† 1 chung k·∫øt
    html += `
        <h5 class="mt-4 text-center">C√¢y Thi ƒë·∫•u V√≤ng Chung K·∫øt</h5>
        <div class="bracket-layout">
            <div class="round-sf d-flex justify-content-center gap-5 align-items-center">
                <div class="sf-match">
                    ${renderMatchBox(sf1, 'B√°n k·∫øt 1')}
                </div>
                <div class="final-link d-none d-md-block" style="flex-shrink: 0; align-self: center;">
                    </div>
                <div class="sf-match">
                    ${renderMatchBox(sf2, 'B√°n k·∫øt 2')}
                </div>
            </div>
            
            <div class="round-final d-flex justify-content-center mt-5">
                ${renderMatchBox(final, 'Chung k·∫øt')}
            </div>
        </div>
    `;

    // C. ƒê·ªôi b·ªã lo·∫°i t·ª´ V√≤ng B·∫£ng
    html += `
        <h5 class="mt-5 text-center teams-out-header">ƒê·ªôi b·ªã lo·∫°i t·ª´ V√≤ng B·∫£ng (H·∫°ng 5-6)</h5>
        <div class="teams-out d-flex flex-wrap justify-content-center gap-3">
            ${teamsOut.map(t => {
                const rank = state.tableA.includes(t) ? state.tableA.indexOf(t) + 1 : state.tableB.indexOf(t) + 1;
                return `<span class="badge bg-secondary p-2 text-wrap">${t.team} (H·∫°ng ${rank} B·∫£ng ${t.bang})</span>`;
            }).join('')}
        </div>
        <p class="text-center small text-muted mt-2">(C√°c ƒë·ªôi x·∫øp h·∫°ng 3, 4, 5, 6 t·ª´ m·ªói b·∫£ng ƒë·∫•u kh√¥ng l·ªçt v√†o B√°n k·∫øt)</p>
    `;

    document.getElementById('tournamentBracket').innerHTML = html;
}
</script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

<script>
const CALENDAR_CSV_URL = 'https://raw.githubusercontent.com/cqtin2024/pickleball/main/data/CalendarRound.csv';
const STATE_JSON_URL = 'https://raw.githubusercontent.com/cqtin2024/pickleball/main/data/state.json';
let roundsSchedule = [];

function parseCSV(content) {
  const lines = content.trim().split(/\r?\n/);
  const header = lines[0].split(',').map(h => h.trim().toLowerCase());
  const rows = lines.slice(1).map(l => l.split(',').map(c => c.trim()));
  return { header, rows };
}

function loadCalendarRound() {
  appendAutoSaveLog('‚è≥ B·∫Øt ƒë·∫ßu t·∫£i CalendarRound.csv t·ª´ GitHub...');
  fetch(CALENDAR_CSV_URL).then(r => {
    if (!r.ok) throw new Error('HTTP ' + r.status);
    return r.text();
  }).then(text => {
    const parsed = parseCSV(text);
    const rows = parsed.rows;
    if (rows.length === 0) throw new Error('Kh√¥ng c√≥ d·ªØ li·ªáu trong CSV');
    roundsSchedule = [];
    let id = 1;
    rows.forEach(r => {
      const date = r[0] || '';
      const time = r[1] || '';
      const court = r[2] || 'S√¢n 1';
      const teamA = r[3] || '';
      const teamB = r[4] || '';
      roundsSchedule.push({ id: 'R' + id++, date, time, court, teamA, teamB, scoreA: null, scoreB: null });
    });
    appendAutoSaveLog('‚úÖ T·∫£i th√†nh c√¥ng CalendarRound.csv ‚Äî ' + roundsSchedule.length + ' tr·∫≠n');
    document.getElementById('roundsLoadStatus').textContent = 'T·∫£i th√†nh c√¥ng: ' + roundsSchedule.length + ' tr·∫≠n';
    renderRoundsByCourt();
    setTimeout(syncScoresFromState, 500);
  }).catch(err => {
    appendAutoSaveLog('‚ö†Ô∏è Kh√¥ng t·∫£i ƒë∆∞·ª£c CalendarRound.csv: ' + err.message + '. S·ª≠ d·ª•ng l·ªãch m·∫∑c ƒë·ªãnh.');
    document.getElementById('roundsLoadStatus').textContent = 'D√πng l·ªãch m·∫∑c ƒë·ªãnh.';
    loadDefaultSchedule();
  });
}

function loadDefaultSchedule() {
  roundsSchedule = [
    { id: 'R1', date: '', time: '14:00', court: 'S√¢n 1', teamA: 'Team A', teamB: 'Team B', scoreA: null, scoreB: null },
    { id: 'R2', date: '', time: '14:00', court: 'S√¢n 2', teamA: 'Team C', teamB: 'Team D', scoreA: null, scoreB: null },
    { id: 'R3', date: '', time: '14:15', court: 'S√¢n 3', teamA: 'Team E', teamB: 'Team F', scoreA: null, scoreB: null },
    { id: 'R4', date: '', time: '14:15', court: 'S√¢n 4', teamA: 'Team G', teamB: 'Team H', scoreA: null, scoreB: null }
  ];
  appendAutoSaveLog('‚ÑπÔ∏è L·ªãch m·∫∑c ƒë·ªãnh ƒë√£ ƒë∆∞·ª£c n·∫°p: ' + roundsSchedule.length + ' tr·∫≠n');
  renderRoundsByCourt();
}

function renderRoundsByCourt() {
  const container = document.getElementById('roundsByCourt');
  container.innerHTML = '';
  const courts = ['S√¢n 1','S√¢n 2','S√¢n 3','S√¢n 4'];
  courts.forEach(courtName => {
    const matches = roundsSchedule.filter(m => (m.court || '').trim() === courtName).sort((a,b) => {
      const toMin = t => { const p = (t||'').split(':'); return (parseInt(p[0]||0)*60 + parseInt(p[1]||0)); };
      return toMin(a.time) - toMin(b.time);
    });
    const col = document.createElement('div');
    col.className = 'col-12 col-md-6';
    const card = document.createElement('div');
    card.className = 'card p-2 shadow-sm';
    let html = `<div class="card-body"><h6 class="card-title">${courtName} <small class="text-muted">(${matches.length} tr·∫≠n)</small></h6>`;
    if (matches.length === 0) {
      html += '<div class="small text-muted">Kh√¥ng c√≥ tr·∫≠n ƒë·∫•u.</div>';
    } else {
      html += '<ul class="list-group list-group-flush">';
      matches.forEach(m => {
        html += `<li class="list-group-item d-flex justify-content-between align-items-center">
          <div class="me-2" style="min-width:160px;"><strong>${m.time}</strong> ${m.date ? '- ' + m.date : ''}</div>
          <div class="flex-grow-1">${m.teamA} <span class="text-muted">vs</span> ${m.teamB}</div>
          <div class="mx-2">${m.scoreA !== null && m.scoreB !== null ? '<span class="badge bg-success">'+m.scoreA+'-'+m.scoreB+'</span>' : '<span class="badge bg-secondary">Ch∆∞a c√≥</span>'}</div>
          <div>
            <select class="form-select form-select-sm" onchange="changeCourtForMatch('${m.id}', this.value)" style="width:140px;display:inline-block;">
              <option value="">Chuy·ªÉn s√¢n...</option>
              <option>S√¢n 1</option><option>S√¢n 2</option><option>S√¢n 3</option><option>S√¢n 4</option>
            </select>
          </div>
        </li>`;
      });
      html += '</ul>';
    }
    html += '</div>';
    card.innerHTML = html;
    col.appendChild(card);
    container.appendChild(col);
  });
}

function changeCourtForMatch(id, newCourt) {
  if (!newCourt) return;
  const match = roundsSchedule.find(m => m.id === id);
  if (!match) return appendAutoSaveLog('‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y tr·∫≠n ' + id);
  const old = match.court;
  match.court = newCourt;
  appendAutoSaveLog('‚úÖ ƒê√£ chuy·ªÉn tr·∫≠n ' + id + ' t·ª´ ' + old + ' ‚Üí ' + newCourt);
  renderRoundsByCourt();
  stateChanged = true;
  setTimeout(() => { saveToGitHub(); }, 800);
}

async function syncScoresFromState() {
  appendAutoSaveLog('‚è≥ ƒê·ªìng b·ªô t·ªâ s·ªë t·ª´ state.json...');
  try {
    const resp = await fetch(STATE_JSON_URL);
    if (!resp.ok) throw new Error('HTTP ' + resp.status);
    const j = await resp.json();
    const allStateMatches = [...(j.matchesA||[]), ...(j.matchesB||[]), ...(j.semifinals||[]), (j.final ? [j.final] : [])];
    let updated = 0;
    roundsSchedule.forEach(m => {
      const found = allStateMatches.find(sm => {
        return (sm.teamA === m.teamA && sm.teamB === m.teamB) || (sm.teamA === m.teamB && sm.teamB === m.teamA);
      });
      if (found && (found.scoreA != null || found.scoreB != null)) {
        if (found.teamA === m.teamA && found.teamB === m.teamB) {
          m.scoreA = found.scoreA;
          m.scoreB = found.scoreB;
        } else {
          m.scoreA = found.scoreB;
          m.scoreB = found.scoreA;
        }
        updated++;
      }
    });
    if (updated > 0) {
      appendAutoSaveLog('‚úÖ ƒê√£ c·∫≠p nh·∫≠t t·ªâ s·ªë cho ' + updated + ' tr·∫≠n t·ª´ state.json');
    } else {
      appendAutoSaveLog('‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu t·ªâ s·ªë kh·ªõp cho c√°c tr·∫≠n trong l·ªãch.');
    }
    renderRoundsByCourt();
  } catch (err) {
    appendAutoSaveLog('‚ùå L·ªói khi ƒë·ªìng b·ªô t·ªâ s·ªë: ' + err.message);
    document.getElementById('roundsLoadStatus').textContent = 'L·ªói ƒë·ªìng b·ªô t·ªâ s·ªë';
  }
}

function exportAllState() {
  const filename = 'pickleball_data_' + new Date().toISOString().slice(0,10) + '.json';
  const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  appendAutoSaveLog('üì¶ ƒê√£ xu·∫•t to√†n b·ªô d·ªØ li·ªáu ra ' + filename);
}

document.querySelectorAll('#mainTabs button[data-bs-target="#matches"]').forEach(btn => {
  btn.addEventListener('shown.bs.tab', function (event) {
    if (!roundsSchedule || roundsSchedule.length === 0) {
      loadCalendarRound();
    } else {
      syncScoresFromState();
    }
  });
});

setTimeout(() => {
  try {
    const activeBtn = document.querySelector('#mainTabs button.active[data-bs-target="#matches"]');
    if (activeBtn) {
      loadCalendarRound();
    }
  } catch(e){}
}, 1000);

</script>


<script>
// Court configuration management
if(!window.state) window.state = {};
if(!state.config) state.config = {};
if(!Array.isArray(state.config.courts) || state.config.courts.length === 0){
  state.config.courts = [
    { name: "S√¢n 1", start: "14:00", duration: 240 },
    { name: "S√¢n 2", start: "14:00", duration: 240 },
    { name: "S√¢n 3", start: "14:00", duration: 240 },
    { name: "S√¢n 4", start: "14:00", duration: 240 }
  ];
}

// Render court config UI
function renderCourtConfig(){
  const container = document.getElementById('courtConfigList');
  if(!container) return;
  const courts = state.config.courts || [];
  container.innerHTML = '';
  if(courts.length === 0){
    container.innerHTML = '<div class="text-muted small">Ch∆∞a c√≥ s√¢n n√†o. Nh·∫•n "Th√™m s√¢n m·ªõi" ƒë·ªÉ b·∫Øt ƒë·∫ßu.</div>';
    return;
  }
  courts.forEach((c, idx) => {
    const row = document.createElement('div');
    row.className = 'border rounded p-2 mb-2';
    row.id = 'court-row-' + idx;
    row.innerHTML = `
      <div class="fw-bold mb-1">üèüÔ∏è S√¢n #${idx+1}</div>
      <div class="row g-2 align-items-center">
        <div class="col-md-4"><label class="form-label mb-0 small">T√™n s√¢n:</label>
          <input type="text" class="form-control form-control-sm court-name" value="${c.name}"></div>
        <div class="col-md-3"><label class="form-label mb-0 small">B·∫Øt ƒë·∫ßu:</label>
          <input type="time" class="form-control form-control-sm court-start" value="${c.start}"></div>
        <div class="col-md-3"><label class="form-label mb-0 small">Th·ªùi l∆∞·ª£ng (ph√∫t):</label>
          <input type="number" min="0" class="form-control form-control-sm court-duration" value="${c.duration}"></div>
        <div class="col-md-2 d-flex gap-1 mt-2 mt-md-0">
          <button class="btn btn-sm btn-outline-primary" title="L∆∞u" onclick="saveCourtConfig(${idx})">üíæ</button>
          <button class="btn btn-sm btn-outline-danger" title="X√≥a" onclick="deleteCourtConfig(${idx})">üóë</button>
        </div>
      </div>`;
    container.appendChild(row);
  });
}

// Add new court
function addCourtConfig(){
  state.config.courts = state.config.courts || [];
  const id = state.config.courts.length + 1;
  const newCourt = { name: "S√¢n " + id, start: "14:00", duration: 240 };
  state.config.courts.push(newCourt);
  appendAutoSaveLog("‚ûï ƒê√£ th√™m s√¢n m·ªõi: " + newCourt.name);
  renderCourtConfig();
  renderRoundsByCourt();
  stateChanged = true;
  setTimeout(()=>saveToGitHub(), 800);
}

// Delete court
function deleteCourtConfig(index){
  if(!state.config || !Array.isArray(state.config.courts)) return;
  const removed = state.config.courts.splice(index, 1)[0];
  appendAutoSaveLog("üóë ƒê√£ x√≥a " + (removed && removed.name ? removed.name : 's√¢n') );
  renderCourtConfig();
  renderRoundsByCourt();
  stateChanged = true;
  setTimeout(()=>saveToGitHub(), 800);
}

// Save court config (from inputs)
function saveCourtConfig(index){
  const row = document.getElementById('court-row-' + index);
  if(!row) return;
  const name = row.querySelector('.court-name').value.trim();
  const start = row.querySelector('.court-start').value.trim();
  const duration = parseInt(row.querySelector('.court-duration').value) || 0;
  if(!name){ alert('T√™n s√¢n kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng!'); return; }
  state.config.courts[index] = { name, start, duration };
  appendAutoSaveLog(`‚úÖ ƒê√£ l∆∞u c·∫•u h√¨nh ${name} (${start}, ${duration} ph√∫t)`);
  renderCourtConfig();
  renderRoundsByCourt();
  stateChanged = true;
  setTimeout(()=>saveToGitHub(), 800);
}

// Override renderRoundsByCourt to use dynamic courts list
if(typeof renderRoundsByCourt === 'function'){
  const _old = renderRoundsByCourt;
  renderRoundsByCourt = function(){
    const courts = (state.config && Array.isArray(state.config.courts) && state.config.courts.length)
      ? state.config.courts.map(c => c.name)
      : ['S√¢n 1','S√¢n 2','S√¢n 3','S√¢n 4'];
    const container = document.getElementById('roundsByCourt');
    if(!container) return;
    container.innerHTML = '';
    courts.forEach(courtName => {
      const matches = roundsSchedule.filter(m => (m.court || '').trim() === courtName).sort((a,b) => {
        const toMin = t => { const p = (t||'').split(':'); return (parseInt(p[0]||0)*60 + parseInt(p[1]||0)); };
        return toMin(a.time) - toMin(b.time);
      });
      const col = document.createElement('div');
      col.className = 'col-12 col-md-6';
      const card = document.createElement('div');
      card.className = 'card p-2 shadow-sm';
      let html = `<div class="card-body"><h6 class="card-title">${courtName} <small class="text-muted">(${matches.length} tr·∫≠n)</small></h6>`;
      if(matches.length===0){
        html += '<div class="small text-muted">Kh√¥ng c√≥ tr·∫≠n ƒë·∫•u.</div>';
      } else {
        html += '<ul class="list-group list-group-flush">';
        matches.forEach(m=>{
          const options = courts.map(c=>`<option ${c===m.court?'selected':''}>${c}</option>`).join('');
          html += `<li class="list-group-item d-flex justify-content-between align-items-center">
            <div class="me-2" style="min-width:160px;"><strong>${m.time}</strong> ${m.date ? '- '+m.date : ''}</div>
            <div class="flex-grow-1">${m.teamA} <span class="text-muted">vs</span> ${m.teamB}</div>
            <div class="mx-2">${m.scoreA !== null && m.scoreB !== null ? '<span class="badge bg-success">'+m.scoreA+'-'+m.scoreB+'</span>' : '<span class="badge bg-secondary">Ch∆∞a c√≥</span>'}</div>
            <div><select class="form-select form-select-sm" onchange="changeCourtForMatch('${m.id}', this.value)" style="width:140px;display:inline-block;">${options}</select></div>
          </li>`;
        });
        html += '</ul>';
      }
      html += '</div>';
      card.innerHTML = html;
      col.appendChild(card);
      container.appendChild(col);
    });
  };
}

// render on load
document.addEventListener('DOMContentLoaded', function(){
  try { renderCourtConfig(); } catch(e){ console.warn(e); }
});
</script>


<style>
.match-item.conflict { border: 2px solid #dc3545 !important; background-color: #ffe6e6 !important; }
#roundsWarning { margin-bottom: 10px; }
</style>

<script>
(function(){
  function safe(fn){ try{ return fn(); }catch(e){ console && console.warn && console.warn(e); } }

  // Confirm before applying schedule changes
  window.updateMatchSchedule = function(id, btn){
    const li = btn.closest('.match-item');
    if(!li) return appendAutoSaveLog && appendAutoSaveLog('‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y h√†ng UI cho ' + id);
    const select = li.querySelector('.court-select');
    const timeInput = li.querySelector('.match-time-input');
    const newCourt = select ? select.value : null;
    const newTime = timeInput ? timeInput.value : null;
    const m = (window.roundsSchedule||[]).find(x=>x.id===id);
    if(!m) return appendAutoSaveLog && appendAutoSaveLog('‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y tr·∫≠n ' + id);

    const oldCourt = m.court || '';
    const oldTime = m.time || '';
    if((newCourt===oldCourt || !newCourt) && (newTime===oldTime || !newTime)){
      appendAutoSaveLog && appendAutoSaveLog('‚ÑπÔ∏è Kh√¥ng c√≥ thay ƒë·ªïi cho tr·∫≠n ' + id);
      return;
    }

    const msg = 'B·∫°n c√≥ ch·∫Øc mu·ªën thay ƒë·ªïi tr·∫≠n ' + id + '\n' +
                'ƒê·ªôi: ' + (m.teamA||'') + ' vs ' + (m.teamB||'') + '\n' +
                'T·ª´: ' + oldCourt + ' ' + oldTime + '\n' +
                '‚Üí Th√†nh: ' + (newCourt||oldCourt) + ' ' + (newTime||oldTime) + '\n\n' +
                'Nh·∫•n OK ƒë·ªÉ x√°c nh·∫≠n, Cancel ƒë·ªÉ h·ªßy.';
    if(!window.confirm(msg)){
      appendAutoSaveLog && appendAutoSaveLog('‚ùå Ng∆∞·ªùi d√πng hu·ª∑ thay ƒë·ªïi cho tr·∫≠n ' + id);
      if(select) select.value = oldCourt;
      if(timeInput) timeInput.value = oldTime;
      return;
    }

    if(newCourt) m.court = newCourt;
    if(newTime) m.time = newTime;
    appendAutoSaveLog && appendAutoSaveLog('üîÑ ƒê√£ c·∫≠p nh·∫≠t tr·∫≠n ' + id + ': ' + (m.teamA||'') + ' vs ' + (m.teamB||'') + ' ‚Üí ' + m.court + ', ' + m.time);
    window.stateChanged = true;
    safe(()=>{ if(typeof renderRoundsByCourt==='function') renderRoundsByCourt(); });
    setTimeout(()=>{ try{ saveToGitHub(); }catch(e){} }, 800);
  };

  // Detect conflicts and display warning
  function detectConflictsAndReport(){
    const map = {};
    (window.roundsSchedule||[]).forEach(m=>{
      if(!m.court || !m.time) return;
      const key = m.court.trim() + '|' + m.time.trim();
      if(!map[key]) map[key] = [];
      map[key].push(m.id);
    });
    document.querySelectorAll('.match-item').forEach(li=>li.classList.remove('conflict'));
    let conflictMatches = 0;
    let conflictCourts = 0;
    Object.keys(map).forEach(k=>{
      const ids = map[k];
      if(ids.length>1){
        conflictCourts += 1;
        conflictMatches += ids.length;
        ids.forEach(id=>{
          const li = document.querySelector('[data-match-id="'+id+'"]');
          if(li) li.classList.add('conflict');
        });
      }
    });
    const warningEl = document.getElementById('roundsWarning');
    if(warningEl){
      if(conflictCourts>0){
        warningEl.classList.remove('d-none');
        warningEl.innerText = '‚ö†Ô∏è C√≥ ' + conflictCourts + ' s√¢n b·ªã tr√πng gi·ªù thi ƒë·∫•u (' + conflictMatches + ' tr·∫≠n). Vui l√≤ng ki·ªÉm tra v√† ƒëi·ªÅu ch·ªânh.';
      } else {
        warningEl.classList.add('d-none');
        warningEl.innerText = '';
      }
    }
  }

  // Wrap renderRoundsByCourt to include conflict detection after render
  if(typeof renderRoundsByCourt === 'function'){
    const _old = renderRoundsByCourt;
    renderRoundsByCourt = function(){
      _old();
      setTimeout(detectConflictsAndReport, 120);
    };
  } else {
    window.renderRoundsByCourt = detectConflictsAndReport;
  }

  // Also run when syncing scores
  if(typeof syncScoresFromState === 'function'){
    const _oldSync = syncScoresFromState;
    syncScoresFromState = async function(){
      const res = await _oldSync();
      detectConflictsAndReport();
      return res;
    };
  }

  // initial run and periodic check
  setTimeout(detectConflictsAndReport, 500);
  setInterval(detectConflictsAndReport, 15000);

})(); // end IIFE
</script>

</body>
</html>
