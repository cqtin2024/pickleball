<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TKD Championship 2025 ‚Äî Qu·∫£n l√Ω gi·∫£i Pickleball V14 GitHub (Court Config)</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body { background:#f7f9fc; font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial; color:#222; padding:18px; }
    .tab-content { margin-top: 18px; }
    .logo { 
      width:64px; 
      height:64px; 
      object-fit:contain; 
      border-radius:8px; 
      border:1px solid #e6eefc; 
      padding:6px; 
      background:#fff; 
    }
    table th { background:#0d6efd; color:#fff; position:sticky; top:0; }
    .status { font-size:0.95rem; color:#555; }
    /* Responsive adjustment for match inputs */
    .match-score-cell input {
      width: 45px;
      text-align: center;
      padding: 0.1rem;
    }
    @media (max-width: 576px) {
      .match-score-cell input {
        width: 35px;
      }
    }
    .winner { font-weight: bold; color: green; }
    .loser { color: red; }
    .ranking-container { display: flex; flex-direction: column; gap: 20px; }
    @media (min-width: 768px) {
        .ranking-container { flex-direction: row; }
        .ranking-container > div { flex: 1; }
    }
  </style>
</head>
<body>
<div class="container">
  <div class="d-flex justify-content-between align-items-center mb-3">
    <div class="d-flex align-items-center gap-2">
      <img class="logo" src="data/logoTKD.png" alt="Logo TKD">
      <div>
        <h3 class="mb-0">TKD Championship 2025</h3>
        <div>Ng√†y thi ƒë·∫•u: 18/10/2025</div>
      </div>
    </div>
    <div>
      <div id="autoSaveStatus" class="text-end status">Auto-save: <span id="autoState" class="text-danger">T·∫Øt</span></div>
      <div id="lastSaved" class="text-end status">Ch∆∞a l∆∞u</div>
    </div>
  </div>

  <ul class="nav nav-tabs" id="mainTabs">
    <li class="nav-item"><button class="nav-link active" data-bs-toggle="tab" data-bs-target="#overview" onclick="renderOverview()">T·ªïng quan</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#matches" id="matchesTabButton" onclick="renderMatchesView()">V√≤ng B·∫£ng</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#finals">V√≤ng Chung K·∫øt</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#results">K·∫øt qu·∫£ Chung cu·ªôc</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#config" id="configTabButton" onclick="renderConfig()">C·∫•u h√¨nh</button></li>
  </ul>

  <div class="tab-content">
    <div class="tab-pane fade show active p-3" id="overview">
        <div id="overviewContent">ƒêang t·∫£i d·ªØ li·ªáu...</div>
    </div>
    
    <div class="tab-pane fade p-3" id="matches">
      <div class="d-flex gap-2 mb-3 flex-wrap">
        <label for="viewMode" class="form-label mb-0 align-self-center text-nowrap">Ch·∫ø ƒë·ªô xem:</label>
        <select id="viewMode" class="form-select form-select-sm w-auto" onchange="renderMatchesView()">
            <option value="table">Theo B·∫£ng ƒë·∫•u</option>
            <option value="court" selected>Theo S√¢n thi ƒë·∫•u</option>
        </select>
        
        <button class="btn btn-sm btn-info ms-auto" onclick="document.getElementById('fileInput').click()">Import L·ªãch (CSV)</button>
        <input type="file" id="fileInput" accept=".csv" style="display: none;" onchange="handleFileSelect(event)">
        
        <button class="btn btn-sm btn-warning" onclick="exportSchedule()">Export L·ªãch (CSV)</button>
      </div>
      
      <div id="matchesViewContent">
        <h6 id="scheduleAHeader" class="mt-4">B·∫£ng A (Nam - N·ªØ)</h6><div id="tableMatchesA">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u.</div>
        
        <h6 class="mt-4">B·∫£ng B (Nam)</h6><div id="tableMatchesB">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u.</div>
      </div>

      <button class="btn btn-warning mt-4" onclick="scheduleFinalsAuto()">L√™n l·ªãch V√≤ng Chung k·∫øt (T·ª± ƒë·ªông h√≥a)</button>
    </div>

    <div class="tab-pane fade p-3" id="finals">
        <div id="finalsContent">
            <h6 class="mt-4">V√≤ng B√°n k·∫øt (16:30, S√¢n 1-2)</h6>
            <div id="semifinalMatches">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u b√°n k·∫øt. K·∫øt qu·∫£ V√≤ng B·∫£ng s·∫Ω t·ª± ƒë·ªông c·∫≠p nh·∫≠t l·ªãch.</div>

            <h6 class="mt-4">Tr·∫≠n Chung k·∫øt (17:00, S√¢n 1)</h6>
            <div id="finalMatch">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u chung k·∫øt.</div>
        </div>
    </div>

    <div class="tab-pane fade p-3" id="results">
        <h5 class="mb-3">B·∫£ng x·∫øp h·∫°ng V√≤ng B·∫£ng (C·∫≠p nh·∫≠t li√™n t·ª•c)</h5>
        <div id="rankingTables" class="ranking-container">
            </div>

        <hr class="my-4">

        <h5 class="mb-3">Danh hi·ªáu Chung cu·ªôc</h5>
        <p id="champion">V√¥ ƒë·ªãch: ƒêang ch·ªù k·∫øt qu·∫£...</p>
        <p id="runnerUp">√Å qu√¢n: ƒêang ch·ªù k·∫øt qu·∫£...</p>
        <p id="thirdPlace">H·∫°ng Ba ƒê·ªìng H·∫°ng: ƒêang ch·ªù k·∫øt qu·∫£...</p>
    </div>

    <div class="tab-pane fade p-3" id="config">
      <h5 class="mb-3">C√¥ng c·ª• L·∫≠p & ƒêi·ªÅn L·ªãch Thi ƒë·∫•u</h5>
      <div class="d-flex gap-2 mb-4 flex-wrap">
        <button class="btn btn-sm btn-primary" onclick="taoLichThiDauCungGio()">T·∫°o l·ªãch thi ƒë·∫•u T·ªëi ∆∞u (T·ª± ƒë·ªông)</button>
        <button class="btn btn-sm btn-secondary" onclick="taoLichCoDinh()">T·∫°o l·ªãch C·ªë ƒë·ªãnh</button>
        <button class="btn btn-sm btn-success" onclick="autoFillScores()">ƒêi·ªÅn k·∫øt qu·∫£ T·ª± ƒë·ªông (11 - X)</button>
        <button class="btn btn-sm btn-danger" onclick="clearAllSchedules()">X√≥a To√†n b·ªô L·ªãch</button>
      </div>
      
      <hr>

      <h5 class="mt-4">‚öôÔ∏è C·∫•u h√¨nh S√¢n thi ƒë·∫•u & L·ªãch T·ªëi ∆∞u</h5>
      <p class="text-muted small">Qu·∫£n l√Ω danh s√°ch s√¢n thi ƒë·∫•u. S√¢n ƒë∆∞·ª£c g√°n lo·∫°i b·∫£ng ƒë·∫•u (A/B) ƒë·ªÉ ph·ª•c v·ª• ch·ª©c nƒÉng t·∫°o l·ªãch T·ªëi ∆∞u.</p>
      <div class="d-flex gap-2 mb-3 flex-wrap">
          <button class="btn btn-sm btn-primary" onclick="openCourtModal()">+ Th√™m S√¢n M·ªõi</button>
          <button class="btn btn-sm btn-outline-info" onclick="loadDefaultCourtConfig()">T·∫£i c·∫•u h√¨nh M·∫∑c ƒë·ªãnh</button>
      </div>
      <div id="courtListContainer">
          </div>
      <div id="courtConfigStatus"></div>
      <hr>

      <h5 class="mt-4">üíæ C·∫•u h√¨nh K·∫øt n·ªëi GitHub</h5>
      <p class="text-muted">Nh·∫≠p th√¥ng tin kho l∆∞u tr·ªØ GitHub ƒë·ªÉ t·ª± ƒë·ªông l∆∞u tr·ªØ d·ªØ li·ªáu gi·∫£i ƒë·∫•u.</p>
      <div class="row g-2 mb-2">
        <div class="col-md-3"><input id="cfgOwner" class="form-control" placeholder="Owner (V√≠ d·ª•: user_name)"></div>
        <div class="col-md-3"><input id="cfgRepo" class="form-control" placeholder="Repo (V√≠ d·ª•: my-data-repo)"></div>
        <div class="col-md-3"><input id="cfgFolder" class="form-control" value="data"></div>
        <div class="col-md-3"><input id="cfgFile" class="form-control" value="state.json"></div>
      </div>
      <input id="cfgToken" type="password" class="form-control mb-2" placeholder="D√°n GitHub Personal Access Token (PAT) t·∫°i ƒë√¢y">
      <div class="d-flex gap-2">
        <button class="btn btn-primary" onclick="saveConfig()">L∆∞u c·∫•u h√¨nh Local</button>
        <button class="btn btn-success" onclick="checkConnection()">Ki·ªÉm tra & T·∫£i D·ªØ li·ªáu</button>
      </div>
      <div class="mt-2" id="configStatus"></div>
      
      <div class="card bg-light mt-4 shadow-sm">
        <div class="card-body">
            <h5 class="card-title text-info">üîë H∆∞·ªõng d·∫´n l·∫•y GitHub Token (PAT)</h5>
            <ol class="small mb-0">
                <li>Truy c·∫≠p <a href="https://github.com/settings/tokens" target="_blank" class="text-info">GitHub Tokens Settings</a> (B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p).</li>
                <li>Ch·ªçn **Generate new token** (ho·∫∑c **Generate new token (classic)** n·∫øu b·∫°n d√πng t√†i kho·∫£n c≈©).</li>
                <li>**T√™n Token:** ƒê·∫∑t t√™n d·ªÖ nh·ªõ (v√≠ d·ª•: `TKDManager_AutoSave`).</li>
                <li>**Th·ªùi h·∫°n:** Ch·ªçn t√πy √Ω (n√™n ch·ªçn 90 ng√†y ho·∫∑c T√πy ch·ªânh).</li>
                <li>**Ph·∫°m vi (Scopes):** **B·∫ÆT BU·ªòC** t√≠ch ch·ªçn √¥ **`repo`** (cho ph√©p truy c·∫≠p v√†o kho l∆∞u tr·ªØ).</li>
                <li>Nh·∫•n **Generate token** v√† **SAO CH√âP** chu·ªói Token v·ª´a ƒë∆∞·ª£c t·∫°o.</li>
                <li>D√°n chu·ªói Token ƒë√≥ v√†o √¥ "D√°n GitHub Personal Access Token (PAT) t·∫°i ƒë√¢y" b√™n tr√™n.</li>
            </ol>
            <p class="mt-2 mb-0 text-danger small">‚ö†Ô∏è **L∆∞u √Ω:** Token ch·ªâ hi·ªÉn th·ªã **M·ªòT L·∫¶N**. H√£y sao ch√©p ngay l·∫≠p t·ª©c v√† gi·ªØ b√≠ m·∫≠t. N·∫øu m·∫•t, b·∫°n ph·∫£i t·∫°o l·∫°i Token m·ªõi.</p>
        </div>
      </div>
      </div>
  </div>
</div>

<div class="modal fade" id="courtModal" tabindex="-1" aria-labelledby="courtModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="courtModalLabel">Th√™m/S·ª≠a C·∫•u h√¨nh S√¢n</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="courtForm">
          <input type="hidden" id="courtIndex" value="">
          <div class="mb-3">
            <label for="courtName" class="form-label">T√™n S√¢n</label>
            <input type="text" class="form-control" id="courtName" required>
          </div>
          <div class="mb-3">
            <label for="courtStartTime" class="form-label">Gi·ªù B·∫Øt ƒê·∫ßu (HH:mm)</label>
            <input type="time" class="form-control" id="courtStartTime" required>
          </div>
          <div class="mb-3">
            <label for="courtMaxDuration" class="form-label">Th·ªùi L∆∞·ª£ng T·ªëi ƒêa (Ph√∫t)</label>
            <input type="number" class="form-control" id="courtMaxDuration" min="1" required>
          </div>
          <div class="form-check mb-3">
            <input class="form-check-input" type="checkbox" id="courtIsMixed">
            <label class="form-check-label" for="courtIsMixed">
              D√†nh cho B·∫£ng A (Nam - N·ªØ)
            </label>
            <div class="form-text">N·∫øu kh√¥ng ch·ªçn, s√¢n s·∫Ω d√†nh cho B·∫£ng B (Nam).</div>
          </div>
          <div id="courtFormStatus" class="mt-2"></div>
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">H·ªßy</button>
        <button type="button" class="btn btn-primary" onclick="saveCourtChanges()">L∆∞u Thay ƒê·ªïi</button>
      </div>
    </div>
  </div>
</div>
<div class="modal fade" id="customAlertModal" tabindex="-1" aria-labelledby="customAlertModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="customAlertModalLabel">Th√¥ng b√°o</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="customAlertModalBody">
        N·ªôi dung th√¥ng b√°o
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-primary" data-bs-dismiss="modal">ƒê√≥ng</button>
      </div>
    </div>
  </div>
</div>

<script>
// D·ªØ li·ªáu l·ªãch c·ªë ƒë·ªãnh t·ª´ file TKDPlayers - Sheet2 (1).csv (ƒê√É C·∫¨P NH·∫¨T)
const FIXED_SCHEDULE_CSV = `Gi·ªù b·∫Øt ƒë·∫ßu,Gi·ªù k·∫øt th√∫c,L∆∞·ª£t tr·∫≠n,S√¢n 1,S√¢n 2,S√¢n 3,S√¢n 7,Th·ªùi l∆∞·ª£ng d·ª± ki·∫øn
2:00,2:15,1,Ti·ªáp/Th·ªßy - Ph∆∞∆°ng/Thanh,Giang/Long - H∆∞·ªùng/ƒê·∫°t,H·∫≠u/D≈©ng - H·∫°nh/Ti·∫øn,Huy·ªÅn/Lu√¢n - Linh/M.H√πng,0:15
2:15,2:30,2,Tri·ªÅu/Minh - Hi·ªÉn/P.H√πng,T√≠n/Khi√™m - √Ånh/To√†n,H·∫≠u/D≈©ng - H∆∞·ªùng/ƒê·∫°t,Giang/Long - Huy·ªÅn/Lu√¢n,0:15
2:30,2:45,3,Ph∆∞∆°ng/Thanh - √Ånh/To√†n,Tri·ªÅu/Minh - T√≠n/Khi√™m,H·∫°nh/Ti·∫øn - Linh/M.H√πng,Tri·ªÅu/Minh - Hi·ªÉn/P.H√πng,0:15
2:45,3:00,4,,H·∫°nh/Ti·∫øn - Giang/Long,Huy·ªÅn/Lu√¢n - H∆∞·ªùng/ƒê·∫°t,H·∫≠u/D≈©ng - Linh/M.H√πng,0:15
3:00,3:15,5,,Ti·ªáp/Th·ªßy - √Ånh/To√†n,T√≠n/Khi√™m - Hi·ªÉn/M.H√πng,,0:15
3:15,3:30,6,,Ph∆∞∆°ng/Thanh - Tri·ªÅu/Minh,Giang/Long - Linh/M.H√πng,,0:15
3:30,3:45,7,,H·∫°nh/Ti·∫øn - H∆∞·ªùng/ƒê·∫°t,H·∫≠u/D≈©ng - Huy·ªÅn/Lu√¢n,,0:15
3:45,4:00,8,,Ti·ªáp/Th·ªßy - T√≠n/Khi√™m,Ph∆∞∆°ng/Thanh - Hi·ªÉn/P.H√πng,,0:15
4:00,4:15,9,,Tri·ªÅu/Minh - √Ånh/To√†n,Ti·ªáp/Th·ªßy - Ph∆∞∆°ng/Thanh,H·∫°nh/Ti·∫øn - Huy·ªÅn/Lu√¢n,0:15
4:15,4:30,10,,T√≠n/Khi√™m - Ph∆∞∆°ng/Thanh,Giang/Long - H·∫≠u/D≈©ng,,0:15
4:30,4:45,11,H·∫≠u/D≈©ng - H·∫°nh/Ti·∫øn,Giang/Long - H∆∞·ªùng/ƒê·∫°t,Huy·ªÅn/Lu√¢n - Linh/M.H√πng,H·∫≠u/D≈©ng - Linh/M.H√πng,0:15
4:45,5:00,12,,,,0:15
5:00,5:15,13,H·∫≠u/D≈©ng - Giang/Long,Huy·ªÅn/Lu√¢n - H·∫°nh/Ti·∫øn,Linh/M.H√πng - H∆∞·ªùng/ƒê·∫°t,,0:15
5:15,5:30,14,Tri·ªÅu/Minh - Ti·ªáp/Th·ªßy,√Ånh/To√†n - Hi·ªÉn/P.H√πng,Ph∆∞∆°ng/Thanh - T√≠n/Khi√™m,,0:15
5:30,5:45,15,H·∫≠u/D≈©ng - Huy·ªÅn/Lu√¢n,Giang/Long - Linh/M.H√πng,H·∫°nh/Ti·∫øn - H∆∞·ªùng/ƒê·∫°t,,0:15
5:45,6:00,16,,,,0:15
6:00,6:15,17,Huy·ªÅn/Lu√¢n - Giang/Long,H·∫≠u/D≈©ng - H∆∞·ªùng/ƒê·∫°t,H·∫°nh/Ti·∫øn - Linh/M.H√πng,,0:15
6:15,6:30,18,Ti·ªáp/Th·ªßy - Hi·ªÉn/P.H√πng,Ph∆∞∆°ng/Thanh - √Ånh/To√†n,Tri·ªÅu/Minh - T√≠n/Khi√™m,,0:15
6:30,6:45,19,H·∫≠u/D≈©ng - H·∫°nh/Ti·∫øn,Giang/Long - H∆∞·ªùng/ƒê·∫°t,Huy·ªÅn/Lu√¢n - Linh/M.H√πng,Ti·ªáp/Th·ªßy - Ph∆∞∆°ng/Thanh,0:15
6:45,7:00,20,Tri·ªÅu/Minh - Hi·ªÉn/P.H√πng,T√≠n/Khi√™m - √Ånh/To√†n,H·∫≠u/D≈©ng - H∆∞·ªùng/ƒê·∫°t,Giang/Long - Huy·ªÅn/Lu√¢n,0:15
7:00,7:15,21,Ph∆∞∆°ng/Thanh - √Ånh/To√†n,Tri·ªÅu/Minh - T√≠n/Khi√™m,H·∫°nh/Ti·∫øn - Linh/M.H√πng,Ti·ªáp/Th·ªßy - Hi·ªÉn/P.H√πng,0:15
7:15,7:30,22,,H·∫°nh/Ti·∫øn - Giang/Long,Huy·ªÅn/Lu√¢n - H∆∞·ªùng/ƒê·∫°t,H·∫≠u/D≈©ng - Linh/M.H√πng,0:15
7:30,7:45,23,,Ti·ªáp/Th·ªßy - √Ånh/To√†n,T√≠n/Khi√™m - Hi·ªÉn/P.H√πng,,0:15
7:45,8:00,24,,Ph∆∞∆°ng/Thanh - Tri·ªÅu/Minh,Giang/Long - Linh/M.H√πng,,0:15
8:00,8:15,25,,H·∫°nh/Ti·∫øn - H∆∞·ªùng/ƒê·∫°t,H·∫≠u/D≈©ng - Huy·ªÅn/Lu√¢n,,0:15
8:15,8:30,26,,Ti·ªáp/Th·ªßy - T√≠n/Khi√™m,Ph∆∞∆°ng/Thanh - Hi·ªÉn/P.P√πng,,0:15
8:30,8:45,27,,Tri·ªÅu/Minh - √Ånh/To√†n,Ti·ªáp/Th·ªßy - Ph∆∞∆°ng/Thanh,H·∫°nh/Ti·∫øn - Huy·ªÅn/Lu√¢n,0:15
8:45,9:00,28,,T√≠n/Khi√™m - Ph∆∞∆°ng/Thanh,Giang/Long - H·∫≠u/D≈©ng,,0:15
9:00,9:15,29,H·∫≠u/D≈©ng - H·∫°nh/Ti·∫øn,Giang/Long - H∆∞·ªùng/ƒê·∫°t,Huy·ªÅn/Lu√¢n - Linh/M.H√πng,H·∫≠u/D≈©ng - Linh/M.H√πng,0:15
9:15,9:30,30,,,,0:15
9:30,9:45,31,H·∫≠u/D≈©ng - Giang/Long,Huy·ªÅn/Lu√¢n - H·∫°nh/Ti·∫øn,Linh/M.H√πng - H∆∞·ªùng/ƒê·∫°t,,0:15
9:45,10:00,32,Tri·ªÅu/Minh - Ti·ªáp/Th·ªßy,√Ånh/To√†n - Hi·ªÉn/P.H√πng,Ph∆∞∆°ng/Thanh - T√≠n/Khi√™m,,0:15
10:00,10:15,33,H·∫≠u/D≈©ng - Huy·ªÅn/Lu√¢n,Giang/Long - Linh/M.H√πng,H·∫°nh/Ti·∫øn - H∆∞·ªùng/ƒê·∫°t,,0:15
10:15,10:30,34,,,,0:15
10:30,10:45,35,Huy·ªÅn/Lu√¢n - Giang/Long,H·∫≠u/D≈©ng - H∆∞·ªùng/ƒê·∫°t,H·∫°nh/Ti·∫øn - Linh/M.H√πng,,0:15
10:45,11:00,36,Ti·ªáp/Th·ªßy - Hi·ªÉn/P.H√πng,Ph∆∞∆°ng/Thanh - √Ånh/To√†n,Tri·ªÅu/Minh - T√≠n/Khi√™m,,0:15`;

// Bi·∫øn state l∆∞u tr·ªØ d·ªØ li·ªáu ch√≠nh c·ªßa ·ª©ng d·ª•ng.
let state = { 
  mixedTeams: [], // S·∫Ω ƒë∆∞·ª£c t·∫£i t·ª´ players.json
  maleTeams: [],  // S·∫Ω ƒë∆∞·ª£c t·∫£i t·ª´ players.json
  matchesA: [], 
  matchesB: [],
  tableA: [], // B·∫£ng x·∫øp h·∫°ng A
  tableB: [], // B·∫£ng x·∫øp h·∫°ng B
  
  // NEW: Court Configuration
  courts: [
    { name: 'S√¢n 1', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, // B·∫£ng A (Mixed)
    { name: 'S√¢n 2', startTime: '14:00', maxDurationMinutes: 180, isMixed: true }, // B·∫£ng A (Mixed)
    { name: 'S√¢n 3', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }, // B·∫£ng B (Male)
    { name: 'S√¢n 4', startTime: '14:00', maxDurationMinutes: 180, isMixed: false } // B·∫£ng B (Male)
  ],
  
  // LOGIC B√ÅN K·∫æT: SF1: Nh·∫•t A vs Nh·∫•t B, SF2: Nh√¨ B vs Nh√¨ A
  semifinals: [
    { id: 'SF1', teamA: 'Nh·∫•t A', teamB: 'Nh·∫•t B', scoreA: null, scoreB: null, time: '16:30', court: 'S√¢n 1', winner: null, loser: null },
    { id: 'SF2', teamA: 'Nh√¨ B', teamB: 'Nh√¨ A', scoreA: null, scoreB: null, time: '16:30', court: 'S√¢n 2', winner: null, loser: null }
  ],
  final: { id: 'F', teamA: 'Th·∫Øng SF1', teamB: 'Th·∫Øng SF2', scoreA: null, scoreB: null, time: '17:00', court: 'S√¢n 1', winner: null, runnerUp: null },
  config: {}
};

let stateChanged = false; // Bi·∫øn c·ªù theo d√µi thay ƒë·ªïi d·ªØ li·ªáu
let currentSha = null; // Bi·∫øn l∆∞u tr·ªØ SHA c·ªßa file tr√™n GitHub
let autoSaveInterval = null; // Bi·∫øn l∆∞u tr·ªØ ID c·ªßa interval

// --- Custom Modal Function ---
function showModal(title, body) {
    document.getElementById('customAlertModalLabel').textContent = title;
    document.getElementById('customAlertModalBody').innerHTML = body;
    const modal = new bootstrap.Modal(document.getElementById('customAlertModal'));
    modal.show();
}

/**
 * H√†m chuy·ªÉn ƒë·ªïi tab
 * @param {string} tabId - ID c·ªßa tab c·∫ßn chuy·ªÉn (v√≠ d·ª•: 'matches', 'overview')
 */
function switchTab(tabId) {
    const tabElement = document.querySelector(`#mainTabs button[data-bs-target="#${tabId}"]`);
    if (tabElement) {
        // T·∫Øt tab ƒëang active
        document.querySelectorAll('#mainTabs .nav-link').forEach(btn => btn.classList.remove('active'));
        document.querySelectorAll('.tab-content .tab-pane').forEach(pane => pane.classList.remove('show', 'active'));

        // B·∫≠t tab m·ªõi
        tabElement.classList.add('active');
        document.getElementById(tabId).classList.add('show', 'active');
        
        // C·∫≠p nh·∫≠t view cho tab matches n·∫øu chuy·ªÉn ƒë·∫øn
        if (tabId === 'matches') {
            renderMatchesView();
        }
    }
}

// --- Helper Functions cho Base64 ---
function b64EncodeUnicode(str) {
  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g,
    function(match, p1) {
      return String.fromCharCode('0x' + p1);
    }));
}

function b64DecodeUnicode(str) {
  return decodeURIComponent(atob(str).split('').map(function(c) {
    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
  }).join(''));
}

// --- GitHub API Functions ---

/**
 * L·∫•y SHA m·ªõi nh·∫•t c·ªßa file state.json tr√™n GitHub.
 * @param {object} cfg - C·∫•u h√¨nh GitHub (owner, repo, folder, file, token)
 * @returns {Promise<{sha: string|null, content: string|null}>}
 */
async function fetchFileSha(cfg, fileName = cfg.file) {
    const filePath = `${cfg.folder}/${fileName}`;
    const apiUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}/contents/${filePath}`;
    
    try {
        const response = await fetch(apiUrl, {
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });
        
        if (response.ok) {
            const data = await response.json();
            if (fileName === cfg.file) {
                 currentSha = data.sha; // Ch·ªâ l∆∞u SHA c·ªßa state.json
            }
            return { sha: data.sha, content: data.content };
        } else if (response.status === 404) {
            if (fileName === cfg.file) {
                 currentSha = null; 
            }
            return { sha: null, content: null };
        } else {
            throw new Error(`L·ªói khi l·∫•y SHA: ${response.statusText}`);
        }
    } catch (error) {
        console.error(`L·ªói Fetch SHA (${fileName}):`, error);
        throw new Error(`L·ªói k·∫øt n·ªëi ho·∫∑c API: ${error.message}`);
    }
}

/**
 * NEW: T·∫£i danh s√°ch ƒë·ªôi t·ª´ players.json
 */
async function loadPlayersFromGitHub(cfg) {
    // players.json ph·∫£i n·∫±m c√πng th∆∞ m·ª•c v·ªõi state.json
    const fileName = 'players.json';
    
    try {
        updateStatus('configStatus', 'info', 'ƒêang t·∫£i danh s√°ch ƒë·ªôi t·ª´ GitHub (players.json)...');
        const result = await fetchFileSha(cfg, fileName); 
        
        if (result.content) {
            const jsonString = b64DecodeUnicode(result.content);
            const loadedTeams = JSON.parse(jsonString);

            if (Array.isArray(loadedTeams.mixedTeams) && Array.isArray(loadedTeams.maleTeams)) {
                state.mixedTeams = loadedTeams.mixedTeams;
                state.maleTeams = loadedTeams.maleTeams;
                updateStatus('configStatus', 'success', `T·∫£i danh s√°ch ƒë·ªôi th√†nh c√¥ng (${state.mixedTeams.length + state.maleTeams.length} ƒë·ªôi).`);
                return true;
            } else {
                throw new Error("File players.json kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng (thi·∫øu mixedTeams/maleTeams).");
            }
        } else {
             // 404 ho·∫∑c kh√¥ng c√≥ content
            updateStatus('configStatus', 'warning', 'Kh√¥ng t√¨m th·∫•y file players.json. D√πng danh s√°ch ƒë·ªôi kh·ªüi t·∫°o (tr·ªëng).');
            return false;
        }
    } catch (error) {
        console.error("L·ªói khi t·∫£i players.json:", error);
        updateStatus('configStatus', 'danger', `L·ªói t·∫£i danh s√°ch ƒë·ªôi: ${error.message}`);
        return false;
    }
}

/**
 * T·∫£i tr·∫°ng th√°i gi·∫£i ƒë·∫•u (state.json) t·ª´ GitHub.
 */
async function loadFromGitHub() {
    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) return;

    // 1. Load Teams (danh s√°ch ƒë·ªôi)
    await loadPlayersFromGitHub(cfg); 

    // 2. Load App State (state.json)
    try {
        updateStatus('configStatus', 'info', 'ƒêang t·∫£i tr·∫°ng th√°i gi·∫£i ƒë·∫•u t·ª´ GitHub (state.json)...');
        // fetchFileSha s·∫Ω t·ª± ƒë·ªông c·∫≠p nh·∫≠t currentSha
        const result = await fetchFileSha(cfg, cfg.file); 
        
        if (result.content) {
            const jsonString = b64DecodeUnicode(result.content);
            const loadedState = JSON.parse(jsonString);

            // Ghi ƒë√® c√°c gi√° tr·ªã kh√°c ngo√†i teams (teams ƒë√£ ƒë∆∞·ª£c load t·ª´ players.json)
            state.matchesA = loadedState.matchesA || [];
            state.matchesB = loadedState.matchesB || [];
            
            // T·∫£i c·∫•u h√¨nh s√¢n (NEW) - n·∫øu kh√¥ng c√≥, gi·ªØ nguy√™n m·∫∑c ƒë·ªãnh
            if (loadedState.courts) {
                state.courts = loadedState.courts;
            }
            
            // X·ª≠ l√Ω logic t·∫£i cho semifinals v√† final (ƒë·∫£m b·∫£o kh√¥ng ghi ƒë√® l·ªãch t·ª± ƒë·ªông)
            const loadedSemifinals = loadedState.semifinals;
            if (loadedSemifinals && loadedSemifinals.length === 2 && 
                (loadedSemifinals[0].teamA !== 'Nh·∫•t A' || loadedSemifinals[0].teamB !== 'Nh·∫•t B' ||
                 loadedSemifinals[1].teamA !== 'Nh√¨ B' || loadedSemifinals[1].teamB !== 'Nh√¨ A')
            ) {
                // N·∫øu ƒë√£ c√≥ ƒë·ªôi th·ª±c t·∫ø ƒë∆∞·ª£c g√°n, gi·ªØ nguy√™n (ƒë√£ t√≠nh t·ª´ data v√≤ng b·∫£ng)
                state.semifinals = loadedSemifinals;
            } else if (loadedSemifinals && loadedSemifinals.length === 2) {
                // N·∫øu l√† tr·∫°ng th√°i r·ªóng, v·∫´n load
                state.semifinals = loadedSemifinals;
            }

            state.final = loadedState.final || state.final;
            
            // C·∫≠p nh·∫≠t giao di·ªán
            renderMatches(); 
            tinhVaCapNhatXepHang();
            renderFinals();
            renderFinalResults();
            renderOverview();
            
            updateStatus('configStatus', 'success', `T·∫£i tr·∫°ng th√°i gi·∫£i ƒë·∫•u th√†nh c√¥ng t·ª´: ${cfg.owner}/${cfg.repo}/${cfg.folder}/${cfg.file}`);
            document.getElementById('lastSaved').textContent = `L·∫ßn t·∫£i: ${new Date().toLocaleTimeString('vi-VN')}`;
        } else {
            updateStatus('configStatus', 'warning', 'File tr·∫°ng th√°i (state.json) ch∆∞a t·ªìn t·∫°i. Vui l√≤ng nh·∫•n L∆∞u ho·∫∑c T·ª± ƒë·ªông l∆∞u ƒë·ªÉ t·∫°o file.');
        }

        startAutoSave();

    } catch (error) {
        updateStatus('configStatus', 'danger', `L·ªói t·∫£i tr·∫°ng th√°i gi·∫£i ƒë·∫•u: ${error.message}. Vui l√≤ng ki·ªÉm tra l·∫°i Token/Repo.`);
        console.error("L·ªói khi t·∫£i tr·∫°ng th√°i gi·∫£i ƒë·∫•u t·ª´ GitHub:", error);
    }
}

async function saveToGitHub() {
    // B·ªè qua n·∫øu kh√¥ng c√≥ thay ƒë·ªïi
    if (!stateChanged) return;

    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) {
        console.warn("Kh√¥ng th·ªÉ t·ª± ƒë·ªông l∆∞u: Thi·∫øu c·∫•u h√¨nh GitHub.");
        document.getElementById('autoState').className = 'text-warning';
        document.getElementById('autoState').textContent = 'T·∫°m d·ª´ng (Thi·∫øu Config)';
        return;
    }

    document.getElementById('autoState').className = 'text-info';
    document.getElementById('autoState').textContent = 'ƒêang l∆∞u...';

    const apiUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}/contents/${cfg.folder}/${cfg.file}`;
    
    // Ch·ªâ l∆∞u c√°c tr∆∞·ªùng c·∫ßn thi·∫øt, lo·∫°i b·ªè config v√† table (v√¨ ch√∫ng ƒë∆∞·ª£c t√≠nh l·∫°i)
    const stateToSave = {
        mixedTeams: state.mixedTeams,
        maleTeams: state.maleTeams,
        matchesA: state.matchesA,
        matchesB: state.matchesB,
        courts: state.courts,
        semifinals: state.semifinals,
        final: state.final
    };
    const content = b64EncodeUnicode(JSON.stringify(stateToSave));
    
    try {
        // Lu√¥n fetch SHA m·ªõi nh·∫•t tr∆∞·ªõc khi c·ªë g·∫Øng l∆∞u
        const result = await fetchFileSha(cfg, cfg.file); // L·∫•y SHA c·ªßa state.json
        const sha = result.sha; 
        
        const payload = {
            message: `[Auto-save] C·∫≠p nh·∫≠t tr·∫°ng th√°i gi·∫£i ƒë·∫•u TKD l√∫c ${new Date().toLocaleString('vi-VN')}`,
            content: content
        };
        
        // Ch·ªâ th√™m SHA v√†o payload n·∫øu n√≥ ƒë√£ t·ªìn t·∫°i (ƒë·ªÉ c·∫≠p nh·∫≠t), 
        if (sha) {
             payload.sha = sha;
        }

        const response = await fetch(apiUrl, {
            method: 'PUT',
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Content-Type': 'application/json',
                'Accept': 'application/vnd.github.v3+json'
            },
            body: JSON.stringify(payload)
        });

        if (response.ok) {
            const data = await response.json();
            currentSha = data.content.sha;
            stateChanged = false;
            document.getElementById('lastSaved').textContent = `L·∫ßn l∆∞u: ${new Date().toLocaleTimeString('vi-VN')}`;
            document.getElementById('autoState').className = 'text-success';
            document.getElementById('autoState').textContent = 'ƒê√£ L∆∞u';
        } else {
            // Tr∆∞·ªùng h·ª£p l·ªói 409 Conflict (SHA c≈©)
            if (response.status === 409) {
                console.warn("L·ªói 409 Conflict: D·ªØ li·ªáu ƒë√£ thay ƒë·ªïi tr√™n GitHub. ƒêang c·ªë g·∫Øng l·∫•y SHA m·ªõi.");
                
                // L·∫•y l·∫°i SHA m·ªõi nh·∫•t. stateChanged v·∫´n l√† true, 
                // ƒë·ªÉ AutoSave interval s·∫Ω th·ª≠ l·∫°i v·ªõi SHA m·ªõi trong l·∫ßn ti·∫øp theo.
                await fetchFileSha(cfg, cfg.file); 
                
                document.getElementById('autoState').className = 'text-warning';
                document.getElementById('autoState').textContent = 'Conflict. S·∫Ω th·ª≠ l∆∞u l·∫°i sau 1 ph√∫t.';
            } else {
                throw new Error(`L·ªói HTTP: ${response.status} - ${response.statusText}`);
            }
        }
    } catch (error) {
        console.error("L·ªói khi l∆∞u l√™n GitHub:", error);
        document.getElementById('autoState').className = 'text-danger';
        document.getElementById('autoState').textContent = 'L·ªói L∆∞u';
    }
}

async function checkConnection() {
    const cfg = state.config;
    if (!cfg.owner || !cfg.repo || !cfg.token) {
        updateStatus('configStatus', 'warning', 'Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß Owner, Repo v√† Token.');
        return;
    }

    try {
        updateStatus('configStatus', 'info', 'ƒêang ki·ªÉm tra k·∫øt n·ªëi...');
        
        const repoCheckUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}`;
        const repoResponse = await fetch(repoCheckUrl, {
            headers: {
                'Authorization': `token ${cfg.token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });

        if (!repoResponse.ok) {
            throw new Error(`L·ªói truy c·∫≠p kho l∆∞u tr·ªØ. M√£: ${repoResponse.status}. (Ki·ªÉm tra Token/Repo/Owner)`);
        }
        
        updateStatus('configStatus', 'success', 'K·∫øt n·ªëi GitHub th√†nh c√¥ng! ƒêang t·∫£i d·ªØ li·ªáu...');
        await loadFromGitHub();

    } catch (error) {
        updateStatus('configStatus', 'danger', `Ki·ªÉm tra k·∫øt n·ªëi th·∫•t b·∫°i: ${error.message}.`);
        console.error("L·ªói ki·ªÉm tra k·∫øt n·ªëi:", error);
    }
}

// --- C·∫•u h√¨nh & Kh·ªüi t·∫°o ---

function renderConfig() {
    // Ch·ªâ c·∫ßn hi·ªÉn th·ªã c·∫•u h√¨nh s√¢n hi·ªán t·∫°i
    renderCourtList();
    document.getElementById('courtConfigStatus').innerHTML = '';
}

/**
 * Hi·ªÉn th·ªã danh s√°ch s√¢n d∆∞·ªõi d·∫°ng b·∫£ng v·ªõi n√∫t S·ª≠a/X√≥a.
 */
function renderCourtList() {
    const container = document.getElementById('courtListContainer');
    if (!container) return;
    
    if (state.courts.length === 0) {
        container.innerHTML = `<div class="alert alert-warning">Ch∆∞a c√≥ s√¢n n√†o ƒë∆∞·ª£c c·∫•u h√¨nh.</div>`;
        return;
    }
    
    let html = `<div class='table-responsive'><table class='table table-striped table-sm'>
        <thead>
            <tr>
                <th>T√™n S√¢n</th>
                <th>Gi·ªù B·∫Øt ƒê·∫ßu</th>
                <th>Th·ªùi L∆∞·ª£ng Max (Ph√∫t)</th>
                <th>Ph√¢n Lo·∫°i</th>
                <th class="text-center">H√†nh ƒë·ªông</th>
            </tr>
        </thead>
        <tbody>`;
        
    state.courts.forEach((court, index) => {
        const type = court.isMixed ? 'B·∫£ng A (Nam-N·ªØ)' : 'B·∫£ng B (Nam)';
        const typeClass = court.isMixed ? 'badge bg-primary' : 'badge bg-info';
        
        html += `<tr>
            <td>${court.name}</td>
            <td>${court.startTime}</td>
            <td>${court.maxDurationMinutes}</td>
            <td><span class="${typeClass}">${type}</span></td>
            <td class="text-center">
                <button class="btn btn-sm btn-outline-secondary me-1" onclick="openCourtModal(${index})">S·ª≠a</button>
                <button class="btn btn-sm btn-outline-danger" onclick="deleteCourt(${index})">X√≥a</button>
            </td>
        </tr>`;
    });
    
    html += `</tbody></table></div>`;
    container.innerHTML = html;
}

/**
 * M·ªü modal th√™m/s·ª≠a s√¢n v√† ƒëi·ªÅn d·ªØ li·ªáu n·∫øu l√† ch·∫ø ƒë·ªô s·ª≠a.
 * @param {number | null} index - Ch·ªâ s·ªë c·ªßa s√¢n c·∫ßn s·ª≠a, ho·∫∑c null n·∫øu th√™m m·ªõi.
 */
function openCourtModal(index = null) {
    const modal = new bootstrap.Modal(document.getElementById('courtModal'));
    document.getElementById('courtFormStatus').innerHTML = '';

    document.getElementById('courtIndex').value = index !== null ? index : '';
    document.getElementById('courtModalLabel').textContent = index !== null ? 'S·ª≠a C·∫•u h√¨nh S√¢n' : 'Th√™m S√¢n M·ªõi';

    if (index !== null) {
        const court = state.courts[index];
        document.getElementById('courtName').value = court.name || '';
        document.getElementById('courtStartTime').value = court.startTime || '14:00';
        document.getElementById('courtMaxDuration').value = court.maxDurationMinutes || 180;
        document.getElementById('courtIsMixed').checked = court.isMixed || false;
    } else {
        // Ch·∫ø ƒë·ªô th√™m m·ªõi: Reset form
        document.getElementById('courtName').value = '';
        document.getElementById('courtStartTime').value = '14:00';
        document.getElementById('courtMaxDuration').value = '180';
        document.getElementById('courtIsMixed').checked = true; // Default to Mixed (B·∫£ng A)
    }

    modal.show();
}

/**
 * L∆∞u thay ƒë·ªïi t·ª´ modal v√†o state.courts
 */
function saveCourtChanges() {
    const indexStr = document.getElementById('courtIndex').value;
    const index = indexStr === '' ? null : parseInt(indexStr);
    
    const name = document.getElementById('courtName').value.trim();
    const startTime = document.getElementById('courtStartTime').value;
    const maxDurationMinutes = parseInt(document.getElementById('courtMaxDuration').value);
    const isMixed = document.getElementById('courtIsMixed').checked;

    const statusDiv = document.getElementById('courtFormStatus');

    // Validation
    if (!name || !startTime || isNaN(maxDurationMinutes) || maxDurationMinutes <= 0) {
        statusDiv.innerHTML = `<div class="alert alert-danger p-2">Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß v√† h·ª£p l·ªá c√°c tr∆∞·ªùng (T√™n, Gi·ªù, Th·ªùi l∆∞·ª£ng > 0).</div>`;
        return;
    }
    
    // Check for duplicate name (excluding the current edited court)
    const isDuplicate = state.courts.some((c, i) => 
        i !== index && c.name.toLowerCase() === name.toLowerCase()
    );

    if (isDuplicate) {
         statusDiv.innerHTML = `<div class="alert alert-danger p-2">T√™n s√¢n "${name}" ƒë√£ t·ªìn t·∫°i.</div>`;
        return;
    }

    const newCourt = { 
        name, 
        startTime, 
        maxDurationMinutes, 
        isMixed 
    };

    if (index !== null) {
        // Edit mode
        state.courts[index] = newCourt;
    } else {
        // Add mode
        state.courts.push(newCourt);
    }
    
    // Close modal
    bootstrap.Modal.getInstance(document.getElementById('courtModal')).hide();

    // Update UI and save
    renderCourtList();
    stateChanged = true;
    updateStatus('courtConfigStatus', 'success', `ƒê√£ ${index !== null ? 'c·∫≠p nh·∫≠t' : 'th√™m'} s√¢n "${name}". D·ªØ li·ªáu s·∫Ω ƒë∆∞·ª£c t·ª± ƒë·ªông l∆∞u l√™n GitHub.`);
    saveToGitHub();
}

/**
 * X√≥a s√¢n kh·ªèi danh s√°ch.
 * @param {number} index - Ch·ªâ s·ªë c·ªßa s√¢n c·∫ßn x√≥a.
 */
function deleteCourt(index) {
    if (confirm(`B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a s√¢n "${state.courts[index].name}"?`)) {
        const deletedCourtName = state.courts[index].name;
        state.courts.splice(index, 1);
        
        renderCourtList();
        stateChanged = true;
        updateStatus('courtConfigStatus', 'success', `ƒê√£ x√≥a s√¢n "${deletedCourtName}". D·ªØ li·ªáu s·∫Ω ƒë∆∞·ª£c t·ª± ƒë·ªông l∆∞u l√™n GitHub.`);
        saveToGitHub();
    }
}

/**
 * T·∫£i c·∫•u h√¨nh m·∫∑c ƒë·ªãnh (ph·∫£i ƒë∆∞·ª£c c·∫≠p nh·∫≠t ƒë·ªÉ d√πng logic m·ªõi)
 */
function loadDefaultCourtConfig() {
    state.courts = [
        { name: 'S√¢n 1', startTime: '14:00', maxDurationMinutes: 180, isMixed: true },
        { name: 'S√¢n 2', startTime: '14:00', maxDurationMinutes: 180, isMixed: true },
        { name: 'S√¢n 3', startTime: '14:00', maxDurationMinutes: 180, isMixed: false },
        { name: 'S√¢n 4', startTime: '14:00', maxDurationMinutes: 180, isMixed: false }
    ];
    
    renderCourtList();
    stateChanged = true;
    updateStatus('courtConfigStatus', 'success', 'ƒê√£ t·∫£i c·∫•u h√¨nh s√¢n M·∫∑c ƒë·ªãnh. D·ªØ li·ªáu s·∫Ω ƒë∆∞·ª£c t·ª± ƒë·ªông l∆∞u l√™n GitHub.');
    saveToGitHub();
}


function loadConfig() {
    const savedConfig = localStorage.getItem('pkb_config');
    if (savedConfig) {
        state.config = JSON.parse(savedConfig);
        document.getElementById('cfgOwner').value = state.config.owner || '';
        document.getElementById('cfgRepo').value = state.config.repo || '';
        document.getElementById('cfgFolder').value = state.config.folder || 'data';
        document.getElementById('cfgFile').value = state.config.file || 'state.json';
        document.getElementById('cfgToken').value = state.config.token || '';
    }
}

function saveConfig(){
  const cfg = {
    owner: document.getElementById('cfgOwner').value,
    repo: document.getElementById('cfgRepo').value,
    folder: document.getElementById('cfgFolder').value,
    file: document.getElementById('cfgFile').value,
    token: document.getElementById('cfgToken').value
  };
  state.config = cfg;
  localStorage.setItem('pkb_config', JSON.stringify(cfg));
  updateStatus('configStatus', 'success', 'ƒê√£ l∆∞u c·∫•u h√¨nh GitHub v√†o tr√¨nh duy·ªát. Vui l√≤ng Ki·ªÉm tra & T·∫£i D·ªØ li·ªáu.');
}

function updateStatus(id, type, message) {
    const statusDiv = document.getElementById(id);
    statusDiv.innerHTML = `<div class="alert alert-${type} p-2 mt-2">${message}</div>`;
}

function startAutoSave() {
    if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
    }
    
    if (state.config.token && state.config.owner && state.config.repo) {
        autoSaveInterval = setInterval(saveToGitHub, 60000);
        document.getElementById('autoState').className = 'text-warning';
        document.getElementById('autoState').textContent = 'Ho·∫°t ƒë·ªông...';
    } else {
        document.getElementById('autoState').className = 'text-danger';
        document.getElementById('autoState').textContent = 'T·∫Øt';
    }
}


window.onload = function() {
    loadConfig();
    
    // ƒê·∫∑t m·∫∑c ƒë·ªãnh cho select box th√†nh 'court' khi load trang (d√π ƒë√£ c√≥ 'selected' trong HTML)
    const viewModeSelect = document.getElementById('viewMode');
    if (viewModeSelect && viewModeSelect.value !== 'court') {
        viewModeSelect.value = 'court'; 
    }

    if (state.config.token) {
        // B·∫Øt ƒë·∫ßu quy tr√¨nh t·∫£i Teams v√† App State t·ª´ GitHub
        loadFromGitHub(); 
    } else {
        // T·∫£i c·∫•u h√¨nh s√¢n m·∫∑c ƒë·ªãnh n·∫øu kh√¥ng c√≥ k·∫øt n·ªëi GitHub
        renderConfig(); 
        renderMatches();
        tinhVaCapNhatXepHang();
        renderFinals();
        renderFinalResults();
        renderOverview(); 
        startAutoSave(); 
    }
};

// --- Tab T·ªïng quan (Gi·ªØ nguy√™n) ---
function renderOverview() {
    const allPlayers = [...state.mixedTeams, ...state.maleTeams]
        .flatMap(team => team.split('/')).map(p => p.trim());
    const uniquePlayers = Array.from(new Set(allPlayers)).sort();
    const totalTeams = state.mixedTeams.length + state.maleTeams.length;
    const totalMatchesA = state.matchesA.length;
    const totalMatchesB = state.matchesB.length;
    const completedMatches = [...state.matchesA, ...state.matchesB].filter(m => m.scoreA !== null && m.scoreB !== null).length;
    const totalMatches = totalMatchesA + totalMatchesB;
    let html = `
        <div class="row">
            <div class="col-md-6 mb-4">
                <div class="card shadow-sm border-primary">
                    <div class="card-body">
                        <h5 class="card-title text-primary">üìä Th√¥ng tin Gi·∫£i ƒë·∫•u</h5>
                        <p><strong>T·ªïng s·ªë V·∫≠n ƒë·ªông vi√™n:</strong> <span class="badge bg-primary">${uniquePlayers.length}</span> ng∆∞·ªùi</p>
                        <p><strong>T·ªïng s·ªë ƒê·ªôi tham gia:</strong> <span class="badge bg-primary">${totalTeams}</span> ƒë·ªôi</p>
                        <p><strong>T·ªïng s·ªë Tr·∫≠n ƒë·∫•u (V√≤ng B·∫£ng):</strong> <span class="badge bg-primary">${totalMatches}</span> tr·∫≠n (ƒê√£ ho√†n th√†nh: ${completedMatches}/${totalMatches})</p>
                    </div>
                </div>
            </div>
            <div class="col-md-6 mb-4">
                <div class="card shadow-sm border-success">
                    <div class="card-body">
                        <h5 class="card-title text-success">üìã Ph√¢n lo·∫°i B·∫£ng ƒë·∫•u</h5>
                        <p><strong>B·∫£ng A (Nam - N·ªØ):</strong> ${state.mixedTeams.length} ƒë·ªôi (T·ªïng ${totalMatchesA} tr·∫≠n)</p>
                        <p><strong>B·∫£ng B (Nam):</strong> ${state.maleTeams.length} ƒë·ªôi (T·ªïng ${totalMatchesB} tr·∫≠n)</p>
                    </div>
                </div>
            </div>
        </div>

        <div class="card mt-2 shadow-sm">
            <div class="card-body">
                <h5 class="card-title text-secondary">üë• Danh s√°ch ƒê·ªôi & V·∫≠n ƒë·ªông vi√™n</h5>
                <div class="row">
                    <div class="col-lg-6">
                        <h6>B·∫£ng A (Nam-N·ªØ):</h6>
                        <ul class="list-group list-group-flush small">
                            ${state.mixedTeams.map(team => `<li class="list-group-item">${team}</li>`).join('')}
                        </ul>
                    </div>
                    <div class="col-lg-6">
                        <h6>B·∫£ng B (Nam):</h6>
                        <ul class="list-group list-group-flush small">
                            ${state.maleTeams.map(team => `<li class="list-group-item">${team}</li>`).join('')}
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    `;
    document.getElementById('overviewContent').innerHTML = html;
}

// --- V√≤ng B·∫£ng: T·∫°o L·ªãch C·ªë ƒê·ªãnh (Gi·ªØ nguy√™n logic) ---
function parseFixedSchedule(csvContent, mixedTeams, maleTeams) {
    const allMatches = [];
    const rows = csvContent.trim().split('\r\n'); // B·ªè qua d√≤ng ti√™u ƒë·ªÅ ƒë·∫ßu ti√™n
    const dataRows = rows.slice(1);
    
    // C·∫≠p nh·∫≠t c·∫•u h√¨nh s√¢n d·ª±a tr√™n file CSV c·ªë ƒë·ªãnh (n·∫øu mu·ªën)
    const COURT_CONFIG = [
        { colIndex: 3, courtName: 'S√¢n 1' },
        { colIndex: 4, courtName: 'S√¢n 2' },
        { colIndex: 5, courtName: 'S√¢n 3' },
        { colIndex: 6, courtName: 'S√¢n 7' },
    ];
    
    dataRows.forEach(row => {
        const columns = row.split(',');
        const time = columns[0] ? columns[0].trim() : '';
        
        COURT_CONFIG.forEach(court => {
            let matchString = columns[court.colIndex] ? columns[court.colIndex].trim() : '';
            
            if (matchString && matchString.toLowerCase() !== 'd·ª± ph√≤ng' && matchString !== '-' && matchString.includes(' - ')) {
                const teams = matchString.split(' - ');
                if (teams.length === 2) {
                    const teamA = teams[0].trim();
                    const teamB = teams[1].trim();
                    
                    let bang = null;
                    
                    const teamAExistsA = mixedTeams.includes(teamA);
                    const teamBExistsA = mixedTeams.includes(teamB);
                    const teamAExistsB = maleTeams.includes(teamA);
                    const teamBExistsB = maleTeams.includes(teamB);
                    
                    if (teamAExistsA && teamBExistsA) {
                        bang = 'A';
                    } else if (teamAExistsB && teamBExistsB) {
                        bang = 'B';
                    } else {
                        // B·ªè qua tr·∫≠n ƒë·∫•u c√≥ ƒë·ªôi kh√¥ng r√µ r√†ng ho·∫∑c sai b·∫£ng
                        return;
                    }

                    allMatches.push({
                        teamA,
                        teamB,
                        time,
                        court: court.courtName,
                        bang,
                        scoreA: null,
                        scoreB: null
                    });
                }
            }
        });
    });

    allMatches.sort((a, b) => {
        const timeToMinutes = (t) => {
            const [h, m] = t.split(':').map(Number);
            return h * 60 + m;
        };
        return timeToMinutes(a.time) - timeToMinutes(b.time);
    });

    return {
        matchesA: allMatches.filter(m => m.bang === 'A'),
        matchesB: allMatches.filter(m => m.bang === 'B')
    };
}

function taoLichCoDinh() {
    const csvData = parseFixedSchedule(FIXED_SCHEDULE_CSV, state.mixedTeams, state.maleTeams);
    
    state.matchesA = csvData.matchesA;
    state.matchesB = csvData.matchesB;
    
    renderMatches();
    tinhVaCapNhatXepHang();
    renderOverview();
    stateChanged = true;
    
    // Chuy·ªÉn tab v√† cu·ªôn l√™n tr√™n
    switchTab('matches'); 
    window.scrollTo(0, 0);
    showModal('Th√†nh c√¥ng', `ƒê√£ t·∫°o ${state.matchesA.length} tr·∫≠n B·∫£ng A v√† ${state.matchesB.length} tr·∫≠n B·∫£ng B t·ª´ l·ªãch C·ªë ƒë·ªãnh.`);
    saveToGitHub();
}

// --- V√≤ng B·∫£ng: T·∫°o L·ªãch T·ªëi ∆Øu (NEW LOGIC) ---
function generateRoundRobin(teams) {
    const n = teams.length;
    if (n % 2 !== 0) {
        // N·∫øu s·ªë ƒë·ªôi l·∫ª, th√™m m·ªôt ƒë·ªôi "·∫£o" (BYE)
        teams = [...teams, 'BYE'];
    }
    const numTeams = teams.length;
    const numRounds = numTeams - 1;
    const matches = [];

    // Danh s√°ch ƒë·ªôi ƒë·ªÉ xoay v√≤ng, gi·ªØ ƒë·ªôi ƒë·∫ßu ti√™n c·ªë ƒë·ªãnh
    let rotatingTeams = teams.slice(1);
    const fixedTeam = teams[0];

    for (let round = 0; round < numRounds; round++) {
        // C·∫∑p ƒë·∫•u v·ªõi ƒë·ªôi c·ªë ƒë·ªãnh
        let teamA = fixedTeam;
        let teamB = rotatingTeams[0];
        if (teamA !== 'BYE' && teamB !== 'BYE') {
            matches.push([teamA, teamB]);
        }

        // C·∫∑p ƒë·∫•u c√≤n l·∫°i
        for (let i = 1; i < numTeams / 2; i++) {
            teamA = rotatingTeams[i];
            teamB = rotatingTeams[numTeams - 1 - i];
            if (teamA !== 'BYE' && teamB !== 'BYE') {
                matches.push([teamA, teamB]);
            }
        }
        
        // Xoay v√≤ng: ƒê·ªôi cu·ªëi c√πng l√™n ƒë·∫ßu danh s√°ch xoay
        const lastTeam = rotatingTeams.pop();
        rotatingTeams.unshift(lastTeam);
    }
    
    // ƒê·∫£m b·∫£o m·ªói c·∫∑p ƒë·∫•u ch·ªâ xu·∫•t hi·ªán 1 l·∫ßn
    const uniqueMatches = [];
    const matchSet = new Set();

    matches.forEach(match => {
        // Chu·∫©n h√≥a t√™n ƒë·ªôi ƒë·ªÉ d·ªÖ so s√°nh (vd: ['A', 'B'] v√† ['B', 'A'] l√† m·ªôt)
        const sortedMatch = match.sort().join('|');
        if (!matchSet.has(sortedMatch)) {
            matchSet.add(sortedMatch);
            uniqueMatches.push(match);
        }
    });

    // T·∫°o th√™m l∆∞·ª£t v·ªÅ (optional, th∆∞·ªùng d√πng cho Round Robin 2 l∆∞·ª£t)
    // Hi·ªán t·∫°i: Ch·ªâ d√πng 1 l∆∞·ª£t ƒëi (n·∫øu n ƒë·ªôi, m·ªói ƒë·ªôi ƒë·∫•u n-1 tr·∫≠n. T·ªïng n*(n-1)/2 tr·∫≠n)
    
    return uniqueMatches.map(([teamA, teamB]) => ({ teamA, teamB }));
}

/**
 * H√†m ki·ªÉm tra xem 1 ƒë·ªôi c√≥ c√≤n tr·∫≠n ƒë·∫•u ch∆∞a x·∫øp l·ªãch hay kh√¥ng
 * @param {string} team - T√™n ƒë·ªôi
 * @param {Array} generatedMatches - Danh s√°ch c√°c tr·∫≠n ƒë·∫•u ƒë√£ x·∫øp l·ªãch
 * @param {Array} matchesToSchedule - Danh s√°ch c√°c tr·∫≠n ƒë·∫•u c·∫ßn x·∫øp l·ªãch (ƒë·∫ßu v√†o)
 * @returns {number} - S·ªë tr·∫≠n ch∆∞a ƒë·∫•u c√≤n l·∫°i
 */
function countRemainingMatches(team, generatedMatches, matchesToSchedule) {
    const allPlayedMatches = new Set(generatedMatches.flatMap(m => m.teamA).filter(t => t === team));
    allPlayedMatches.add(...generatedMatches.flatMap(m => m.teamB).filter(t => t === team));

    let count = 0;
    for (const match of matchesToSchedule) {
        // T·∫°o key chu·∫©n h√≥a
        const key = [match.teamA, match.teamB].sort().join('|');
        
        // Ki·ªÉm tra xem tr·∫≠n ƒë·∫•u n√†y ƒë√£ c√≥ trong generatedMatches ch∆∞a (theo key chu·∫©n h√≥a)
        const isScheduled = generatedMatches.some(gm => 
            [gm.teamA, gm.teamB].sort().join('|') === key
        );

        if (!isScheduled && (match.teamA === team || match.teamB === team)) {
            count++;
        }
    }
    return count;
}


/**
 * X·∫øp l·ªãch thi ƒë·∫•u T·ªëi ∆∞u theo S√¢n v√† Gi·ªù B·∫Øt ƒë·∫ßu c·∫•u h√¨nh
 */
function taoLichThiDauCungGio() {
    // 1. L·∫•y v√† ph√¢n lo·∫°i S√¢n
    const mixedCourts = state.courts.filter(c => c.isMixed).sort((a, b) => a.name.localeCompare(b.name));
    const maleCourts = state.courts.filter(c => !c.isMixed).sort((a, b) => a.name.localeCompare(b.name));

    if (mixedCourts.length === 0 && maleCourts.length === 0) {
        showModal('L·ªói', 'Ch∆∞a c√≥ s√¢n thi ƒë·∫•u n√†o ƒë∆∞·ª£c c·∫•u h√¨nh. Vui l√≤ng v√†o tab C·∫•u h√¨nh ƒë·ªÉ th√™m s√¢n.');
        return;
    }
    
    if (state.mixedTeams.length < 2 && state.maleTeams.length < 2) {
        showModal('L·ªói', 'Ch∆∞a c√≥ ƒë·ªß ƒë·ªôi (√≠t nh·∫•t 2 ƒë·ªôi/b·∫£ng) ƒë·ªÉ t·∫°o l·ªãch. Vui l√≤ng ki·ªÉm tra file players.json ho·∫∑c danh s√°ch ƒë·ªôi.');
        return;
    }

    // 2. T·∫°o danh s√°ch c√°c tr·∫≠n ƒë·∫•u Round Robin
    const allMatchesA = generateRoundRobin(state.mixedTeams);
    const allMatchesB = generateRoundRobin(state.maleTeams);
    
    if (allMatchesA.length === 0 && allMatchesB.length === 0) {
         showModal('L·ªói', 'Kh√¥ng th·ªÉ t·∫°o l·ªãch. Vui l√≤ng ki·ªÉm tra l·∫°i danh s√°ch ƒë·ªôi (ph·∫£i c√≥ √≠t nh·∫•t 2 ƒë·ªôi trong m·ªói b·∫£ng).');
        return;
    }

    // 3. X·∫øp l·ªãch cho B·∫£ng A (Mixed)
    let scheduledMatchesA = scheduleMatchesForCourts(allMatchesA, mixedCourts, 'A');

    // 4. X·∫øp l·ªãch cho B·∫£ng B (Male)
    let scheduledMatchesB = scheduleMatchesForCourts(allMatchesB, maleCourts, 'B');

    // 5. C·∫≠p nh·∫≠t State
    state.matchesA = scheduledMatchesA;
    state.matchesB = scheduledMatchesB;
    
    // 6. C·∫≠p nh·∫≠t UI
    renderMatches();
    tinhVaCapNhatXepHang();
    renderOverview();
    stateChanged = true;
    
    // Chuy·ªÉn tab v√† th√¥ng b√°o
    switchTab('matches'); 
    window.scrollTo(0, 0);
    showModal('Th√†nh c√¥ng', `ƒê√£ t·∫°o l·ªãch thi ƒë·∫•u T·ªëi ∆∞u:<br> - B·∫£ng A: ${state.matchesA.length} tr·∫≠n<br> - B·∫£ng B: ${state.matchesB.length} tr·∫≠n. L·ªãch s·∫Ω ƒë∆∞·ª£c t·ª± ƒë·ªông l∆∞u l√™n GitHub.`);
    saveToGitHub();
}

/**
 * X·∫øp l·ªãch c√°c tr·∫≠n ƒë·∫•u v√†o danh s√°ch s√¢n ƒë√£ cho
 * @param {Array<{teamA: string, teamB: string}>} matchesToSchedule - Danh s√°ch c√°c tr·∫≠n ƒë·∫•u c·∫ßn x·∫øp l·ªãch
 * @param {Array<{name: string, startTime: string, maxDurationMinutes: number}>} courts - Danh s√°ch s√¢n thi ƒë·∫•u
 * @param {string} bang - T√™n b·∫£ng ('A' ho·∫∑c 'B')
 * @returns {Array<Match>} - Danh s√°ch tr·∫≠n ƒë·∫•u ƒë√£ ƒë∆∞·ª£c x·∫øp l·ªãch
 */
function scheduleMatchesForCourts(matchesToSchedule, courts, bang) {
    if (courts.length === 0 || matchesToSchedule.length === 0) {
        return [];
    }
    
    const MATCH_DURATION = 15; // M·ªói tr·∫≠n 15 ph√∫t
    const scheduledMatches = [];
    const teams = bang === 'A' ? state.mixedTeams : state.maleTeams;
    
    // Kh·ªüi t·∫°o tr·∫°ng th√°i s√¢n: currentCourtTime l√† th·ªùi ƒëi·ªÉm s√¢n tr·ªëng
    const courtStates = courts.map(c => ({
        name: c.name,
        currentTime: parseTime(c.startTime), // Th·ªùi gian b·∫Øt ƒë·∫ßu b·∫±ng ph√∫t
        endTime: parseTime(c.startTime) + c.maxDurationMinutes, // Th·ªùi gian k·∫øt th√∫c b·∫±ng ph√∫t
        lastPlayedTeam: new Set(), // Set c√°c ƒë·ªôi v·ª´a ƒë·∫•u tr√™n s√¢n n√†y (ch·ªâ c·∫ßn teamA/teamB c·ªßa tr·∫≠n cu·ªëi)
        lastMatchFinish: parseTime(c.startTime) // Th·ªùi ƒëi·ªÉm tr·∫≠n cu·ªëi k·∫øt th√∫c
    }));

    // Kh·ªüi t·∫°o tr·∫°ng th√°i ƒë·ªôi: lastPlayedTime l√† th·ªùi ƒëi·ªÉm ƒë·ªôi k·∫øt th√∫c tr·∫≠n cu·ªëi c√πng
    const teamStates = new Map(teams.map(team => [team, 0])); // 0 l√† th·ªùi ƒëi·ªÉm b·∫Øt ƒë·∫ßu thi ƒë·∫•u

    let matchIndex = 0;
    while (matchIndex < matchesToSchedule.length) {
        const currentMatch = matchesToSchedule[matchIndex];
        let bestCourtIndex = -1;
        let earliestFinishTime = Infinity;

        // 1. T√¨m s√¢n s·ªõm nh·∫•t c√≥ th·ªÉ thi ƒë·∫•u
        for (let i = 0; i < courtStates.length; i++) {
            const court = courtStates[i];
            
            // T√≠nh th·ªùi ƒëi·ªÉm match n√†y c√≥ th·ªÉ b·∫Øt ƒë·∫ßu (Max(Th·ªùi ƒëi·ªÉm s√¢n tr·ªëng, Th·ªùi ƒëi·ªÉm ƒë·ªôi A r·∫£nh, Th·ªùi ƒëi·ªÉm ƒë·ªôi B r·∫£nh))
            const teamAReady = teamStates.get(currentMatch.teamA) || 0;
            const teamBReady = teamStates.get(currentMatch.teamB) || 0;
            
            // Th·ªùi ƒëi·ªÉm s·ªõm nh·∫•t c√≥ th·ªÉ b·∫Øt ƒë·∫ßu: Max(S√¢n tr·ªëng, ƒê·ªôi A r·∫£nh, ƒê·ªôi B r·∫£nh)
            const earliestStart = Math.max(court.lastMatchFinish, teamAReady, teamBReady);
            
            const finishTime = earliestStart + MATCH_DURATION;
            
            // Ki·ªÉm tra ƒëi·ªÅu ki·ªán r√†ng bu·ªôc:
            // a. Kh√¥ng v∆∞·ª£t qu√° MaxDuration c·ªßa s√¢n
            if (finishTime > court.endTime) {
                continue; // S√¢n n√†y kh√¥ng ƒë·ªß th·ªùi gian
            }
            
            // b. Tr√°nh cho ƒë·ªôi v·ª´a ƒë·∫•u l·∫°i ƒë·∫•u ngay tr√™n s√¢n n√†y (gi·∫£ ƒë·ªãnh 15p ngh·ªâ gi·ªØa 2 tr·∫≠n tr√™n 1 s√¢n)
            // L·∫ßn ch·∫°y ƒë·∫ßu ti√™n s·∫Ω kh√¥ng c√≥ ƒë·ªôi n√†o trong lastPlayedTeam, n√™n kh√¥ng b·ªã ch·∫∑n.
            const hasRestingTime = earliestStart >= court.lastMatchFinish + MATCH_DURATION;
            
            // c. ∆Øu ti√™n s√¢n c√≥ th·ªÉ ho√†n th√†nh s·ªõm nh·∫•t
            if (hasRestingTime && finishTime < earliestFinishTime) {
                earliestFinishTime = finishTime;
                bestCourtIndex = i;
            }
        }

        if (bestCourtIndex !== -1) {
            // X·∫øp l·ªãch th√†nh c√¥ng
            const bestCourt = courtStates[bestCourtIndex];
            const startTimeInMinutes = earliestFinishTime - MATCH_DURATION;
            const startTimeString = formatMinutesToTime(startTimeInMinutes);

            scheduledMatches.push({
                ...currentMatch,
                time: startTimeString,
                court: bestCourt.name,
                bang: bang,
                scoreA: null,
                scoreB: null
            });

            // C·∫≠p nh·∫≠t tr·∫°ng th√°i s√¢n
            bestCourt.lastMatchFinish = earliestFinishTime;
            
            // C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë·ªôi
            teamStates.set(currentMatch.teamA, earliestFinishTime);
            teamStates.set(currentMatch.teamB, earliestFinishTime);
            
            matchIndex++; // Chuy·ªÉn sang tr·∫≠n ti·∫øp theo
        } else {
            // Tr∆∞·ªùng h·ª£p kh√¥ng t√¨m th·∫•y s√¢n n√†o ph√π h·ª£p cho tr·∫≠n n√†y (qu√° gi·ªù ho·∫∑c kh√¥ng c√≥ s√¢n)
            // L·∫•y s√¢n c√≥ th·ªùi gian tr·ªëng s·ªõm nh·∫•t ƒë·ªÉ x·∫øp v√†o (ƒë·ªÉ tr√°nh v√≤ng l·∫∑p v√¥ h·∫°n, nh∆∞ng c·∫£nh b√°o)
            // Do logic n√†y l√† t·ªëi ∆∞u h√≥a, n·∫øu kh√¥ng t√¨m ƒë∆∞·ª£c s√¢n t·ªët, ta s·∫Ω ch·∫•p nh·∫≠n s√¢n tr·ªëng s·ªõm nh·∫•t (b·ªè qua r√†ng bu·ªôc rest)
            
            let fallbackCourtIndex = -1;
            let earliestAvailableTime = Infinity;

            for (let i = 0; i < courtStates.length; i++) {
                const court = courtStates[i];
                if (court.lastMatchFinish < court.endTime && court.lastMatchFinish < earliestAvailableTime) {
                    earliestAvailableTime = court.lastMatchFinish;
                    fallbackCourtIndex = i;
                }
            }

            if (fallbackCourtIndex !== -1) {
                // X·∫øp l·ªãch cho tr·∫≠n ƒë·∫•u n√†y v√†o s√¢n c√≥ th·ªÉ b·∫Øt ƒë·∫ßu s·ªõm nh·∫•t
                const fallbackCourt = courtStates[fallbackCourtIndex];
                const teamAReady = teamStates.get(currentMatch.teamA) || 0;
                const teamBReady = teamStates.get(currentMatch.teamB) || 0;
                
                const startTimeInMinutes = Math.max(fallbackCourt.lastMatchFinish, teamAReady, teamBReady);
                const finishTime = startTimeInMinutes + MATCH_DURATION;
                
                if (finishTime <= fallbackCourt.endTime) {
                    const startTimeString = formatMinutesToTime(startTimeInMinutes);
                    
                     scheduledMatches.push({
                        ...currentMatch,
                        time: startTimeString,
                        court: fallbackCourt.name,
                        bang: bang,
                        scoreA: null,
                        scoreB: null
                    });
                    
                    fallbackCourt.lastMatchFinish = finishTime;
                    teamStates.set(currentMatch.teamA, finishTime);
                    teamStates.set(currentMatch.teamB, finishTime);
                    
                    matchIndex++;
                } else {
                    // N·∫øu ngay c·∫£ s√¢n s·ªõm nh·∫•t c≈©ng kh√¥ng ƒë·ªß th·ªùi gian
                    console.warn(`[${bang}] B·ªè qua tr·∫≠n ${currentMatch.teamA} vs ${currentMatch.teamB} v√¨ qu√° gi·ªù ${fallbackCourt.name}`);
                    matchIndex++;
                }

            } else {
                // H·∫øt s√¢n cho b·∫£ng n√†y
                console.warn(`[${bang}] H·∫øt s√¢n thi ƒë·∫•u, d·ª´ng x·∫øp l·ªãch.`);
                break;
            }
        }
    }
    
    // S·∫Øp x·∫øp l·∫°i theo th·ªùi gian
    scheduledMatches.sort((a, b) => parseTime(a.time) - parseTime(b.time));

    return scheduledMatches;
}

/**
 * Chuy·ªÉn ƒë·ªïi chu·ªói th·ªùi gian HH:mm sang s·ªë ph√∫t t·ª´ 00:00
 * @param {string} timeStr - Chu·ªói th·ªùi gian (HH:mm)
 * @returns {number} - S·ªë ph√∫t
 */
function parseTime(timeStr) {
    if (!timeStr) return 0;
    const [h, m] = timeStr.split(':').map(Number);
    return h * 60 + m;
}

/**
 * Chuy·ªÉn ƒë·ªïi s·ªë ph√∫t sang chu·ªói th·ªùi gian HH:mm
 * @param {number} minutes - S·ªë ph√∫t
 * @returns {string} - Chu·ªói th·ªùi gian (HH:mm)
 */
function formatMinutesToTime(minutes) {
    const h = Math.floor(minutes / 60);
    const m = minutes % 60;
    const H = String(h).padStart(2, '0');
    const M = String(m).padStart(2, '0');
    return `${H}:${M}`;
}

// --- V√≤ng B·∫£ng: Ch·∫ø ƒë·ªô Xem (Gi·ªØ nguy√™n) ---

/**
 * C·∫≠p nh·∫≠t ƒëi·ªÉm s·ªë v√† t√≠nh to√°n ng∆∞·ªùi th·∫Øng/thua.
 * @param {HTMLInputElement} input - Input element g·ªçi h√†m
 * @param {string} type - Lo·∫°i tr·∫≠n ƒë·∫•u ('A', 'B', 'semifinals', 'final')
 * @param {string | number} id - Index c·ªßa tr·∫≠n ƒë·∫•u (ho·∫∑c id n·∫øu l√† v√≤ng CK)
 * @param {boolean} isTeamA - true n·∫øu l√† ƒëi·ªÉm c·ªßa ƒë·ªôi A, false n·∫øu l√† ƒë·ªôi B
 */
function capNhatTiSo(input, type, id, isTeamA) {
    let score = parseInt(input.value);
    
    // ƒê·∫£m b·∫£o ƒëi·ªÉm h·ª£p l·ªá
    if (isNaN(score) || score < 0) {
        input.value = '';
        score = null;
    }

    let match;
    let matchId = id;
    let list;

    if (type === 'semifinals' || type === 'final') {
        if (type === 'semifinals') {
            list = state.semifinals;
        } else {
            list = [state.final];
        }
        match = list.find(m => m.id === id);
    } else {
        matchId = parseInt(id);
        list = type === 'A' ? state.matchesA : state.matchesB;
        match = list[matchId];
    }
    
    if (!match) return;

    if (isTeamA) {
        match.scoreA = score;
    } else {
        match.scoreB = score;
    }
    
    // Logic t√≠nh to√°n th·∫Øng/thua chung
    if (type === 'semifinals' || type === 'final') {
        const scoreA = match.scoreA;
        const scoreB = match.scoreB;

        if (scoreA !== null && scoreB !== null) {
             if (scoreA > scoreB) {
                match.winner = match.teamA;
                match.loser = match.teamB;
                match.runnerUp = (type === 'final') ? match.teamB : null;
            } else if (scoreB > scoreA) {
                match.winner = match.teamB;
                match.loser = match.teamA;
                match.runnerUp = (type === 'final') ? match.teamA : null;
            } else {
                match.winner = null;
                match.loser = null;
                match.runnerUp = null;
            }
            renderFinals();
            renderFinalResults();
            
        } else {
            match.winner = null;
            match.loser = null;
            match.runnerUp = null;
        }

    } else {
        // V√≤ng b·∫£ng
        const scoreA = match.scoreA;
        const scoreB = match.scoreB;

        if (scoreA !== null && scoreB !== null) {
            if (scoreA > scoreB) {
                match.winner = match.teamA;
                match.loser = match.teamB;
            } else if (scoreB > scoreA) {
                match.winner = match.teamB;
                match.loser = match.teamA;
            } else {
                // Tr∆∞·ªùng h·ª£p h√≤a: kh√¥ng g√°n winner/loser
                match.winner = null;
                match.loser = null;
            }
        } else {
            match.winner = null;
            match.loser = null;
        }

        renderMatches(); // Render l·∫°i ƒë·ªÉ c·∫≠p nh·∫≠t m√†u s·∫Øc
        tinhVaCapNhatXepHang();
    }
    
    stateChanged = true;
    // C·∫≠p nh·∫≠t l√™n GitHub ngay l·∫≠p t·ª©c khi t·ªâ s·ªë thay ƒë·ªïi
    saveToGitHub();
}

// H√†m render ch√≠nh ƒë·ªÉ ch·ªçn ch·∫ø ƒë·ªô xem
function renderMatchesView() {
    const viewMode = document.getElementById('viewMode').value;
    const contentDiv = document.getElementById('matchesViewContent');
    
    if (viewMode === 'table') {
        contentDiv.innerHTML = `
            <h6 id="scheduleAHeader" class="mt-4">B·∫£ng A (Nam - N·ªØ)</h6><div id="tableMatchesA"></div>
            <h6 class="mt-4">B·∫£ng B (Nam)</h6><div id="tableMatchesB"></div>
        `;
        renderMatchesByTable(state.matchesA, 'tableMatchesA', 'A');
        renderMatchesByTable(state.matchesB, 'tableMatchesB', 'B');
    } else {
        contentDiv.innerHTML = `<div id="courtMatches"></div>`;
        renderMatchesByCourt();
    }
}

// Ch·∫ø ƒë·ªô xem theo B·∫£ng ƒë·∫•u (Table View)
function renderMatchesByTable(matches, containerId, type) {
    const container = document.getElementById(containerId);
    if (!container) return;

    if (matches.length === 0) {
        container.innerHTML = `<div class="alert alert-info">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u cho B·∫£ng ${type}.</div>`;
        return;
    }

    let html = `<div class='table-responsive'><table class='table table-bordered table-striped table-sm'>
        <thead>
            <tr>
                <th>#</th>
                <th>Gi·ªù</th>
                <th>S√¢n</th>
                <th>ƒê·ªôi A</th>
                <th class="text-center">T·ªâ s·ªë</th>
                <th>ƒê·ªôi B</th>
                <th>K·∫øt qu·∫£</th>
            </tr>
        </thead>
        <tbody>`;

    matches.forEach((match, index) => {
        const teamAClass = match.winner === match.teamA ? 'winner' : (match.loser === match.teamA ? 'loser' : '');
        const teamBClass = match.winner === match.teamB ? 'winner' : (match.loser === match.teamB ? 'loser' : '');
        const winnerText = match.winner ? match.winner : (match.scoreA !== null && match.scoreB !== null && match.scoreA === match.scoreB ? 'H√≤a' : 'ƒêang ƒë·∫•u');

        html += `<tr>
            <td>${index + 1}</td>
            <td>${match.time}</td>
            <td>${match.court}</td>
            <td class="${teamAClass}">${match.teamA}</td>
            <td class="match-score-cell d-flex justify-content-center align-items-center">
                <input type='number' min='0' value='${match.scoreA !== null ? match.scoreA : ''}' onchange='capNhatTiSo(this, "${type}", ${index}, true)' class='form-control form-control-sm'>
                -
                <input type='number' min='0' value='${match.scoreB !== null ? match.scoreB : ''}' onchange='capNhatTiSo(this, "${type}", ${index}, false)' class='form-control form-control-sm'>
            </td>
            <td class="${teamBClass}">${match.teamB}</td>
            <td>${winnerText}</td>
        </tr>`;
    });

    html += `</tbody></table></div>`;
    container.innerHTML = html;
}

// Ch·∫ø ƒë·ªô xem theo S√¢n thi ƒë·∫•u (Court View)
function renderMatchesByCourt() {
    const courtMatchesDiv = document.getElementById('courtMatches');
    if (!courtMatchesDiv) return;
    
    // G·ªôp t·∫•t c·∫£ c√°c tr·∫≠n ƒë·∫•u v√† ph√¢n nh√≥m theo S√¢n
    const allMatches = [...state.matchesA, ...state.matchesB];
    if (allMatches.length === 0) {
        courtMatchesDiv.innerHTML = `<div class="alert alert-info">Ch∆∞a c√≥ l·ªãch thi ƒë·∫•u. Vui l√≤ng t·∫°o l·ªãch trong tab C·∫•u h√¨nh.</div>`;
        return;
    }

    // S·∫Øp x·∫øp c√°c tr·∫≠n ƒë·∫•u theo S√¢n, sau ƒë√≥ theo Gi·ªù
    allMatches.sort((a, b) => {
        if (a.court < b.court) return -1;
        if (a.court > b.court) return 1;
        return parseTime(a.time) - parseTime(b.time);
    });

    // Gom nh√≥m theo S√¢n
    const matchesByCourt = allMatches.reduce((acc, match) => {
        acc[match.court] = acc[match.court] || [];
        acc[match.court].push(match);
        return acc;
    }, {});

    let html = '';
    const courtNames = Object.keys(matchesByCourt).sort();

    courtNames.forEach(courtName => {
        const matches = matchesByCourt[courtName];
        html += `<h5 class="mt-4 mb-2 text-primary">üèüÔ∏è ${courtName}</h5>`;
        html += `<div class='table-responsive'><table class='table table-bordered table-striped table-sm'>
            <thead>
                <tr>
                    <th>#</th>
                    <th>Gi·ªù B·∫Øt ƒë·∫ßu</th>
                    <th>Gi·ªù K·∫øt th√∫c (d·ª± ki·∫øn)</th>
                    <th>B·∫£ng</th>
                    <th>ƒê·ªôi A</th>
                    <th class="text-center">T·ªâ s·ªë</th>
                    <th>ƒê·ªôi B</th>
                    <th>K·∫øt qu·∫£</th>
                </tr>
            </thead>
            <tbody>`;

        matches.forEach((match, index) => {
            const timeInMinutes = parseTime(match.time);
            const endTime = formatMinutesToTime(timeInMinutes + 15);
            
            // T√¨m index g·ªëc ƒë·ªÉ d√πng cho h√†m capNhatTiSo
            let originalIndex, type;
            if (match.bang === 'A') {
                originalIndex = state.matchesA.findIndex(m => m.teamA === match.teamA && m.teamB === match.teamB && m.time === match.time && m.court === match.court);
                type = 'A';
            } else {
                originalIndex = state.matchesB.findIndex(m => m.teamA === match.teamA && m.teamB === match.teamB && m.time === match.time && m.court === match.court);
                type = 'B';
            }
            
            const teamAClass = match.winner === match.teamA ? 'winner' : (match.loser === match.teamA ? 'loser' : '');
            const teamBClass = match.winner === match.teamB ? 'winner' : (match.loser === match.teamB ? 'loser' : '');
            const winnerText = match.winner ? match.winner : (match.scoreA !== null && match.scoreB !== null && match.scoreA === match.scoreB ? 'H√≤a' : 'ƒêang ƒë·∫•u');
            const bangClass = match.bang === 'A' ? 'badge bg-primary' : 'badge bg-info';

            html += `<tr>
                <td>${index + 1}</td>
                <td>${match.time}</td>
                <td>${endTime}</td>
                <td><span class="${bangClass}">B·∫£ng ${match.bang}</span></td>
                <td class="${teamAClass}">${match.teamA}</td>
                <td class="match-score-cell d-flex justify-content-center align-items-center">
                    <input type='number' min='0' value='${match.scoreA !== null ? match.scoreA : ''}' onchange='capNhatTiSo(this, "${type}", ${originalIndex}, true)' class='form-control form-control-sm'>
                    -
                    <input type='number' min='0' value='${match.scoreB !== null ? match.scoreB : ''}' onchange='capNhatTiSo(this, "${type}", ${originalIndex}, false)' class='form-control form-control-sm'>
                </td>
                <td class="${teamBClass}">${match.teamB}</td>
                <td>${winnerText}</td>
            </tr>`;
        });

        html += `</tbody></table></div>`;
    });

    courtMatchesDiv.innerHTML = html;
}

// H√†m render chung, g·ªçi renderMatchesView() ƒë·ªÉ ƒë·∫£m b·∫£o ƒë√∫ng ch·∫ø ƒë·ªô xem
function renderMatches() {
    renderMatchesView();
}


// --- X·∫øp h·∫°ng V√≤ng B·∫£ng ---

/**
 * T√≠nh to√°n b·∫£ng x·∫øp h·∫°ng cho m·ªôt danh s√°ch ƒë·ªôi v√† c√°c tr·∫≠n ƒë·∫•u c·ªßa h·ªç.
 * @param {Array<string>} teams - Danh s√°ch t√™n ƒë·ªôi
 * @param {Array<Match>} matches - Danh s√°ch c√°c tr·∫≠n ƒë·∫•u
 * @returns {Array<RankingEntry>} - B·∫£ng x·∫øp h·∫°ng
 */
function calculateRanking(teams, matches) {
    const ranking = teams.map(team => ({
        team: team,
        played: 0,
        wins: 0,
        losses: 0,
        draws: 0,
        scoreFor: 0,
        scoreAgainst: 0,
        scoreDiff: 0,
        points: 0 // Th·∫Øng: 3, H√≤a: 1, Thua: 0 (gi·∫£ ƒë·ªãnh)
    }));

    matches.forEach(match => {
        if (match.scoreA !== null && match.scoreB !== null) {
            const teamAIndex = ranking.findIndex(r => r.team === match.teamA);
            const teamBIndex = ranking.findIndex(r => r.team === match.teamB);

            if (teamAIndex === -1 || teamBIndex === -1) return;

            const rA = ranking[teamAIndex];
            const rB = ranking[teamBIndex];

            // C·∫≠p nh·∫≠t s·ªë tr·∫≠n ƒë√£ ƒë·∫•u
            rA.played++;
            rB.played++;

            // C·∫≠p nh·∫≠t ƒëi·ªÉm s·ªë b√†n th·∫Øng/thua
            rA.scoreFor += match.scoreA;
            rA.scoreAgainst += match.scoreB;
            rB.scoreFor += match.scoreB;
            rB.scoreAgainst += match.scoreA;

            // C·∫≠p nh·∫≠t th·∫Øng/thua/h√≤a v√† ƒëi·ªÉm
            if (match.scoreA > match.scoreB) {
                // A th·∫Øng
                rA.wins++;
                rA.points += 3;
                rB.losses++;
            } else if (match.scoreB > match.scoreA) {
                // B th·∫Øng
                rB.wins++;
                rB.points += 3;
                rA.losses++;
            } else {
                // H√≤a
                rA.draws++;
                rB.draws++;
                rA.points += 1;
                rB.points += 1;
            }
        }
    });

    // C·∫≠p nh·∫≠t hi·ªáu s·ªë
    ranking.forEach(r => {
        r.scoreDiff = r.scoreFor - r.scoreAgainst;
    });

    // S·∫Øp x·∫øp: 
    // 1. ƒêi·ªÉm
    // 2. Hi·ªáu s·ªë b√†n th·∫Øng
    // 3. T·ªïng s·ªë b√†n th·∫Øng (B√†n th·∫Øng ƒë·ªëi ƒë·∫ßu n·∫øu c√≥, nh∆∞ng ·ªü ƒë√¢y d√πng chung)
    ranking.sort((a, b) => {
        if (b.points !== a.points) return b.points - a.points;
        if (b.scoreDiff !== a.scoreDiff) return b.scoreDiff - a.scoreDiff;
        return b.scoreFor - a.scoreFor;
    });

    return ranking;
}

function tinhVaCapNhatXepHang() {
    state.tableA = calculateRanking(state.mixedTeams, state.matchesA);
    state.tableB = calculateRanking(state.maleTeams, state.matchesB);
    renderRankingTables();
    scheduleFinalsAuto(false); // C·∫≠p nh·∫≠t v√≤ng CK nh∆∞ng kh√¥ng show modal
}


function renderRankingTables() {
    const container = document.getElementById('rankingTables');
    if (!container) return;

    // Render B·∫£ng A
    let htmlA = renderSingleRankingTable('B·∫£ng A (Nam - N·ªØ)', state.tableA, 'primary');
    
    // Render B·∫£ng B
    let htmlB = renderSingleRankingTable('B·∫£ng B (Nam)', state.tableB, 'info');

    container.innerHTML = htmlA + htmlB;
}

function renderSingleRankingTable(title, table, type) {
    if (table.length === 0) {
        return `<div><h6>${title}</h6><div class="alert alert-warning">Ch∆∞a c√≥ d·ªØ li·ªáu x·∫øp h·∫°ng.</div></div>`;
    }
    
    let html = `
    <div>
        <h6 class="text-${type}">${title}</h6>
        <div class='table-responsive'><table class='table table-bordered table-striped table-sm'>
            <thead>
                <tr class="table-${type}">
                    <th>#</th>
                    <th>ƒê·ªôi</th>
                    <th>ƒê√£ ƒë·∫•u</th>
                    <th>Th·∫Øng</th>
                    <th>H√≤a</th>
                    <th>Thua</th>
                    <th>+/-</th>
                    <th>ƒêi·ªÉm</th>
                </tr>
            </thead>
            <tbody>`;
            
    table.forEach((row, index) => {
        const rank = index + 1;
        let rowClass = '';
        if (rank === 1) rowClass = 'table-success';
        if (rank === 2) rowClass = 'table-warning';
        
        html += `<tr class="${rowClass}">
            <td>${rank}</td>
            <td>${row.team}</td>
            <td>${row.played}</td>
            <td>${row.wins}</td>
            <td>${row.draws}</td>
            <td>${row.losses}</td>
            <td>${row.scoreDiff}</td>
            <td><strong>${row.points}</strong></td>
        </tr>`;
    });

    html += `</tbody></table></div></div>`;
    return html;
}

// --- V√≤ng Chung K·∫øt ---

/**
 * T·ª± ƒë·ªông l√™n l·ªãch B√°n k·∫øt v√† Chung k·∫øt d·ª±a tr√™n k·∫øt qu·∫£ v√≤ng b·∫£ng.
 * @param {boolean} showAlert - Hi·ªÉn th·ªã modal th√¥ng b√°o hay kh√¥ng (m·∫∑c ƒë·ªãnh l√† true)
 */
function scheduleFinalsAuto(showAlert = true) {
    if (state.tableA.length < 2 || state.tableB.length < 2) {
        if (showAlert) showModal('L·ªói', 'Ch∆∞a ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ x·∫øp h·∫°ng (√≠t nh·∫•t 2 ƒë·ªôi/b·∫£ng) ho·∫∑c ch∆∞a c√≥ tr·∫≠n ƒë·∫•u n√†o ho√†n th√†nh.');
        renderFinals();
        renderFinalResults();
        return;
    }
    
    // L·∫•y top 2 c·ªßa m·ªói b·∫£ng (Rank 1 v√† Rank 2)
    const teamsACompletedAll = state.mixedTeams.length > 0 ? state.mixedTeams.every(team => state.tableA.find(r => r.team === team && r.played === state.mixedTeams.length - 1)) : false;
    const teamsBCompletedAll = state.maleTeams.length > 0 ? state.maleTeams.every(team => state.tableB.find(r => r.team === team && r.played === state.maleTeams.length - 1)) : false;
    
    const allMatchesCompleted = teamsACompletedAll && teamsBCompletedAll;

    const nhatA = teamsACompletedAll ? state.tableA[0].team : 'Nh·∫•t A';
    const nhiA = teamsACompletedAll ? state.tableA[1].team : 'Nh√¨ A';
    const nhatB = teamsBCompletedAll ? state.tableB[0].team : 'Nh·∫•t B';
    const nhiB = teamsBCompletedAll ? state.tableB[1].team : 'Nh√¨ B';
    
    
    let teamSF1_A = 'Nh·∫•t A';
    let teamSF1_B = 'Nh·∫•t B';
    let teamSF2_A = 'Nh√¨ B'; // Ch√∫ √Ω: Nh√¨ B vs Nh√¨ A
    let teamSF2_B = 'Nh√¨ A';

    if (allMatchesCompleted) {
        teamSF1_A = nhatA;
        teamSF1_B = nhatB;
        teamSF2_A = nhiB;
        teamSF2_B = nhiA;
        
        if (showAlert) showModal('Th√†nh c√¥ng', 'ƒê√£ c·∫≠p nh·∫≠t ƒë·ªôi v√†o V√≤ng B√°n k·∫øt d·ª±a tr√™n k·∫øt qu·∫£ V√≤ng B·∫£ng.');
    } else if (showAlert) {
        showModal('C·∫£nh b√°o', 'V√≤ng B·∫£ng ch∆∞a ho√†n th√†nh, V√≤ng B√°n k·∫øt ƒëang hi·ªÉn th·ªã theo v·ªã tr√≠ t·∫°m th·ªùi.');
    }
    
    // Gi·ªØ nguy√™n t·ªâ s·ªë n·∫øu ƒë√£ c√≥, ch·ªâ c·∫≠p nh·∫≠t t√™n ƒë·ªôi
    state.semifinals[0].teamA = teamSF1_A;
    state.semifinals[0].teamB = teamSF1_B;
    state.semifinals[1].teamA = teamSF2_A;
    state.semifinals[1].teamB = teamSF2_B;
    
    // C·∫≠p nh·∫≠t v√≤ng chung k·∫øt
    const winnerSF1 = state.semifinals[0].winner || 'Th·∫Øng SF1';
    const winnerSF2 = state.semifinals[1].winner || 'Th·∫Øng SF2';
    
    state.final.teamA = winnerSF1;
    state.final.teamB = winnerSF2;
    
    // C·∫≠p nh·∫≠t k·∫øt qu·∫£ cu·ªëi
    if (state.final.winner) {
        state.final.runnerUp = state.final.loser;
    } else {
        state.final.runnerUp = null;
    }
    
    renderFinals();
    renderFinalResults();
    stateChanged = true;
    if (showAlert) saveToGitHub();
}


function renderFinals() {
    const sMatches = state.semifinals;
    const final = state.final;
    const container = document.getElementById('semifinalMatches');
    const finalContainer = document.getElementById('finalMatch');
    
    if (!container || !finalContainer) return;
    
    // --- Render B√°n k·∫øt ---
    let sHtml = `<div class='table-responsive'><table class='table table-bordered table-striped table-sm'>
        <thead>
            <tr class="table-danger">
                <th>Tr·∫≠n</th>
                <th>Gi·ªù/S√¢n</th>
                <th>ƒê·ªôi A</th>
                <th class="text-center">T·ªâ s·ªë</th>
                <th>ƒê·ªôi B</th>
                <th>K·∫øt qu·∫£</th>
            </tr>
        </thead>
        <tbody>`;
        
    sMatches.forEach((match, index) => {
        const teamAClass = match.winner === match.teamA ? 'winner' : (match.loser === match.teamA ? 'loser' : '');
        const teamBClass = match.winner === match.teamB ? 'winner' : (match.loser === match.teamB ? 'loser' : '');
        const winnerText = match.winner ? match.winner : 'ƒêang ƒë·∫•u';
        
        // Disable input n·∫øu ƒë·ªôi ch∆∞a ƒë∆∞·ª£c x√°c ƒë·ªãnh
        const disabledA = (match.teamA === 'Nh·∫•t A' || match.teamA === 'Nh√¨ B') ? 'disabled' : '';
        const disabledB = (match.teamB === 'Nh·∫•t B' || match.teamB === 'Nh√¨ A') ? 'disabled' : '';
        const disabledSF = disabledA || disabledB;

        sHtml += `<tr>
            <td>${match.id}</td>
            <td>${match.time}, ${match.court}</td>
            <td class="${teamAClass}">${match.teamA}</td>
            <td class="match-score-cell d-flex justify-content-center align-items-center">
                <input type='number' min='0' value='${match.scoreA !== null ? match.scoreA : ''}' onchange='capNhatTiSo(this, "semifinals", "${match.id}", true)' class='form-control form-control-sm' ${disabledSF}>
                -
                <input type='number' min='0' value='${match.scoreB !== null ? match.scoreB : ''}' onchange='capNhatTiSo(this, "semifinals", "${match.id}", false)' class='form-control form-control-sm' ${disabledSF}>
            </td>
            <td class="${teamBClass}">${match.teamB}</td>
            <td>${winnerText}</td>
        </tr>`;
    });
    
    sHtml += `</tbody></table></div>`;
    container.innerHTML = sHtml;

    // --- Render Chung k·∫øt ---
    let fHtml = `<div class='table-responsive'><table class='table table-bordered table-striped table-sm'>
        <thead>
            <tr class="table-danger">
                <th>Tr·∫≠n</th>
                <th>Gi·ªù/S√¢n</th>
                <th>ƒê·ªôi A</th>
                <th class="text-center">T·ªâ s·ªë</th>
                <th>ƒê·ªôi B</th>
                <th>K·∫øt qu·∫£</th>
            </tr>
        </thead>
        <tbody>`;
        
    const disabledF = (final.teamA === 'Th·∫Øng SF1' || final.teamB === 'Th·∫Øng SF2') ? 'disabled' : '';
    
    fHtml += `<tr>
        <td>${final.id}</td>
        <td>${final.time}, ${final.court}</td>
        <td class="${final.winner === final.teamA ? 'winner' : (final.loser === final.teamA ? 'loser' : '')}">${final.teamA}</td>
        <td class="match-score-cell d-flex justify-content-center align-items-center">
            <input type='number' min='0' value='${final.scoreA !== null ? final.scoreA : ''}' onchange='capNhatTiSo(this, "final", "${final.id}", true)' class='form-control form-control-sm' ${disabledF}>
            -
            <input type='number' min='0' value='${final.scoreB !== null ? final.scoreB : ''}' onchange='capNhatTiSo(this, "final", "${final.id}", false)' class='form-control form-control-sm' ${disabledF}>
        </td>
        <td class="${final.winner === final.teamB ? 'winner' : (final.loser === final.teamB ? 'loser' : '')}">${final.teamB}</td>
        <td>${final.winner ? final.winner + ' V√¥ ƒë·ªãch' : 'ƒêang ƒë·∫•u'}</td>
    </tr>`;
    fHtml += `</tbody></table></div>`;
    finalContainer.innerHTML = fHtml;
}


function renderFinalResults() {
    const final = state.final;
    const sf1Loser = state.semifinals[0].loser;
    const sf2Loser = state.semifinals[1].loser;
    
    let thirdPlaceTeams = [];
    if (sf1Loser) thirdPlaceTeams.push(sf1Loser);
    if (sf2Loser) thirdPlaceTeams.push(sf2Loser);

    document.getElementById('champion').innerHTML = final.winner 
        ? `<span class="badge bg-success">ü•á V√¥ ƒë·ªãch: ${final.winner}</span>` 
        : 'V√¥ ƒë·ªãch: ƒêang ch·ªù k·∫øt qu·∫£...';

    document.getElementById('runnerUp').innerHTML = final.runnerUp 
        ? `<span class="badge bg-secondary">ü•à √Å qu√¢n: ${final.runnerUp}</span>` 
        : '√Å qu√¢n: ƒêang ch·ªù k·∫øt qu·∫£...';
        
    document.getElementById('thirdPlace').innerHTML = thirdPlaceTeams.length >= 1
        ? `<span class="badge bg-info">ü•â H·∫°ng Ba ƒê·ªìng H·∫°ng: ${thirdPlaceTeams.join(' & ')}</span>`
        : 'H·∫°ng Ba ƒê·ªìng H·∫°ng: ƒêang ch·ªù k·∫øt qu·∫£...';
}

// --- C√¥ng c·ª• (ƒêi·ªÅn/X√≥a) ---

function autoFillScores() {
    const fillScore = 11;
    const winRate = 0.6; // T·ªâ l·ªá th·∫Øng 60%

    // V√≤ng B·∫£ng A
    state.matchesA.forEach(match => {
        if (match.scoreA === null && match.scoreB === null) {
            let scoreA, scoreB;
            if (Math.random() < winRate) {
                // Team A th·∫Øng
                scoreA = fillScore;
                scoreB = Math.floor(Math.random() * 10);
            } else {
                // Team B th·∫Øng
                scoreB = fillScore;
                scoreA = Math.floor(Math.random() * 10);
            }
            match.scoreA = scoreA;
            match.scoreB = scoreB;
            match.winner = scoreA > scoreB ? match.teamA : match.teamB;
            match.loser = scoreA < scoreB ? match.teamA : match.teamB;
        }
    });

    // V√≤ng B·∫£ng B
    state.matchesB.forEach(match => {
        if (match.scoreA === null && match.scoreB === null) {
            let scoreA, scoreB;
            if (Math.random() < winRate) {
                // Team A th·∫Øng
                scoreA = fillScore;
                scoreB = Math.floor(Math.random() * 10);
            } else {
                // Team B th·∫Øng
                scoreB = fillScore;
                scoreA = Math.floor(Math.random() * 10);
            }
            match.scoreA = scoreA;
            match.scoreB = scoreB;
            match.winner = scoreA > scoreB ? match.teamA : match.teamB;
            match.loser = scoreA < scoreB ? match.teamA : match.teamB;
        }
    });

    // V√≤ng B√°n k·∫øt (ch·ªâ ƒëi·ªÅn n·∫øu ƒë√£ c√≥ ƒë·ªôi x√°c ƒë·ªãnh)
    state.semifinals.forEach(match => {
        if (match.scoreA === null && match.scoreB === null && match.teamA.indexOf('Nh·∫•t') === -1 && match.teamB.indexOf('Th·∫Øng') === -1) {
            let scoreA, scoreB;
             if (Math.random() < winRate) {
                scoreA = fillScore;
                scoreB = Math.floor(Math.random() * 10);
            } else {
                scoreB = fillScore;
                scoreA = Math.floor(Math.random() * 10);
            }
            match.scoreA = scoreA;
            match.scoreB = scoreB;
            match.winner = scoreA > scoreB ? match.teamA : match.teamB;
            match.loser = scoreA < scoreB ? match.teamA : match.teamB;
        }
    });
    
    // V√≤ng Chung k·∫øt (ch·ªâ ƒëi·ªÅn n·∫øu ƒë√£ c√≥ ƒë·ªôi x√°c ƒë·ªãnh)
    const final = state.final;
    if (final.scoreA === null && final.scoreB === null && final.teamA.indexOf('Th·∫Øng') === -1 && final.teamB.indexOf('Th·∫Øng') === -1) {
        let scoreA, scoreB;
         if (Math.random() < 0.5) { // T·ªâ l·ªá 50/50 cho chung k·∫øt
            scoreA = fillScore;
            scoreB = Math.floor(Math.random() * 10);
        } else {
            scoreB = fillScore;
            scoreA = Math.floor(Math.random() * 10);
        }
        final.scoreA = scoreA;
        final.scoreB = scoreB;
        final.winner = scoreA > scoreB ? final.teamA : final.teamB;
        final.runnerUp = scoreA < scoreB ? final.teamA : final.teamB;
        final.loser = final.runnerUp;
    }


    renderMatches();
    tinhVaCapNhatXepHang();
    renderFinals();
    renderFinalResults();
    stateChanged = true;
    showModal('Ho√†n th√†nh', 'ƒê√£ ƒëi·ªÅn ng·∫´u nhi√™n (11 - X) cho c√°c tr·∫≠n ch∆∞a c√≥ k·∫øt qu·∫£.');
    saveToGitHub();
}

function clearAllSchedules() {
    if (confirm("B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën X√ìA T·∫§T C·∫¢ L·ªäCH THI ƒê·∫§U (V√≤ng B·∫£ng & Chung k·∫øt) v√† K·∫æT QU·∫¢ ƒê√É ƒêI·ªÄN kh√¥ng? Thao t√°c n√†y KH√îNG th·ªÉ ho√†n t√°c.")) {
        state.matchesA = [];
        state.matchesB = [];
        state.tableA = [];
        state.tableB = [];
        
        state.semifinals = [
            { id: 'SF1', teamA: 'Nh·∫•t A', teamB: 'Nh·∫•t B', scoreA: null, scoreB: null, time: '16:30', court: 'S√¢n 1', winner: null, loser: null },
            { id: 'SF2', teamA: 'Nh√¨ B', teamB: 'Nh√¨ A', scoreA: null, scoreB: null, time: '16:30', court: 'S√¢n 2', winner: null, loser: null }
        ];
        state.final = { id: 'F', teamA: 'Th·∫Øng SF1', teamB: 'Th·∫Øng SF2', scoreA: null, scoreB: null, time: '17:00', court: 'S√¢n 1', winner: null, runnerUp: null };

        renderMatches();
        renderRankingTables();
        renderFinals();
        renderFinalResults();
        renderOverview();
        stateChanged = true;
        showModal('Th√†nh c√¥ng', 'ƒê√£ x√≥a to√†n b·ªô l·ªãch thi ƒë·∫•u v√† k·∫øt qu·∫£.');
        saveToGitHub();
    }
}


// --- Import/Export CSV ---

function handleFileSelect(event) {
    const file = event.target.files[0];
    if (!file) {
        return;
    }
    
    if (file.type !== 'text/csv' && !file.name.endsWith('.csv')) {
         showModal('L·ªói', 'Vui l√≤ng ch·ªçn file ƒë·ªãnh d·∫°ng CSV.');
         event.target.value = ''; // Reset input file
         return;
    }

    const reader = new FileReader();
    reader.onload = (e) => {
        const csvContent = e.target.result;
        importSchedule(csvContent);
        event.target.value = ''; // Reset input file
    };
    reader.onerror = () => {
        showModal('L·ªói', 'Kh√¥ng th·ªÉ ƒë·ªçc file.');
        event.target.value = '';
    };
    reader.readAsText(file, 'UTF-8');
}

function importSchedule(csvContent) {
    try {
        const matches = [];
        const rows = csvContent.trim().split('\n').map(row => row.trim());
        
        if (rows.length < 2) {
            showModal('L·ªói', 'File CSV kh√¥ng h·ª£p l·ªá (√≠t h∆°n 2 d√≤ng).');
            return;
        }

        const headers = rows[0].split(',').map(h => h.trim());
        const expectedHeaders = ["teamA", "teamB", "time", "court", "bang", "scoreA", "scoreB"];
        
        // Ki·ªÉm tra header (t√πy ch·ªçn, ƒë·ªÉ ƒë·∫£m b·∫£o ƒë√∫ng ƒë·ªãnh d·∫°ng export)
        if (headers.length < expectedHeaders.length || expectedHeaders.some((h, i) => h !== headers[i])) {
            // Ch·∫•p nh·∫≠n file CSV c·ªë ƒë·ªãnh n·∫øu kh√¥ng kh·ªõp header
            try {
                const fixedData = parseFixedSchedule(csvContent, state.mixedTeams, state.maleTeams);
                if (fixedData.matchesA.length > 0 || fixedData.matchesB.length > 0) {
                     state.matchesA = fixedData.matchesA;
                     state.matchesB = fixedData.matchesB;
                     
                     renderMatches();
                     tinhVaCapNhatXepHang();
                     renderOverview();
                     stateChanged = true;
                     showModal('Th√†nh c√¥ng', `ƒê√£ Import ${fixedData.matchesA.length + fixedData.matchesB.length} tr·∫≠n ƒë·∫•u t·ª´ file CSV (D·∫°ng L·ªãch C·ªë ƒë·ªãnh).`);
                     saveToGitHub();
                     return;
                }
            } catch (e) {
                console.error("L·ªói khi c·ªë g·∫Øng ƒë·ªçc file CSV d∆∞·ªõi d·∫°ng L·ªãch C·ªë ƒë·ªãnh:", e);
                showModal('L·ªói', 'File CSV kh√¥ng kh·ªõp v·ªõi ƒë·ªãnh d·∫°ng chu·∫©n. Vui l√≤ng ki·ªÉm tra l·∫°i.');
                return;
            }
        }


        // N·∫øu kh·ªõp ƒë·ªãnh d·∫°ng chu·∫©n (xu·∫•t ra t·ª´ tool n√†y)
        for (let i = 1; i < rows.length; i++) {
            const cols = rows[i].split(',').map(c => c.trim());
            
            if (cols.length >= expectedHeaders.length) {
                const match = {
                    teamA: cols[0],
                    teamB: cols[1],
                    time: cols[2],
                    court: cols[3],
                    bang: cols[4],
                    scoreA: cols[5] ? parseInt(cols[5]) : null,
                    scoreB: cols[6] ? parseInt(cols[6]) : null
                };

                // T√≠nh l·∫°i winner/loser
                if (match.scoreA !== null && match.scoreB !== null) {
                    if (match.scoreA > match.scoreB) {
                        match.winner = match.teamA;
                        match.loser = match.teamB;
                    } else if (match.scoreB > match.scoreA) {
                        match.winner = match.teamB;
                        match.loser = match.teamA;
                    } else {
                        match.winner = null;
                        match.loser = null;
                    }
                } else {
                    match.winner = null;
                    match.loser = null;
                }
                matches.push(match);
            }
        }

        state.matchesA = matches.filter(m => m.bang === 'A').sort((a, b) => parseTime(a.time) - parseTime(b.time));
        state.matchesB = matches.filter(m => m.bang === 'B').sort((a, b) => parseTime(a.time) - parseTime(b.time));

        renderMatches();
        tinhVaCapNhatXepHang();
        renderOverview();
        stateChanged = true;
        showModal('Th√†nh c√¥ng', `ƒê√£ Import ${matches.length} tr·∫≠n ƒë·∫•u t·ª´ file CSV.`);
        saveToGitHub();
        
    } catch (e) {
        console.error("L·ªói khi ƒë·ªçc file CSV:", e);
        showModal('L·ªói', `ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω file CSV: ${e.message}`);
    }
}


function exportSchedule() {
    // T·∫°o header
    let csvContent = "teamA,teamB,time,court,bang,scoreA,scoreB\n";
    
    // G·ªôp v√† s·∫Øp x·∫øp t·∫•t c·∫£ c√°c tr·∫≠n
    const allMatches = [...state.matchesA, ...state.matchesB].sort((a, b) => {
        const timeA = parseTime(a.time);
        const timeB = parseTime(b.time);
        if (timeA !== timeB) return timeA - timeB;
        if (a.court < b.court) return -1;
        if (a.court > b.court) return 1;
        return 0;
    });

    // Th√™m d·ªØ li·ªáu tr·∫≠n ƒë·∫•u
    allMatches.forEach(match => {
        const scoreA = match.scoreA !== null ? match.scoreA : '';
        const scoreB = match.scoreB !== null ? match.scoreB : '';
        
        csvContent += `${match.teamA},${match.teamB},${match.time},${match.court},${match.bang},${scoreA},${scoreB}\n`;
    });

    // T·∫°o Blob v√† download
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.setAttribute('href', url);
    link.setAttribute('download', 'schedule_export_' + new Date().toISOString().slice(0, 10) + '.csv');
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    showModal('Ho√†n th√†nh', 'ƒê√£ Export l·ªãch thi ƒë·∫•u v√† k·∫øt qu·∫£ ra file CSV.');
}

</script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
